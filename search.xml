<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Performance Benchmarking and Optimizing Hyperledger Fabric Blockchain Platform</title>
      <link href="/2020/04/04/Performance-Benchmarking-and-Optimizing-Hyperledger-Fabric-Blockchain-Platform/"/>
      <url>/2020/04/04/Performance-Benchmarking-and-Optimizing-Hyperledger-Fabric-Blockchain-Platform/</url>
      
        <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><blockquote><p>The rise in popularity of permissioned blockchain platforms in recent time is significant. Hyperledger Fabric is one such permissioned blockchain platform and one of the Hyperledger projects hosted by the Linux Foundation.</p><p>The Fabric comprises of various components such as smart-contracts, endorsers, committers, validators, and orderers.</p><p>As the performance of blockchain platform is a major concern for enterprise applications, in this work, we perform a comprehensive empirical study to characterize the performance of Hyperledger Fabric and identify potential performance bottlenecks to gain a better understanding of the system.</p></blockquote><p>最近一段时间，许可链平台的流行度显着上升。 Hyperledger Fabric 是一种这样的许可链平台，也是 Linux 基金会托管的 Hyperledger 项目之一。</p><p>Fabric 由各种组件组成，例如智能合约，背书节点，提交节点，验证节点和排序节点。</p><p>由于区块链平台的性能是企业应用程序的主要关注点，因此在这项工作中，我们进行了全面的实证研究，以表征 Hyperledger Fabric 的性能并确定潜在的性能瓶颈，以更好地了解系统。</p><blockquote><p>We follow a two-phased approach.</p><p>In the first phase, our goal is to understand the impact of various configuration parameters such as block size, endorsement policy, channels, resource allocation, state database choice on the transaction throughput &amp; latency to provide various guidelines on configuring these parameters.</p><p>In addition, we also aim to identify performance bottlenecks and hotspots. We observed that (1) endorsement policy verification, (2) sequential policy validation of transactions in a block, and (3) state validation and commit (with CouchDB) were the three major bottlenecks.</p></blockquote><p>我们遵循两阶段的方法。</p><p>在第一阶段，我们的目标是了解各种配置参数（例如块大小、背书策略、通道、资源配置、状态数据库选择）对交易吞吐量和延迟的影响，以提供有关配置这些参数的各种指导。</p><p>此外，我们还旨在确定性能瓶颈和热点。 我们观察到（1）背书策略验证，（2）块中交易的顺序策略验证，（3）状态验证和提交（使用 CouchDB）是三个主要瓶颈。</p><blockquote><p>In the second phase, we focus on optimizing Hyperledger Fabric v1.0 based on our observations.</p><p>We introduced and studied various simple optimizations such as aggressive caching for endorsement policy verification in the cryptography component (3× improvement in the performance) and parallelizing endorsement policy verification (7× improvement). </p><p>Further, we enhanced and measured the effect of an existing bulk read/write optimization for CouchDB during state validation &amp; commit phase (2.5× improvement). </p><p>By combining all three optimizations, we improved the overall throughput by 16× (i.e., from 140 tps to 2250 tps).</p></blockquote><p>在第二阶段，我们将根据我们的观察优化 Hyperledger Fabric v1.0。</p><p>我们介绍并研究各种简单的优化方法，例如在加密组件中进行背书策略验证的主动缓存（性能提高了 3 倍）和并行化背书策略验证（提高 7 倍）。</p><p>此外，我们在验证和提交阶段期间增强并测量了现有的针对 CouchDB 批量读写优化的效果（提高 2.5 倍）。</p><p>通过结合这 3 个优化，我们将整体吞吐量提升了 16 倍，即从 140 tps 到 2250 tps。</p><h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><blockquote><p>Blockchain technologies initially gained popularity as they were seen as a way to get rid of the intermediary and decentralize the system. Since then, blockchain has witnessed a growing interest from different domains and use cases. A blockchain is a shared, distributed ledger that records transactions and is maintained by multiple nodes in the network where nodes do not trust each other. Each node holds the identical copy of the ledger which is usually represented as a chain of blocks, with each block being a logical sequence of transactions. Each block encloses the hash of its immediate previous block, thereby guaranteeing the immutability of ledger.</p></blockquote><p>区块链最初开始流行是因为它们被认为是一种摆脱中介和去中心化系统的方式。从那之后，区块链见证了来自不同领域和用例日益增长的兴趣。</p><p>区块链是一个共享的、分布式的账本，它记录交易并由网络中互不信任的多个节点共同维护。每个节点都拥有该账本的相同副本，账本通常由区块链表示，每个区块都是交易的逻辑顺序。每个交易都包含前一个区块的哈希，从而保证了账本的不可篡改。</p><blockquote><p>Blockchain is often hailed as a new breed of database systems, in essence being a distributed transaction processing system where the nodes are not trusted and the system needs to achieve Byzantine fault tolerance. Blockchain provides serializability, immutability, and cryptographic verifiability without a single point of trust unlike a database system; properties that have triggered blockchain adoption in a wide variety of industries.</p></blockquote><p>区块链通常被誉为一种新型的数据库系统，本质上是一个分布式的交易处理系统，其中的节点不受信任，并且这个系统需要实现拜占庭容错。与数据库系统不同，区块链在没有单一信任点的情况下提供了可串行性、不可篡改性和加密可验证性；引发区块链在众多行业中采用的特性。</p><blockquote><p>A blockchain network can be either permissionless or permissioned. </p><p>In a permissionless network or public network such as Bitcoin, Ethereum, anyone can join the network to perform transactions. Due to a large number of nodes in a public network, a proof-of-work consensus approach is used to order transactions and create a block.</p><p>In a permissioned network, the identity of each participant is known and authenticated cryptographically such that blockchain can store who performed which transaction. In addition, such a network can have extensive access control mechanisms built-in to limit who can (a) read &amp; append to ledger data, (b) issue transactions, (c) administer participation in the blockchain network.</p></blockquote><p>区块链网络可以是未经许可的或经过许可的。</p><p>在未经许可的网络或公共网络（例如比特币、以太坊）中，任何人都可以加入网络以执行交易。由于公共网络中有大量节点，因此采用工作量证明共识算法来对交易进行排序并创建一个区块。</p><p>在经过许可的网络中，每个参与者的身份都是已知的，通过密码验证，区块链可以存储谁执行了哪个交易。此外，这样的网络可以内置广泛的网络控制机制来限制谁可以（a）读取并添加账本数据，（b）发送交易，（c）管理参与区块链网络。</p><blockquote><p>A permissioned network is highly suitable for enterprise applications that require authenticated participants. Each node in a permissioned network can be owned by different organizations. Further, enterprise applications need complex data models and expressibility which can be supported using smart-contracts. Enterprises find value in being able to integrate diverse systems without having to build a centralized solution and to bring a level of trust among untrusting parties or to bring in a trusted third-party. Trade Finance and Food Safety are examples of blockchain applications where participants see value in visibility advantages it offers as compared to the existing loosely coupled centralized systems.</p></blockquote><p>许可网络非常适合需要验证参与者身份的企业应用程序。 许可网络中的每个节点可以由不同的组织拥有。 此外，企业应用程序需要复杂的数据模型和可表达性，可以使用智能合约来支持它们。 企业发现了能够集成各种系统而无需构建集中式解决方案并在非信任方之间建立信任度或引入受信任的第三方的价值。 贸易金融和食品安全是区块链应用的例子，与现有的松散耦合的集中式系统相比，参与者在其可见性优势中看到了价值。</p><blockquote><p>There is a lot of concern about the performance of permissioned blockchain platforms and their ability to handle a huge volume of transactions at low latency. Another concern is the richness of language to describe the transactions. Different blockchain platforms such as Quorum, Corda address these concerns using different techniques derived from the distributed systems domain. Hyperledger Fabric is an enterprise-grade open-source permissioned blockchain platform which has a modular design and a high degree of specifiability through trust models and pluggable components. Fabric is currently being used in many different use cases such as Global Trade Digitization, SecureKey, Everledger and is the focus of our performance study.</p></blockquote><p>对于许可链平台的性能及其以低延迟处理大量事务的能力，存在很多担忧。 另一个问题是描述交易的语言丰富。 Quorum，Corda 等不同的区块链平台使用源自分布式系统领域的不同技术来解决这些问题。Hyperledger Fabric 是企业级开源许可链平台，具有模块化设计，并通过信任模型和可插拔组件实现高度可定制性。 目前，Fabric 已在许多不同的用例中使用，例如全球贸易数字化，SecureKey，Everledger，这是我们性能研究的重点。</p><blockquote><p>Fabric consists of various components such as endorsers, ordering service, and committers. Further, it constitutes various phases in processing a transaction such as endorsement phase, ordering phase, validation and commit phase. Due to numerous components and phases, Fabric provides various configurable parameters such as block size, endorsement policy, channels, state database. Hence, one of the main challenges in setting up an efficient blockchain network is finding the right set of values for these parameters. For e.g., depending on the application and requirements, one might need to answer the following questions:</p><ul><li><p>What should be the block size to achieve a lower latency?</p></li><li><p>How many channels can be created and what should be</p><p>  the resource allocation?</p></li><li><p>What types of endorsement policy is more efficient?</p></li><li><p>How much is the performance difference between</p><p>  GoLevelDB and CocuhDB when it is used as the</p><p>  state database?</p></li></ul></blockquote><p>Fabric 由各种组件组成，例如智能合约，背书节点，提交节点，验证节点和排序节点。此外，它还构成了处理交易的各个阶段，例如背书阶段，排序阶段，验证和提交阶段。由于组件和阶段众多，Fabric 提供了各种可配置的参数，例如块大小，背书策略，通道，状态数据库。因此，建立有效的区块链网络的主要挑战之一是为这些参数找到正确的值集。例如，根据应用和要求，可能需要回答以下问题：</p><ul><li>达到较低延迟的块大小应该是多少？</li><li>可以创建多少个通道，应该怎么分配资源？</li><li>哪种类型的认可政策更有效？</li><li>GoLevelDB 和 CocuhDB 用作状态数据库时它们之间的性能差异有多少？</li></ul><blockquote><p>To answer above questions and to identify the performance bottlenecks, we perform a comprehensive empirical study of Fabric v1.0 with various configurable parameters. Specifically, our three major contributions are listed below.</p><ol><li>We conducted a comprehensive empirical study of Fabric platform by varying values assigned to the five major parameters by conducting over 1000s of experiments. As a result, we provide six guidelines on configuring these parameters to attain the maximum performance.</li><li>We identified three major performance bottlenecks: (i) crypto operations, (ii) serial validation of transactions in a block, and (iii) multiple REST API calls to CouchDB.</li><li>Introduced and studied three simple optimizations to improve the overall performance by 16× (i.e., from 140 tps to 2250 tps) for a single channel environment.</li></ol></blockquote><p>为了回答上述问题并确定性能瓶颈，我们对 Fabric v1.0 的各种可配置参数的进行了全面的实证研究。 具体来说，以下是我们的三大贡献。</p><ol><li>我们通过进行1000多次实验，通过改变分配给五个主要参数的值，对Fabric 平台进行了全面的实证研究。 最终，我们提供了六种有关配置这些参数的准则以获得最佳性能。</li><li>我们确定了三个主要的性能瓶颈：（i）加密操作，（ii）块中交易的串行验证以及（iii）对 CouchDB 的多个 REST API 调用。</li><li>引入并研究了三种简单的优化方法，针对单个通道环境将整体性能提高16倍（即从 140 tps 到 2250 tps）。</li></ol><h1 id="II-BACKGROUND-HYPERLEDGER-FABRIC-ARCHITECTURE-amp-CONFIGURATION-PARAMETERS"><a href="#II-BACKGROUND-HYPERLEDGER-FABRIC-ARCHITECTURE-amp-CONFIGURATION-PARAMETERS" class="headerlink" title="II. BACKGROUND: HYPERLEDGER FABRIC ARCHITECTURE &amp; CONFIGURATION PARAMETERS"></a>II. BACKGROUND: HYPERLEDGER FABRIC ARCHITECTURE &amp; CONFIGURATION PARAMETERS</h1><blockquote><p>The Hyperledger Fabric is an implementation of permissioned blockchain system which has many unique properties suited for enterprise-class applications. It can run arbitrary smart contracts (a.k.a chaincodes) implemented in Go/JAVA/Nodejs language. It supports an application specifiable trust model for transaction validation and a pluggable consensus protocol to name a few. A Fabric network consists of different types of entities, peer nodes, ordering service nodes and clients, belonging to different organizations. Each of these has an identity on the network which is provided by a Membership Service Provider (MSP), typically associated with an organization. All entities in the network have visibility to identities of all organizations and can verify them.</p></blockquote><p>Hyperledger Fabric 是许可区块链系统的实现，具有许多适合企业级应用程序的独特属性。 它可以运行以 Go / JAVA / Nodejs 语言实现的任意智能合约（也称为链码）。 它支持用于事务验证的应用程序特定的信任模型和可插拔的共识协议等。 Fabric 网络由属于不同组织的不同类型的实体，对等节点，订购服务节点和客户端组成。 这些中的每一个在网络上都有一个身份，该身份由通常与组织相关联的成员资格服务提供商（MSP）提供。 网络中的所有实体都可以查看所有组织的身份，并可以对其进行验证。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 精读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dataExplorer打包优化</title>
      <link href="/2020/04/03/dataExplorer%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/"/>
      <url>/2020/04/03/dataExplorer%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><h3 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h3><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200403192753922.png" alt="image-20200403192753922" style="zoom:50%;"><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200403192922295.png" alt="image-20200403192922295" style="zoom:50%;"><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200403194220981.png" alt="image-20200403194220981" style="zoom:50%;"><h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>因为是 vue-cli 3.0，没有 webpack 配置文件了，在根目录下自己手动新建 <code>vue.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config</span><br><span class="line">    .plugin(<span class="string">'webpack-bundle-analyzer'</span>)</span><br><span class="line">    .use(<span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run server</span><br></pre></td></tr></table></figure><p>重新启动之后访问 <a href="http://127.0.0.1:8888" target="_blank" rel="noopener">http://127.0.0.1:8888</a> 就是可视化的图了</p><h2 id="Webpack-文件分离"><a href="#Webpack-文件分离" class="headerlink" title="Webpack 文件分离"></a>Webpack 文件分离</h2><p>Webpack 文件分离包括两个部分，一个是 Bundle 的分离，一个是 Code 代码的分离:</p><ul><li>Bundle splitting: 实际上就是创建多个更小的文件，并行加载，以获得更好的缓存效果；主要的作用就是使浏览器并行下载，提高下载速度。并且运用浏览器缓存，只有代码被修改，文件名中的哈希值改变了才会去再次加载。</li><li>Code splitting: 只加载用户最需要的部分，其余的代码都遵从懒加载的策略；主要的作用就是加快页面加载速度，不加载不必要加载的东西。</li></ul><h2 id="Bundle-splitting"><a href="#Bundle-splitting" class="headerlink" title="Bundle splitting"></a>Bundle splitting</h2><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config</span><br><span class="line">    .plugin(<span class="string">'webpack-bundle-analyzer'</span>)</span><br><span class="line">    .use(<span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin)</span><br><span class="line">  &#125;,</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            chunks: <span class="string">'all'</span>,</span><br><span class="line">            maxInitialRequests: <span class="literal">Infinity</span>,</span><br><span class="line">            minSize: <span class="number">0</span>,</span><br><span class="line">            minChunks: <span class="number">1</span>,</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">              commons: &#123;</span><br><span class="line">                test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">                name(<span class="built_in">module</span>) &#123;</span><br><span class="line">                  <span class="keyword">const</span> packageName = <span class="built_in">module</span>.context.match(<span class="regexp">/[\\/]node_modules[\\/](.*?)([\\/]|$)/</span>)[<span class="number">1</span>];</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">`modules.<span class="subst">$&#123;packageName.replace(<span class="string">'@'</span>, <span class="string">''</span>)&#125;</span>`</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先增加 maxInitialRequests 并设置成 Infinity，指定这个入口文件最大并行请求数</p><p>然后将 minSize 和 minChunks 分别设置成 0 和 1，即使模块非常小也将其提取出来，并且这个模块的引用次数只有 1 也要提取</p><p>最后配置匹配的依赖以及分离出的文件名格式</p><p>另外，我们还将运行时代码分离出来，这块代码还可以配合 <strong>InlineManifestWebpackPlugin</strong> 直接插入到 HTML 文件中。这里我们将这个配置设置成 single，即将所有chunk的运行代码打包到一个文件中</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里AE技术部-一面</title>
      <link href="/2020/04/02/%E9%98%BF%E9%87%8CAE%E6%8A%80%E6%9C%AF%E9%83%A8-%E4%B8%80%E9%9D%A2/"/>
      <url>/2020/04/02/%E9%98%BF%E9%87%8CAE%E6%8A%80%E6%9C%AF%E9%83%A8-%E4%B8%80%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>30 分钟凉经</p><ul><li><p>为什么选前端</p></li><li><p>你认为前端需要什么能力</p></li><li><p>介绍一下项目</p><ul><li>卡片和线装饰，线是用 svg 图片，高亮点沿线移动，用 kute.js 动画库</li></ul></li><li><p>不用 svg 的话可以用什么？</p><ul><li>canvas</li></ul></li><li><p>当时为什么不用</p><ul><li><p>不会画……</p><blockquote><p>项目这边应该是给了很不好的印象了，最后有跟我提到技术选型的问题</p></blockquote></li></ul></li><li><p>项目在你接手之前和之后有什么不同吗？有没有做什么优化</p><ul><li>没有……</li></ul></li><li><p>css position 的取值</p><ul><li>static</li><li>absolute</li><li>relative</li><li>fixed</li></ul></li><li><p>static 和 fixed 有什么区别？</p><ul><li>fixed 是相对于浏览器窗口定位的，static 我没用过不是太了解</li></ul></li><li><p>css 选择器</p><ul><li>权重叠加，important 最高，id 选择器第二</li></ul></li><li><p>事件冒泡和事件捕获的场景</p><ul><li>冒泡是点击的元素沿着 DOM 树一级级向上直到 Document，捕获相反</li><li>场景想不到，举了一个之前做项目的例子，currentTarget，onmousedown.stop</li></ul></li><li><p>项目用什么框架？打包原理清楚吗？webpack 之类的有配置过吗</p><ul><li><p>Vue</p></li><li><p>webpack 了解过，根据入口去找相关依赖，然后依赖导入的时候会用到 loader</p></li><li><p>配置了一个，就是让 .map 文件不打包出来，这样最终的包会小一点</p></li><li><blockquote><p>这一块其实没听太清楚，电话声音有点小，大概意思就是只是用了脚手架提供的功能，内置的东西没有去深入了解，不知道整个构建流程</p><p>感觉面试官是用 react 的，我说 vue 之后就没什么兴趣问了</p></blockquote></li></ul></li><li><p>图片懒加载怎么做的</p><ul><li>这个不清楚</li></ul></li><li><p>说一下 cookie</p><ul><li>sessionStorage 标签之间不共享，localstorage 永久存储， cookie 可以设置过期时间所以项目用了 cookie</li></ul></li><li><p>跨域</p><ul><li>平时一般是 CORS，还有就是 jsonp，jsonp 是利用 html 标签的 src 属性没有浏览器安全的限制，用回调函数实现跨域</li></ul></li><li><p>CORS 有配置过吗</p><ul><li>没有，都是后端配的</li></ul></li><li><p>有没有做过服务端</p><ul><li>写过 sdk，应该不算服务端吧</li></ul></li><li><p>有什么补充的吗</p><ul><li>之前调 bug 的时候用到 setTimeout(0)，就顺便学到了事件循环机制和 js 运行机制，后来回顾的时候知道 vue 里有个 nextTick，算是误打误撞实现了</li></ul></li><li><p>nextTick 和 setTimeout 有什么区别</p><ul><li><p>nextTick 是让回调函数在下一次页面渲染之后再去执行，setTimeout 只是实现 nextTick 的一种方式，也可以用 Promise 实现，这个会判断浏览器的支持情况</p></li><li><blockquote><p>我以为这边会顺着问一下事件循环机制和js运行机制，没想到问了个 nextTick</p></blockquote></li></ul></li></ul><p>最后我是问对我今后的学习有什么建议？</p><p>系统学一下前端基础，不要是做项目做到了才去学。在做项目的时候要了解一下业界比较流行的做法，前端更新比较快，注意性能上的一些优化。</p><blockquote><p>可能是看我做了项目吧，大多数问题都是从项目入手的，我项目也做的不太好，应该说没整理好，没讲清楚也没体现技术，这也和我平时做项目能用就行的想法有关系。</p><p>确实对旧项目没有做过优化，做新功能的时候技术选型也有问题，就是他说的项目用到了才匆匆忙忙去学。</p><p>准备面试的时候都是在看 js 基础相关的，比较奇怪的是问了好多优化的东西，js 反而一点没问，后面又说我基础不太好（虽然确实是不太好），以为一面会问很多基础，没想到都没怎么问</p><p>其实面着面着就知道自己凉了，总觉得对面已经招够了，也不太有兴趣问下去的感觉</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 面试准备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷面经</title>
      <link href="/2020/04/02/%E5%88%B7%E9%9D%A2%E7%BB%8F/"/>
      <url>/2020/04/02/%E5%88%B7%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<p>最近有点看不进去书，到牛客找面经上面对面经复习</p><p>主要是为了用自己的语言组织一下，怕面试了答不上来</p><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul><li>this 作用域<ul><li>指向运行时所在的作用域，一般是调用函数的对象</li><li>如果是全局就是 Window</li><li>如果是该函数是一个构造函数，this指针指向一个新的对象</li><li>使用 call、apply、bind 可以改变 this 的指向<ul><li>call、apply 区别：<ul><li>第一个参数都是 this 需要指向的对象</li><li>call 参数一个个传</li><li>apply 传数组</li></ul></li><li>bind 只是绑定一下，不执行，要执行的话需要再加括号</li><li>箭头函数没有自己的 this，根据作用域链去找<ul><li>如果箭头函数使用 call、apply、bind，第一个参数会被忽略</li></ul></li></ul></li></ul></li><li>什么样的 const 值可以更改<ul><li>const 只规定了变量的内容不被修改</li><li>如果是基本数据类型（string、number、bool、undefined、null、symbol）就不能改，因为直接存的数据</li><li>如果是复杂数据类型（Object）就可以改，因为保存的是变量的地址，地址再指向真实的数据，改变真实数据的情况下，地址不会变</li></ul></li><li>事件<ul><li>事件捕获</li><li>处于目标阶段</li><li>事件冒泡</li></ul></li><li>Promise</li><li>函数的柯里化<ul><li>把接受多个参数的函数变换成接受一个参数的函数，并且返回接受余下参数的新函数</li></ul></li><li>js 原型链</li><li>深浅复制</li><li>闭包<ul><li>能够读取其他函数变量的函数</li></ul></li><li>new 一个对象的过程<ul><li>创建一个空对象</li><li>将对象的原型指向构造函数</li><li>执行构造函数中的代码</li><li>返回新对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li>怎么用 css 画一个三角形</li><li>相对定位</li><li>绝对定位</li><li>flex-box 怎么用</li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul><li>双向绑定原理</li><li>vue-router 实现方式</li><li>vue 和 React 的区别</li><li>mvvm 的设计模式<ul><li>ViewModel 分离视图和模型，ViewModel 只关心数据和业务的处理</li></ul></li><li>父子组件的通信机制</li><li>组件化思想</li><li>页面懒加载向写法</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>队列和栈的区别？用栈来实现队列<ul><li>队列是先进先出，类似于排队；栈的话是先进后出，出入口是同一个，先进的元素会被压在下面</li><li>可以用两个栈，在出栈的时候把元素都先放到另外一个栈中，这样顺序就对了</li></ul></li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li>TCP、UDP区别？TCP如何做到双工可靠传输？TCP阻塞控制是什么？<ul><li>TCP 是面向连接的，传输比较可靠；UDP 是不可靠传输，比较适用于实时应用</li></ul></li><li>302 和 304 的区别</li><li>http code 的含义</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>进程和线程的区别</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>跨域</li><li>jsonp 原理</li><li>用户输入网址，看到页面的流程</li><li>Bootstrap 栅格系统的写法</li><li>怎么优化项目</li><li>存储</li></ul><h2 id="手撕代码"><a href="#手撕代码" class="headerlink" title="手撕代码"></a>手撕代码</h2><ul><li>提取url中search部分参数，<a href="https://www.aliexpress.com/?a=1&amp;b=2" target="_blank" rel="noopener">https://www.aliexpress.com/?a=1&amp;b=2</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = str.split(<span class="string">'?'</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> params = arr.split(<span class="string">'&amp;'</span>);</span><br><span class="line">  <span class="keyword">let</span> ans = []</span><br><span class="line">  <span class="keyword">for</span> (item <span class="keyword">of</span> params) &#123;</span><br><span class="line">    <span class="keyword">let</span> param = item.split(<span class="string">'='</span>);</span><br><span class="line">    ans.push(&#123;<span class="attr">key</span>: param[<span class="number">0</span>], <span class="attr">value</span>: param[<span class="number">1</span>]&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>写一个类Person， 拥有属性age和name，拥有方法say(something)， 再写一个类Superman，继承Person，拥有自己的属性power，拥有自己的方法fly(height)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age, name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  say(something) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(something)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Superman</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(power) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.power = power;</span><br><span class="line">  &#125;</span><br><span class="line">  fly(height) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`fly to <span class="subst">$&#123;height&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveDup</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params[i] === params[i<span class="number">-1</span>]) &#123;</span><br><span class="line">      params.splice(i, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> params</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(moveDup([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure><ul><li>quickSort</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> priv = arr[right];</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">let</span> j = right;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; priv) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = arr[i];</span><br><span class="line">    <span class="keyword">while</span> (j &gt; i &amp;&amp; arr[j] &gt; priv) &#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">  &#125;</span><br><span class="line">  arr[j] = priv;</span><br><span class="line">  quickSort(arr, left, j<span class="number">-1</span>);</span><br><span class="line">  quickSort(arr, j+<span class="number">1</span>, right);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>debounce</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>throttle</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      flag = <span class="literal">true</span></span><br><span class="line">    &#125;, ms)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试准备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2020/04/02/SpringBoot/"/>
      <url>/2020/04/02/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-入门"><a href="#Spring-Boot-入门" class="headerlink" title="Spring Boot 入门"></a>Spring Boot 入门</h1><h2 id="Srping-Boot-简介"><a href="#Srping-Boot-简介" class="headerlink" title="Srping Boot 简介"></a>Srping Boot 简介</h2><blockquote><p>简化 Spring 应用开发的一个框架；</p><p>整个 Spring 技术栈的一个大集合；</p><p>J2EE 开发的一站式解决方案；</p></blockquote><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服务：架构风格（微服务化）</p><p>一个应用应该是一组小型服务；可以通过 HTTP 的方式进行互通；</p><p>每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p><h2 id="Hello-World-探究"><a href="#Hello-World-探究" class="headerlink" title="Hello World 探究"></a>Hello World 探究</h2><h3 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h3><h4 id="父项目"><a href="#父项目" class="headerlink" title="父项目"></a>父项目</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/</span>artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.2</span><span class="number">.6</span>.RELEASE&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">        &lt;relativePath/</span>&gt; &lt;!-- lookup parent <span class="keyword">from</span> repository --&gt;</span><br><span class="line">    &lt;<span class="regexp">/parent&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 它的父项目是（cmd+鼠标左键点击 spring-boot-starter-parent 查看）</span></span><br><span class="line"><span class="regexp">  &lt;parent&gt;</span></span><br><span class="line"><span class="regexp">    &lt;groupId&gt;org.springframework.boot&lt;/g</span>roupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-dependencies&lt;<span class="regexp">/artifactId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;version&gt;2.2.6.RELEASE&lt;/</span>version&gt;</span><br><span class="line">    &lt;relativePath&gt;../../spring-boot-dependencies&lt;<span class="regexp">/relativePath&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>parent&gt;</span><br><span class="line"><span class="comment">// 真正管理 Spring Boot 应用里所有依赖版本</span></span><br></pre></td></tr></table></figure><h4 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h4><h5 id="spring-boot-starter-web"><a href="#spring-boot-starter-web" class="headerlink" title="spring-boot-starter-web"></a>spring-boot-starter-web</h5><ul><li>spring-boot-starter：SpringBoot 场景启动器</li></ul><p>Spring Boot 将所有的功能场景都抽取出来，做成一个个启动器，只需要在项目引入这些启动器相关场景都所有依赖都会导入进来，要什么功能就导入什么启动器</p><ul><li>spring-boot-starter-web：帮我们导入了 web 模块正常运行所依赖的组件</li></ul><h3 id="主程序类，主入口类"><a href="#主程序类，主入口类" class="headerlink" title="主程序类，主入口类"></a>主程序类，主入口类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@SpringBootApplication：说明这个类是主配置类，运行该类的 main 方法启动 SpringBoot 应用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">), @<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">)&#125;</span></span><br><span class="line"><span class="class">)</span></span><br></pre></td></tr></table></figure><ul><li><p>@SpringBootConfiguration：SpringBoot 的配置类</p><ul><li>标注在某个类上，表示这是一个 SpringBoot 的配置类</li><li>@Configuration：配置类上标注这个注解</li><li>@Component：说明这也是一个spring的组件</li></ul></li><li><p>@EnableAutoConfiguration：自动配置</p><ul><li>@AutoConfigurationPackage：自动配置包<ul><li>@Import({Registrar.class})<ul><li>Spring 的底层注解，给容器中导入一个组件：导入的组件由 Registrar.class 指定</li><li>将主配置类（@SpringBootApplication标注的类）的所在包以及下面所有子包里面的所有组件扫描到 Spring 容器</li></ul></li></ul></li><li>@Import({AutoConfigurationImportSelector.class})：自动配置导入选择<ul><li>导入哪些组件的选择器</li><li>将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</li><li>会给容器导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；</li></ul></li></ul></li><li><p>META-INF/spring.factories：自动配置的核心文件</p></li></ul><p>结论：Springboot 所有自动配置都是在启动的时候扫描并加载 <code>spring.factories</code> 所有的自动配置类都在这里面，但不一定生效，要判断条件是否成立，只要导入了对应的 start，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后就配置成功</p><ol><li>springboot 在启动的时候，从类路径下 <code>/META-INF/spring.factories</code> 获取指定的值</li><li>将这些自动配置的类导入容器，自动配置就会生效，帮我们进行自动配置</li><li>整合 javaEE，解决方案和自动配置的东西都在 spring-boot-autoconfigure-2.2.0.RELEASE.jar 这个包下</li><li>它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器</li><li>容器中也会存在非常多的 xxxAutoConfiguration 的文件（@Bean），就是这些类给容器中导入了这个场景需要的所有组件；并自动配置，@Configuration，JavaConfig</li><li>有了自动配置类，就免去了手动配置</li></ol><h2 id="使用-Spring-Initialize-快速创建-Spring-Boot-项目"><a href="#使用-Spring-Initialize-快速创建-Spring-Boot-项目" class="headerlink" title="使用 Spring Initialize 快速创建 Spring Boot 项目"></a>使用 Spring Initialize 快速创建 Spring Boot 项目</h2><p>默认生成的 Spring Boot 项目</p><ul><li>主程序已经生成好了，只需要编写自己的逻辑</li><li>resources 文件夹中目录结构<ul><li>static：保存所有的静态资源；js css images</li><li>templates：保存所有的模版页面；（Spring Boot 默认 jar 包使用嵌入式的 Tomcat，默认不支持 JSP 页面）；可以使用模版引擎</li><li>application.properties：SpringBoot 应用的配置文件：可以修改端口等</li></ul></li></ul><p>#配置文件</p><ul><li>application.properties<ul><li>语法结构：key=value</li></ul></li><li>application.yml（推荐）<ul><li>语法结构：key:空格value</li><li>Yaml 可以直接给实体类赋值<ul><li>@ConfigurationProperties(prefix = “xxx”)</li></ul></li></ul></li></ul><h2 id="JSR-303-校验"><a href="#JSR-303-校验" class="headerlink" title="JSR-303 校验"></a>JSR-303 校验</h2><ul><li>@validated 数据校验</li></ul><h2 id="配置文件位置及优先级"><a href="#配置文件位置及优先级" class="headerlink" title="配置文件位置及优先级"></a>配置文件位置及优先级</h2><ol><li>file: ./config/</li><li>file: ./</li><li>classpath: /config/</li><li>classpath:/</li></ol><h2 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h2><ol><li>SpringBoot 启动会加载大量的自动配置类</li><li>看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中</li><li>在看这个自动配置类中到底配置了哪些组件（需要的组件有的话就不用手动配置了）</li><li>给容器中添加组件的时候，会从 properties 类中回去某些属性，只需要在配置文件中指定这些属性的值即可</li></ol><ul><li><p>xxxAutoConfiguration 自动配置类：给容器中添加组件</p></li><li><p>xxxProperties：封装配置文件中相关属性</p></li></ul><h1 id="SpringBoot-Web-开发"><a href="#SpringBoot-Web-开发" class="headerlink" title="SpringBoot Web 开发"></a>SpringBoot Web 开发</h1><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><ul><li>在 springboot 中，可以使用以下方式处理静态资源<ul><li>webjars</li><li>public、static、/**、resources</li></ul></li><li>优先级：resources &gt; static &gt; public</li></ul><h2 id="模版引擎"><a href="#模版引擎" class="headerlink" title="模版引擎"></a>模版引擎</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-java8time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>前后端分离还有用吗这个？</li></ul><h2 id="SpringMVC-配置原理"><a href="#SpringMVC-配置原理" class="headerlink" title="SpringMVC 配置原理"></a>SpringMVC 配置原理</h2><ul><li>在 Srpingboot 中，有非常多的 xxxConfiguration 帮助我们进行扩展配置</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP</title>
      <link href="/2020/04/01/%E5%9B%BE%E8%A7%A3HTTP/"/>
      <url>/2020/04/01/%E5%9B%BE%E8%A7%A3HTTP/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-了解-Web-及网络基础"><a href="#第一章-了解-Web-及网络基础" class="headerlink" title="第一章 了解 Web 及网络基础"></a>第一章 了解 Web 及网络基础</h1><h2 id="使用-HTTP-协议访问-Web"><a href="#使用-HTTP-协议访问-Web" class="headerlink" title="使用 HTTP 协议访问 Web"></a>使用 HTTP 协议访问 Web</h2><p>Web 是建立在 HTTP 协议上通信的</p><h2 id="HTTP-的诞生"><a href="#HTTP-的诞生" class="headerlink" title="HTTP 的诞生"></a>HTTP 的诞生</h2><p>最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的 WWW（World Wide Web，万维网）</p><ul><li>HTML：把 SGML 作为页面的文本标记语言</li><li>HTTP：文档传递协议</li><li>URL：指定文档所在位置</li></ul><p>WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。</p><p>现在则用来表示这一系列的集合，也可简称为 Web。</p><h2 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP/IP"></a>网络基础 TCP/IP</h2><p>HTTP 是 TCP/IP 协议族的一个子集</p><table><thead><tr><th>应用层</th><th>FTP、DNS、HTTP</th><th>HTTP 数据</th></tr></thead><tbody><tr><td>传输层</td><td>TCP、UDP</td><td>TCP首部（HTTP数据）</td></tr><tr><td>网络层</td><td>IP 数据包</td><td>IP首部（TCP首部（HTTP数据））</td></tr><tr><td>链路层</td><td>硬件</td><td>以太网首部（IP首部（TCP首部（HTTP数据）））</td></tr></tbody></table><h3 id="IP-协议（负责传输）"><a href="#IP-协议（负责传输）" class="headerlink" title="IP 协议（负责传输）"></a>IP 协议（负责传输）</h3><ul><li>作用：把各种数据包传送给对方</li><li>IP 地址 —ARP地址解析协议—&gt; MAC 地址</li><li>路由选择</li></ul><h3 id="TCP-协议（确保可靠性）"><a href="#TCP-协议（确保可靠性）" class="headerlink" title="TCP 协议（确保可靠性）"></a>TCP 协议（确保可靠性）</h3><ul><li><p>作用：提供可靠的字节流服务</p><ul><li>字节流服务：为了方便传输，将大块数据分割成报文段（segment）为单位的数据包进行管理</li><li>可靠的传输服务：能够确认数据最终是否送达到对方</li></ul></li><li><p>三次握手策略</p><ul><li>发送端首先发送一个带有 SYN 标志的数据包给对方</li><li>接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息</li><li>发送端再回传一个带 ACK 标志的数据包</li></ul></li></ul><h3 id="DNS-服务（负责域名解析）"><a href="#DNS-服务（负责域名解析）" class="headerlink" title="DNS 服务（负责域名解析）"></a>DNS 服务（负责域名解析）</h3><ul><li>作用：域名 &lt;===&gt; IP 地址</li></ul><h2 id="各种协议与-HTTP-协议的关系"><a href="#各种协议与-HTTP-协议的关系" class="headerlink" title="各种协议与 HTTP 协议的关系"></a>各种协议与 HTTP 协议的关系</h2><ol><li>DNS 解析域名，得到对应 IP 地址</li><li>HTTP 协议生成 HTTP 请求报文</li><li>TCP 将请求报文分割成报文段</li><li>IP 协议路由寻址，一边中转一边传送</li><li>TCP 收到报文段，重组报文段</li><li>HTTP 队收到的请求进行处理</li></ol><h2 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h2><ul><li><p>URI（Uniform Resource Locator）统一资源标识符</p></li><li><p>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。</p></li></ul><h1 id="第二章-简单的-HTTP-协议"><a href="#第二章-简单的-HTTP-协议" class="headerlink" title="第二章 简单的 HTTP 协议"></a>第二章 简单的 HTTP 协议</h1><ul><li><p>HTTP 协议用于客户端和服务器端之间的通信</p></li><li><p>通过请求和相应的交换达成通信，必须先有请求才有响应</p></li><li><p>请求报文</p><ul><li>请求方法</li><li>请求 URI</li><li>协议版本</li><li>可选的请求首部字段</li><li>内容实体</li></ul></li><li><p>响应报文</p><ul><li>协议版本</li><li>状态码（用以解释状态码的原因短语）</li><li>可选的响应首部字段</li><li>实体主体</li></ul></li></ul><h2 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h2><ul><li>HTTP 是无状态协议，不保留之前一切的请求或响应报文的信息<ul><li>为了实现期望的保持状态功能，引入 Cookie 技术</li></ul></li></ul><h2 id="请求-URI-定位资源"><a href="#请求-URI-定位资源" class="headerlink" title="请求 URI 定位资源"></a>请求 URI 定位资源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET http:hackr.jp&#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line"></span><br><span class="line">GET &#x2F;index.html HTTP&#x2F;1.1</span><br><span class="line">Host: hackr.jp</span><br></pre></td></tr></table></figure><ul><li>不是请求具体资源，而是针对服务器端本身的请求 * 代替 URI</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS * HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><h2 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h2><ul><li>GET：获取资源<ul><li>请求访问已被 URI 识别的资源，资源<strong>经过服务器解析</strong>后返回</li></ul></li><li>POST：传输实体主体</li><li>PUT：传输文件<ul><li>请求报文主体中包含文件内容，保存到请求 URI 指定的位置</li><li>PUT 方法自身不带验证机制，任何人都可以上传，为了安全一般都不用</li></ul></li><li>HEAD：获得报文首部<ul><li>类似 GET，不返回报文主体，用于确认 URI 的有效性及资源更新的日期</li></ul></li><li>DELETE：删除文件<ul><li>按请求 URI 删除指定的资源</li><li>不带验证机制</li></ul></li><li>OPTIONS（1.1）：询问支持的方法<ul><li>查询针对请求 URI 指定的资源支持的方法</li></ul></li><li>TRACE（1.1）：追踪路径<ul><li>让 Web 服务前端将之前的请求通信环回给客户端</li><li>确认请求连接过程中发生的一系列操作</li><li>容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，不常用</li></ul></li><li>CONNECT（1.1）：要求用隧道协议连接代理<ul><li>SSL（Secure Sockets Layer，安全套阶层）</li><li>TLS（Transport Layer Security，传输层安全）</li><li>TCP 通信，使用以上两个协议加密</li></ul></li></ul><h2 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h2><p>HTTP/1.0 每进行一次 HTTP 通信就要断开一次 TCP 连接；一个网页包含很多资源，TCP 连接建立和断开会增加通信量的开销</p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>HTTP/1.1 中，只要任意一端没有明确提出断开连接，就保持 TCP 连接状态</p><h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>从前发送请求后需等待并收到响应才能发送下一个请求</p><p>管线化技术出现后，不用等待响应就可以直接发送下一个请求，即能做到同时并行发送多个请求</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态</p><p>Cookie 会根据从服务器端发送端响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去</p><h1 id="第三章-HTTP-报文内的-HTTP-信息"><a href="#第三章-HTTP-报文内的-HTTP-信息" class="headerlink" title="第三章 HTTP 报文内的 HTTP 信息"></a>第三章 HTTP 报文内的 HTTP 信息</h1><p>HTTP 报文本身是由多行数据构成的字符串文本</p><table><thead><tr><th>请求报文</th><th>响应报文</th><th></th></tr></thead><tbody><tr><td>请求行</td><td>状态行</td><td>报</td></tr><tr><td>请求首部字段</td><td>响应首部字段</td><td>文</td></tr><tr><td>通用首部字段</td><td>通用首部字段</td><td></td></tr><tr><td>实体首部字段</td><td>实体首部字段</td><td>首</td></tr><tr><td>其他</td><td>其他</td><td>部</td></tr><tr><td>（空行）</td><td>（空行）</td><td></td></tr><tr><td>报文主体</td><td>报文主体</td><td></td></tr></tbody></table><h3 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h3><ul><li>报文（message）：是 HTTP 通信中的基本单位，由 8 位组字节流组成，通过 HTTP 通信传输</li><li>实体（enentity）：作为请求或响应的有效载荷数据（补充项）被传输，内容由实体首部和实体主体组成</li></ul><p>实体首部是报文首部的一部分（看上面的表格）</p><p>一般情况下，实体主体等于报文主体。传输过程中，为了提升传输速率，会对报文主体进行编码，这样报文主体就和实体主体不同了。</p><h3 id="内容编码（压缩传输）"><a href="#内容编码（压缩传输）" class="headerlink" title="内容编码（压缩传输）"></a>内容编码（压缩传输）</h3><ul><li><strong>内容编码</strong>指明应用在实体内容上的编码格式。客户端接收并负责解码。</li><li>常用的内容编码<ul><li>gzip（GNU zip）</li><li>compress（UNIX 系统的标准压缩）</li><li>deflate（zlib）</li><li>identity（不进行编码）</li></ul></li></ul><h3 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h3><p>在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。</p><p>通过把数据分割成多块，能够让浏览器逐步显示页面。</p><p>这种把实体主体分块的功能称为<strong>分块传输编码</strong>。</p><h2 id="多部分对象集合（发送多种数据）"><a href="#多部分对象集合（发送多种数据）" class="headerlink" title="多部分对象集合（发送多种数据）"></a>多部分对象集合（发送多种数据）</h2><ul><li>multipart/form-data：Web表单文件上传</li><li>multipart/byteranges：状态码 206，响应报文包含多个范围的内容</li></ul><p>使用多部分对象集合时，需要在首部字段加上 Content-type</p><p>使用 boundary 字符串来划分多部分对象集合指明的各类实体</p><h2 id="范围请求（断点重传）"><a href="#范围请求（断点重传）" class="headerlink" title="范围请求（断点重传）"></a>范围请求（断点重传）</h2><ul><li>从之前下载的中断处恢复下载，仅下载指定的实体范围，称为<strong>范围请求</strong></li><li>首部字段 Range 来指定资源的 byte 范围</li><li>针对范围请求，响应会返回状态码为 206 的响应报文<ul><li>如果是多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges</li></ul></li><li>如果无法响应范围请求，会返回 200 和完整的实体内容</li></ul><h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p><strong>内容协商机制</strong>指客户端和服务器端就响应的资源内容进行交涉，提供最合适的资源</p><ul><li>基准：语言、字符集、编码方式等<ul><li>Accept</li><li>Accept-Charset</li><li>Accept-Encoding</li><li>Accept-Language</li><li>Content-Language</li></ul></li><li>内容协商技术类型<ul><li>服务器驱动协商<ul><li>以请求的首部字段为参考，在服务器端自动处理，不一定筛出最优内容</li></ul></li><li>客户端驱动协商<ul><li>用户从浏览器显示的可选项列表中手动选择</li><li>利用 js 脚本在 Web 页面上进行选择</li></ul></li><li>透明协商</li></ul></li></ul><h1 id="第四章-返回结果的-HTTP-状态码"><a href="#第四章-返回结果的-HTTP-状态码" class="headerlink" title="第四章 返回结果的 HTTP 状态码"></a>第四章 返回结果的 HTTP 状态码</h1><ul><li>状态码的指责是当客户端向服务器端发送请求时，描述返回的请求结果</li></ul><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1xx</td><td>Informational</td><td>接收的请求正在处理</td></tr><tr><td>2xx</td><td>Success</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4xx</td><td>Client Error</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error</td><td>服务器处理请求出错</td></tr></tbody></table><ul><li>2xx 成功<ul><li>200 OK</li><li>204 No Content</li><li>206 Partial Content</li></ul></li><li>3xx 重定向<ul><li>301 Moved Permanently 永久性重定向，建议用户修改书签</li><li>302 Found 临时性重定向，希望用户（本次）能使用新的 URI 访问</li><li>303 See Other 请求对应的资源存在另一个 URI，且明确用 GET 访问</li><li>304 Not Modified 客户端发送附带条件的请求时，服务器端允许请求访问资源<ul><li>If-Match</li><li>If-Modified-Since</li><li>If-None-Match</li><li>If-Range</li><li>If-Unmodified-Since</li></ul></li><li>307 Temporary Redirect 临时重定向</li></ul></li><li>4xx 客户端错误<ul><li>400 Bad Request 报文中存在语法错误</li><li>401 Unauthorized 发送的请求需要有通过 HTTP 认证的认证信息</li><li>403 Forbidden 该状态码表明对请求资源的访问呗服务器拒绝了</li><li>404 Not Found 服务器上无法找到请求的资源</li></ul></li><li>5xx 服务器错误<ul><li>500 Internal Server Error 服务器端在执行请求时发生了错误</li><li>503 Service Unavailable 超负载或停机维护，无法处理请求</li></ul></li></ul><h1 id="第五章-与-HTTP-协作的-Web-服务器"><a href="#第五章-与-HTTP-协作的-Web-服务器" class="headerlink" title="第五章 与 HTTP 协作的 Web 服务器"></a>第五章 与 HTTP 协作的 Web 服务器</h1><ul><li>通信数据转发程序<ul><li>代理<ul><li>转发功能的应用程序，不改变 URI</li><li>好处<ul><li>利用缓存技术减少网络带宽的流量</li><li>组织内部针对特定网站的访问控制</li><li>获取访问日志</li></ul></li><li>分类<ul><li>缓存代理</li><li>透明代理：不对报文做任何加工</li></ul></li></ul></li><li>网关<ul><li>转发其他服务器通信数据的服务器</li><li>好处<ul><li>利用网关可以由 HTTP 请求转化为其他协议通信</li></ul></li></ul></li><li>隧道<ul><li>按要求建立一条与其他服务器的通信线路，使用 SSL 等加密手段进行通信</li><li>目的<ul><li>确保通信安全</li></ul></li><li>隧道本身不去解析 HTTP 请求</li></ul></li></ul></li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li>缓存是指代理服务器或客户端本地磁盘内保存的资源副本<ul><li>利用缓存可减少对源服务器的访问，节省了通信流量和通信时间</li></ul></li><li>缓存过期后，会向源服务器确认资源的有效性</li><li>若缓存失效，浏览器会再次请求新资源</li></ul><h1 id="第六章-HTTP-首部"><a href="#第六章-HTTP-首部" class="headerlink" title="第六章 HTTP 首部"></a>第六章 HTTP 首部</h1><h2 id="报文首部"><a href="#报文首部" class="headerlink" title="报文首部"></a>报文首部</h2><h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><ul><li>报文首部<ul><li>请求行：方法、URI、HTTP 版本</li><li>HTTP 首部字段<ul><li>请求首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他</li></ul></li></ul></li><li>空行</li><li>报文主体</li></ul><h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><ul><li>报文首部<ul><li>状态行：HTTP 版本、状态码</li><li>HTTP 首部字段<ul><li>响应首部字段</li><li>通用首部字段</li><li>实体首部字段</li><li>其他</li></ul></li></ul></li><li>空行</li><li>报文主体</li></ul><h2 id="HTTP-首部字段"><a href="#HTTP-首部字段" class="headerlink" title="HTTP 首部字段"></a>HTTP 首部字段</h2><ul><li>首部字段名：字段值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text&#x2F;html</span><br></pre></td></tr></table></figure><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>通用首部字段</li><li>请求首部字段</li><li>响应首部字段</li><li>实体首部字段</li></ul><p>非 HTTP/1.1 首部字段</p><ul><li>Cookie</li><li>Set-Cookie</li><li>Content-Disposition</li></ul><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><ul><li>Cache-Control：控制缓存行为</li><li>Connection：控制不再转发给代理的首部字段；管理持久连接</li><li>Date：创建 HTTP 报文的日期和时间</li><li>Pragma：向后兼容；要求所有的中间服务器不返回缓存的资源</li><li>Trailer：报文主体后记录了哪些首部字段</li><li>Transfer-Encoding：传输时的编码方式</li><li>Upgrade：检测 HTTP 协议及其他协议是否可使用更高的版本进行通信</li><li>Via：追踪传输路径</li><li>Warning：缓存相关问题的警告</li></ul><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><ul><li>Accept：用户代理支持的媒体类型及优先级</li><li>Accept-Charset：用户代理支持的字符集及优先级</li><li>Accept-Encoding：用户代理支持的内容编码及优先级<ul><li>gzip</li><li>compress</li><li>deflate</li><li>identity</li></ul></li><li>Accept-Language：用户代理支持的自然语言集及优先级</li><li>Authorization：</li><li>Expect：期望出现的某种特定行为</li><li>From：电子邮件地址</li><li>Host：请求的资源所处的互联网主机名和端口号；如果未设置主机名发送空</li><li>If-xxx：条件请求，判断为真才执行<ul><li>IF-Match：字段值跟 ETag 值匹配一致时才接受请求</li><li>If-Modified-Since：字段值（日期）之后资源更新，接受请求</li><li>If-None-Match：字段值跟 ETag 值不一致时才接受请求</li><li>If-Range：字段值（ETag或时间）和请求资源（ETag 值或时间）相一致时，作为范围请求处理，否则返回全体资源</li></ul></li></ul><h4 id="响应字段首部"><a href="#响应字段首部" class="headerlink" title="响应字段首部"></a>响应字段首部</h4><ul><li>Accept-Ranges</li><li>Age</li><li>ETag：实体资源的唯一标识，中英文是同一个<ul><li>强 ETag：细微变化都会改变</li><li>弱 ETag：只用于提示资源是否相同，资源发生根本改变产生差异时才改变 ETag 值</li></ul></li><li>Location</li><li>Proxy-Authenticate</li><li>Retry-After</li><li>Server</li><li>Vary</li></ul><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><ul><li>Allow</li><li>Content-Encoding</li><li>Content-Language</li><li>Content-Length</li><li>Content-Location</li><li>Content-MD5</li><li>Content-Range</li><li>Content-Type</li><li>Expires：资源失效的日期</li><li>Last-Modified：资源最终修改的时间</li></ul><h4 id="为-Cookie服务的首部字段"><a href="#为-Cookie服务的首部字段" class="headerlink" title="为 Cookie服务的首部字段"></a>为 Cookie服务的首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th><th>首部类型</th></tr></thead><tbody><tr><td>Set-Cookie</td><td>开始状态管理所使用的 Cookie 信息</td><td>响应首部字段</td></tr><tr><td>COokie</td><td>服务器接收到的 Cookie 信息</td><td>请求首部字段</td></tr></tbody></table><h1 id="第七章-确保-Web-安全的-HTTPS"><a href="#第七章-确保-Web-安全的-HTTPS" class="headerlink" title="第七章 确保 Web 安全的 HTTPS"></a>第七章 确保 Web 安全的 HTTPS</h1><h2 id="HTTP-的缺点"><a href="#HTTP-的缺点" class="headerlink" title="HTTP 的缺点"></a>HTTP 的缺点</h2><ul><li>明文，内容会被窃听    </li><li>不验证身份，会被伪装</li><li>无法验证完整性，可能被篡改</li></ul><p>未加密协议都会存在这类问题</p><h4 id="明文"><a href="#明文" class="headerlink" title="明文"></a>明文</h4><ul><li>TCP/IP 是可能被窃听的网络<ul><li>抓包工具</li></ul></li><li>加密处理防止被窃听<ul><li>通信的加密<ul><li>SSL</li><li>TLS</li></ul></li><li>内容的加密</li></ul></li></ul><h4 id="验证身份"><a href="#验证身份" class="headerlink" title="验证身份"></a>验证身份</h4><ul><li><p>任何人都可以发起请求，服务器收到请求都会返回响应</p></li><li><p>查明对手的证书：SSL</p></li></ul><h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><ul><li>遭遇篡改，MITM 中间人攻击</li><li>防止篡改<ul><li>MD5 和 SHA-1等散列值校验</li><li>数字签名</li></ul></li></ul><h2 id="HTTPS-HTTP-加密-认证-完整性保护"><a href="#HTTPS-HTTP-加密-认证-完整性保护" class="headerlink" title="HTTPS = HTTP + 加密 + 认证 + 完整性保护"></a>HTTPS = HTTP + 加密 + 认证 + 完整性保护</h2><ul><li>公钥加密，私钥解密</li><li>公钥加密与共享密钥加密相比，处理速度要慢</li><li>HTTPS 采用混合加密机制<ul><li>使用公钥加密方式交换共享密钥</li><li>之后的通信使用共享密钥加密</li></ul></li><li>证书证明公钥的有效性</li></ul><h1 id="第八章-确认访问用户身份的认证"><a href="#第八章-确认访问用户身份的认证" class="headerlink" title="第八章 确认访问用户身份的认证"></a>第八章 确认访问用户身份的认证</h1><h2 id="BASIC-认证（基本认证）"><a href="#BASIC-认证（基本认证）" class="headerlink" title="BASIC 认证（基本认证）"></a>BASIC 认证（基本认证）</h2><ol><li>请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Reuired，返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式（BASIC）及 Request-URI 安全域字符串（realm）</li><li>接收到状态码 401 的客户端，需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（：）连接后，再经过 Base64 编码处理。</li><li>收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。</li></ol><h2 id="DIGEST-认证（摘要认证）"><a href="#DIGEST-认证（摘要认证）" class="headerlink" title="DIGEST 认证（摘要认证）"></a>DIGEST 认证（摘要认证）</h2><ol><li>请求的资源需要 DIGEST 认证时，服务器会随状态码 401 Authorization Reuired，返回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce）</li><li>接收到状态码 401 的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息，包括 username、realm、nonce、uri、response 字段。<ul><li>realm、nonce 是从服务端得到</li><li>username 是 realm 限定范围内可进行认证等用户名</li><li>uri 即 Request-URI</li><li>response 存放经过 MD5 运算后的密码字符串，形成响应码</li></ul></li><li>收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。</li></ol><h2 id="SSL-客户端认证"><a href="#SSL-客户端认证" class="headerlink" title="SSL 客户端认证"></a>SSL 客户端认证</h2><p>客户端事先安装证书</p><ol><li>接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。</li><li>用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。</li><li>服务器验证客户端证书，验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。</li></ol><h3 id="双因素认证"><a href="#双因素认证" class="headerlink" title="双因素认证"></a>双因素认证</h3><ul><li><p>证书认证 -&gt; 认证客户端计算机</p></li><li><p>表单认证 -&gt; 认证用户本人的行为</p></li></ul><h2 id="基于表单认证"><a href="#基于表单认证" class="headerlink" title="基于表单认证"></a>基于表单认证</h2><ul><li>一般用 Cookie 来管理 Session</li><li>通过服务器端的 web 应用，将客户端发送过来的用户 ID 和密码与之前登录过的信息做匹配来进行认证的</li></ul><ol><li>客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS 通信来进行 HTML 表单画面的显示和用户输入数据的发送。</li><li>服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID。</li><li>客户端接收到从服务端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</li></ol><h1 id="第九章-基于-HTTP-的功能追加协议"><a href="#第九章-基于-HTTP-的功能追加协议" class="headerlink" title="第九章 基于 HTTP 的功能追加协议"></a>第九章 基于 HTTP 的功能追加协议</h1><h3 id="HTTP-的瓶颈"><a href="#HTTP-的瓶颈" class="headerlink" title="HTTP 的瓶颈"></a>HTTP 的瓶颈</h3><ul><li>一条连接上只可发送一个请求</li><li>请求只能从客户端开始，客户端不可以接收响应意外的指令</li><li>请求/响应首部未经压缩就发送。首部信息越多延迟越大</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li><li>可任意选择数据压缩格式。非强制压缩发送。</li></ul><h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><ul><li>Asynchronous JavaScript and XML</li><li>有效利用 JavaScript 和 DOM 的操作，达到局部 Web 页面替换加载的异步通信手段</li><li>和以前的同步通信相比，只更新一部分页面，<strong>传输的数据量减少</strong></li><li>Ajax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 的调用就能和服务器进行 HTTP 通信</li></ul><h4 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h4><ul><li>Comet 先将响应挂起，当服务器端后更新再返回。模拟服务器端向客户端推送的功能。</li><li><strong>内容实时更新</strong>，为了维持连接会消耗更多的资源</li></ul><h2 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h2><ul><li>没有完全改写 HTTP 协议</li><li>在 TCP/IP 的应用层与传输层之间通过新加会话层的形式运作</li><li>为了安全规定使用 SSL</li><li>好处<ul><li>多路复用流</li><li>赋予请求优先级</li><li>压缩 HTTP 首部</li><li>推送功能</li><li>服务器提示功能</li></ul></li><li>缺点<ul><li>单个域名的通信多路服用，一个 Web 网址上使用多个域名下的资源，改善效果有限</li></ul></li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul><li>Web 浏览器与 Web 服务器之间全双工通信标准</li><li>建立在 HTTP 基础上，发起方仍是客户端，一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方可以直接向对方发送报文。</li><li>特点<ul><li>推送功能</li><li>WebSocket 首部信息很小，减少通信量</li></ul></li></ul><p>为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次握手。</p><ul><li>握手·请求<ul><li>HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，达到握手的目的。</li><li>Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值</li><li>Sec-WebSocket-Protocol 字段内记录使用的子协议</li></ul></li><li>握手·响应<ul><li>返回状态码 101 Switching Protocols</li><li>Sec-WebSocket-Accept 字段值是由握手请求中的 Sec-WebSocket-Key 的自动值生成的</li></ul></li></ul><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h2><ul><li>目标是改善用户在使用 Web 时的速度体验</li></ul><h2 id="Web-服务器管理文件的-WebDAV"><a href="#Web-服务器管理文件的-WebDAV" class="headerlink" title="Web 服务器管理文件的 WebDAV"></a>Web 服务器管理文件的 WebDAV</h2><ul><li>Web-based Distributed Authoring and Versioning</li><li>可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统</li></ul><h1 id="第十章-构建-Web-内容的技术"><a href="#第十章-构建-Web-内容的技术" class="headerlink" title="第十章 构建 Web 内容的技术"></a>第十章 构建 Web 内容的技术</h1><ul><li>HTML（HyperText Markup Language）</li><li>CSS（Cascading Style Sheets）</li><li>JavaScript</li><li>JSON（JavaScript Object Notation）</li></ul><h1 id="第十一章-Web-的攻击技术"><a href="#第十一章-Web-的攻击技术" class="headerlink" title="第十一章 Web 的攻击技术"></a>第十一章 Web 的攻击技术</h1><ul><li>HTTP 不具备必要的安全功能</li><li>HTTP 请求可以在客户端自由地修改<ul><li>在报文内加载攻击代码<ul><li>URL 查询字段或表单、HTTP 首部、Cookie 等途径</li></ul></li></ul></li></ul><h3 id="针对-Web-应用的攻击模式"><a href="#针对-Web-应用的攻击模式" class="headerlink" title="针对 Web 应用的攻击模式"></a>针对 Web 应用的攻击模式</h3><ul><li><p>以服务器为目标的主动攻击</p><ul><li>把攻击代码传入的攻击模式</li><li>代表<ul><li>SQL 注入攻击</li><li>OS 命令注入攻击</li></ul></li></ul></li><li><p>以服务器为目标的被动攻击</p><ul><li><p>利用圈套策略执行攻击代码的攻击模式</p><ol><li>诱使用户触发已经设置好的陷阱，陷阱会自动发送已嵌入攻击代码的 HTTP 请求</li><li>当用户不知不觉中招后，用户的浏览器或邮件客户端救护触发这个陷阱</li><li>中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码</li><li>执行完攻击代码，存在安全漏洞的 Web 应用会成为攻击者的跳板，可能导致用户所持的 Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果</li></ol></li><li><p>代表</p><ul><li>XSS 跨站脚本攻击</li><li>跨站点请求伪造</li></ul></li></ul></li></ul><h3 id="因输入值转义不完全引发的安全漏洞"><a href="#因输入值转义不完全引发的安全漏洞" class="headerlink" title="因输入值转义不完全引发的安全漏洞"></a>因输入值转义不完全引发的安全漏洞</h3><ul><li>XSS 跨站脚本攻击<ul><li>在 html 中注入 js 代码使得用户在表单中输入的账户密码会发送到攻击者的网站</li></ul></li><li>SQL 注入攻击<ul><li>针对数据库，传入非法的 SQL 让服务器执行，可能导致非法浏览和篡改</li></ul></li><li>OS 命令注入攻击<ul><li>通过 Web 应用，执行非法的操作系统命令</li></ul></li><li>HTTP 首部注入攻击<ul><li>攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击<ul><li>比如 Cookie 信息、重定向 URL</li></ul></li></ul></li><li>目录遍历攻击<ul><li>对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的</li></ul></li><li>远程文件包含漏洞<ul><li>当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当以来文件，让脚本读取之后，就可以运行任意脚本的一种攻击</li></ul></li></ul><h3 id="因设置或设计上的缺陷引发的安全漏洞"><a href="#因设置或设计上的缺陷引发的安全漏洞" class="headerlink" title="因设置或设计上的缺陷引发的安全漏洞"></a>因设置或设计上的缺陷引发的安全漏洞</h3><ul><li>强制浏览</li><li>不正确的错误消息处理</li><li>开放重定向</li></ul><h3 id="因会话管理疏忽引发的安全漏洞"><a href="#因会话管理疏忽引发的安全漏洞" class="headerlink" title="因会话管理疏忽引发的安全漏洞"></a>因会话管理疏忽引发的安全漏洞</h3><ul><li>会话劫持<ul><li>攻击者通过某种手段拿到用户的会话 ID，并非法使用此会话 ID 伪装成用户</li></ul></li><li>会话固定攻击</li><li>跨站点请求伪造<ul><li>攻击者通过设置好的陷阱</li></ul></li></ul><h3 id="其他安全漏洞"><a href="#其他安全漏洞" class="headerlink" title="其他安全漏洞"></a>其他安全漏洞</h3><ul><li>密码破解</li><li>点击劫持<ul><li>利用透明按钮覆盖在 Web 页面上，让用户点击，又称界面伪装</li></ul></li><li>DoS 攻击<ul><li>让运行中的服务呈停止状态的攻击</li></ul></li><li>后门程序</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2020/03/30/%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/03/30/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">arr, left = <span class="number">0</span>, right = arr.length <span class="number">-1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">let</span> j = right;</span><br><span class="line">  <span class="keyword">const</span> baseVal = arr[j];</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= baseVal) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = arr[i];</span><br><span class="line">    <span class="keyword">while</span> (j &gt; i &amp;&amp; arr[j] &gt;= baseVal) &#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">  &#125;</span><br><span class="line">  arr[j] = baseVal;</span><br><span class="line">  quickSort(arr, left, j<span class="number">-1</span>);</span><br><span class="line">  quickSort(arr, j+<span class="number">1</span>, right);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试准备 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS运行机制</title>
      <link href="/2020/03/29/JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/03/29/JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA</a></p><h2 id="区分进程和线程"><a href="#区分进程和线程" class="headerlink" title="区分进程和线程"></a>区分进程和线程</h2><ul><li>进程是 cpu 资源分配的最小单位，线程是 cpu 调度的最小单位。</li><li>一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。</li><li>进程在创建、切换和销毁时开销比较大，而线程比较小。<ul><li>进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。</li></ul></li></ul><h2 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h2><ul><li>浏览器是多进程的</li><li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li><li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程<ul><li>在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了（所以每一个Tab标签对应一个进程并不一定是绝对的）</li></ul></li></ul><h2 id="浏览器都包含哪些进程？"><a href="#浏览器都包含哪些进程？" class="headerlink" title="浏览器都包含哪些进程？"></a>浏览器都包含哪些进程？</h2><ul><li>Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有：<ul><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul></li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D绘制等</li><li>浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）<ul><li>默认每个Tab页面一个进程，互不影响。主要作用为<ul><li>页面渲染，脚本执行，事件处理等</li></ul></li></ul></li></ul><h2 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势</h2><ul><li>避免单个page crash影响整个浏览器</li><li>避免第三方插件crash影响整个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li></ul><h2 id="重点是浏览器内核（渲染进程）"><a href="#重点是浏览器内核（渲染进程）" class="headerlink" title="重点是浏览器内核（渲染进程）"></a>重点是浏览器内核（渲染进程）</h2><ul><li>页面的渲染，JS的执行，事件的循环，都在这个渲染进程内进行</li><li>浏览器的渲染进程是多线程的<ul><li>GUI渲染线程<ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li><li><strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中<strong>等到JS引擎空闲时</strong>立即被执行</li></ul></li><li>JS引擎线程<ul><li>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</li><li>JS引擎线程负责解析Javascript脚本，运行代码。</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li><li><strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞</li></ul></li><li>事件触发线程<ul><li>归属于浏览器而不是JS引擎，用来控制事件循环</li><li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li></ul></li><li>定时触发器线程<ul><li>传说中的setInterval与setTimeout所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul></li><li>异步 http 请求线程<ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li></ul></li></ul></li></ul><h2 id="Browser进程和浏览器内核（Renderer进程）的通信过程"><a href="#Browser进程和浏览器内核（Renderer进程）的通信过程" class="headerlink" title="Browser进程和浏览器内核（Renderer进程）的通信过程"></a>Browser进程和浏览器内核（Renderer进程）的通信过程</h2><ul><li>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程</li><li>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染</li><li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li><li>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</li><li>最后Render进程将结果传递给Browser进程</li><li>Browser进程接收到结果并将结果绘制出来</li></ul><h2 id="梳理浏览器内核中线程之间的关系"><a href="#梳理浏览器内核中线程之间的关系" class="headerlink" title="梳理浏览器内核中线程之间的关系"></a>梳理浏览器内核中线程之间的关系</h2><h2 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥</h2><ul><li>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了</li><li>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行</li></ul><h2 id="JS阻塞页面加载"><a href="#JS阻塞页面加载" class="headerlink" title="JS阻塞页面加载"></a>JS阻塞页面加载</h2><ul><li>JS如果执行时间过长就会阻塞页面。</li><li>譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</li><li>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</li></ul><h2 id="WebWorker，JS的多线程？"><a href="#WebWorker，JS的多线程？" class="headerlink" title="WebWorker，JS的多线程？"></a>WebWorker，JS的多线程？</h2><ul><li>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li><li>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</li></ul><h2 id="WebWorker与SharedWorker"><a href="#WebWorker与SharedWorker" class="headerlink" title="WebWorker与SharedWorker"></a>WebWorker与SharedWorker</h2><ul><li>WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享</li><li>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</li><li>SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用</li><li>所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次</li></ul><h2 id="简单梳理下浏览器渲染流程"><a href="#简单梳理下浏览器渲染流程" class="headerlink" title="简单梳理下浏览器渲染流程"></a>简单梳理下浏览器渲染流程</h2><blockquote><p><em>浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程-浏览器渲染流程开始</em></p></blockquote><p>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p><ol><li>解析html建立dom树</li><li>解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）</li><li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint），绘制页面像素信息</li><li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</li></ol><p>渲染完毕后就是<code>load</code>事件了，之后就是自己的JS逻辑处理了。</p><p>![image-20200330102718586](/Users/wuziyan/Library/Application Support/typora-user-images/image-20200330102718586.png)</p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h2><ul><li>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>  (譬如如果有async加载的脚本就不一定完成)</li><li>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。（渲染完毕了）</li></ul><p>所以，顺序是：<code>DOMContentLoaded -&gt; load</code></p><h2 id="css加载是否会阻塞dom树渲染？"><a href="#css加载是否会阻塞dom树渲染？" class="headerlink" title="css加载是否会阻塞dom树渲染？"></a>css加载是否会阻塞dom树渲染？</h2><p><strong>css是由单独的下载线程异步下载的。</strong></p><ul><li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</li><li>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</li></ul><h2 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h2><ul><li>浏览器渲染的图层一般包含两大类：普通图层以及复合图层</li><li>普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）</li><li>其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层</li><li>GPU中，各个复合图层是单独绘制的，所以互不影响</li></ul><h3 id="如何变成复合图层（硬件加速）"><a href="#如何变成复合图层（硬件加速）" class="headerlink" title="如何变成复合图层（硬件加速）"></a>如何变成复合图层（硬件加速）</h3><p>将该元素变成一个复合图层，就是传说中的硬件加速技术</p><h3 id="absolute和硬件加速的区别"><a href="#absolute和硬件加速的区别" class="headerlink" title="absolute和硬件加速的区别"></a>absolute和硬件加速的区别</h3><p>可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。<br>所以，就算absolute中信息改变时不会改变普通文档流中render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。</p><p>（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）</p><p>而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p><h3 id="复合图层的作用？"><a href="#复合图层的作用？" class="headerlink" title="复合图层的作用？"></a>复合图层的作用？</h3><p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能</p><p>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡</p><h2 id="从Event-Loop谈JS的运行机制"><a href="#从Event-Loop谈JS的运行机制" class="headerlink" title="从Event Loop谈JS的运行机制"></a>从Event Loop谈JS的运行机制</h2><ul><li>JS分为同步任务和异步任务</li><li>同步任务都在主线程上执行，形成一个<code>执行栈</code></li><li>主线程之外，<strong>事件触发线程</strong>管理着一个<code>任务队列</code>，只要异步任务有了运行结果，就在<code>任务队列</code>之中放置一个事件。</li><li>一旦<code>执行栈</code>中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取<code>任务队列</code>，将可运行的异步任务添加到可执行栈中，开始执行。</li></ul><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200330121739552.png" alt="image-20200330121739552" style="zoom:50%;"><h2 id="事件循环机制进一步补充"><a href="#事件循环机制进一步补充" class="headerlink" title="事件循环机制进一步补充"></a>事件循环机制进一步补充</h2><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200330121911081.png" alt="image-20200330121911081" style="zoom:50%;"><p>上图大致描述就是：</p><ul><li>主线程运行时会产生执行栈，栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）</li><li>而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调</li><li>如此循环</li><li>注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件</li></ul><h2 id="单独说说定时器"><a href="#单独说说定时器" class="headerlink" title="单独说说定时器"></a>单独说说定时器</h2><ul><li>上述事件循环机制的核心是：JS引擎线程和事件触发线程</li><li><strong>当使用<code>setTimeout</code>或<code>setInterval</code>时</strong>，需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中</li></ul><h2 id="setTimeout而不是setInterval"><a href="#setTimeout而不是setInterval" class="headerlink" title="setTimeout而不是setInterval"></a>setTimeout而不是setInterval</h2><ul><li><p>用setTimeout模拟定期计时和直接用setInterval是有区别的</p></li><li><p>因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差（误差多少与代码执行时间有关）</p><p>  而setInterval则是每次都精确的隔一段时间推入一个事件<br>  （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</p><p>  而且setInterval有一些比较致命的问题就是：</p><ul><li><p>累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔。就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）</p></li><li><p>譬如像iOS的webview,或者Safari等浏览器中都有一个特点，<strong>在滚动的时候是不执行JS的</strong>，如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误（这一块后续有补充，setInterval自带的优化，不会重复添加回调）</p></li><li><p>而且把浏览器最小化显示等操作时，setInterval并不是不执行程序，它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时</p><p>所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame</p></li></ul></li></ul><h2 id="事件循环进阶：macrotask与microtask"><a href="#事件循环进阶：macrotask与microtask" class="headerlink" title="事件循环进阶：macrotask与microtask"></a>事件循环进阶：macrotask与microtask</h2><ul><li>Promise里有了一个一个新的概念：<code>microtask</code></li><li>JS中分为两种任务类型：<strong><code>macrotask</code>和<code>microtask</code></strong>，在ECMAScript中，microtask称为<code>jobs</code>，macrotask可称为<code>task</code></li></ul><p>区别：</p><ul><li>macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</li><li>每一个task会从头到尾将这个任务执行完毕，不会执行其它</li><li>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染<br>  （<code>task-&gt;渲染-&gt;task-&gt;...</code>）</li><li>microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务</li><li>也就是说，在当前task任务后，下一个task之前，在渲染之前</li><li>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染</li><li>也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）</li></ul><p>分别什么样的场景会形成macrotask和microtask呢？</p><ul><li>macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）</li><li>microtask：Promise，process.nextTick等</li></ul><p>再根据线程来理解下：</p><ul><li>macrotask中的事件都是放在一个事件队列中的，而这个队列由<strong>事件触发线程</strong>维护</li><li>microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由<strong>JS引擎线程维护</strong><br>  （这点由自己理解+推测得出，因为它是在主线程下无缝执行的）</li></ul><p>所以，总结下运行机制：</p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ul><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200330122837010.png" alt="image-20200330122837010" style="zoom:50%;">]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖&amp;节流</title>
      <link href="/2020/03/28/%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81/"/>
      <url>/2020/03/28/%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/Antwan-Dmy/p/10714445.html" target="_blank" rel="noopener">https://www.cnblogs.com/Antwan-Dmy/p/10714445.html</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试准备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>module</title>
      <link href="/2020/03/28/23-24-module/"/>
      <url>/2020/03/28/23-24-module/</url>
      
        <content type="html"><![CDATA[<h1 id="Module-的语法"><a href="#Module-的语法" class="headerlink" title="Module 的语法"></a>Module 的语法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>CommonJS 模块就是对象，输入时必须查找对象属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><blockquote><p>整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p></blockquote><ul><li>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><ul><li>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载</li><li>这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高</li><li>这也导致了没法引用 ES6 模块本身，因为它不是对象。</li></ul><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><ul><li>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code></li><li>限制<ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用<code>with</code>语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li><li><code>eval</code>不会在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li><code>arguments</code>不会自动反映函数参数的变化</li><li>不能使用<code>arguments.callee</code></li><li>不能使用<code>arguments.caller</code></li><li>禁止<code>this</code>指向全局对象</li><li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li><li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li></ul></li><li>ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code></li></ul><h2 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h2><ul><li>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取</li><li>如果希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</li><li>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。重命名后，可以用不同的名字输出两次</li><li><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值</li></ul><blockquote><p><code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷</p></blockquote><h2 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h2><ul><li><code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名</li><li><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口</li><li>如果是对象，属性可修改，但不建议这样做</li><li><code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行<ul><li>本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前</li></ul></li><li>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构</li></ul><h2 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h2><ul><li><code>import * (as xxx) from &#39;...&#39;</code></li></ul><h2 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h2><ul><li><code>export default xxx</code> 不需要大括号，<code>import xxx from &#39;...&#39;</code> 也不需要大括号</li></ul><blockquote><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令</p></blockquote><ul><li>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字</li></ul><h2 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure><ul><li>写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，当前模块不能直接使用<code>foo</code>和<code>bar</code></li></ul><h2 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h2><ul><li><code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中</li><li>有利于编译器提高效率，但也导致无法在运行时加载模块</li><li>ES2020 提案引入 <code>import()</code> 函数支持动态加载模块</li></ul><h1 id="Module-的加载实现"><a href="#Module-的加载实现" class="headerlink" title="Module 的加载实现"></a>Module 的加载实现</h1><h2 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><ul><li>浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间</li><li>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载</li><li><code>&lt;script&gt;</code> 标签打开 defer 或 async 属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令</li></ul><blockquote><p><code>defer</code>与<code>async</code>的区别是：<code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</p><p>一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。</p><p>另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的</p></blockquote><h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><ul><li>浏览器加载 ES6 模块，也使用 <code>&lt;script&gt;</code> 标签，但是要加入 <code>type=&quot;module&quot;</code> 属性</li><li><code>module</code> 属性都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了``标签的<code>defer</code>属性</li></ul><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用<ul><li>一旦输出一个值，模块内部的变化就影响不到这个值</li></ul></li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口<ul><li>生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值</li><li>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型 &amp; 原型链</title>
      <link href="/2020/03/25/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2020/03/25/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>原文：<a href="https://mengera88.github.io/2017/06/06/javascript对象详解：搞清楚原型与原型链/" target="_blank" rel="noopener">https://mengera88.github.io/2017/06/06/javascript%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%90%9E%E6%B8%85%E6%A5%9A%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试准备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise 学习笔记</title>
      <link href="/2020/03/25/Promise/"/>
      <url>/2020/03/25/Promise/</url>
      
        <content type="html"><![CDATA[<p>原文：<a href="https://mengera88.github.io/2017/05/18/Promise原理解析/" target="_blank" rel="noopener">https://mengera88.github.io/2017/05/18/Promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</a></p><h2 id="极简雏形"><a href="#极简雏形" class="headerlink" title="极简雏形"></a>极简雏形</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="literal">null</span>,</span><br><span class="line">      callbacks = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    callbacks.push(onFulfilled);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    callbacks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      callback(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码逻辑<ol><li>调用 <code>then</code> 方法，将想要在 <code>Promise</code> 异步操作成功时执行的回调放入 <code>callbacks</code> 队列<ul><li>就是注册回调函数，观察者模式</li></ul></li><li>创建 <code>Promise</code> 实例时传入的函数 <code>fn</code> 会被赋予一个函数类型的参数，即 <code>resolve</code><ul><li><code>resolve</code> 接收一个参数 value，代表异步操作的返回结果</li></ul></li><li>当异步操作执行成功后，用户会调用 <code>resolve</code> 方法。真实操作是将 <code>callbacks</code> 队列中的回调一一执行</li></ol></li><li>代码分析<ul><li><code>new Promise</code> 时，传给 <code>promise</code> 的函数发送异步请求</li><li>接着调用 <code>promise</code> 对象的 <code>then</code> 属性，注册请求成功的回调函数</li><li>当异步请求发送成功时，调用 <code>resolve(results.id)</code> 方法，该方法执行 <code>then</code> 方法注册的回调数组</li></ul></li></ul><h3 id="支持链式调用"><a href="#支持链式调用" class="headerlink" title="支持链式调用"></a>支持链式调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="literal">null</span>,</span><br><span class="line">      callbacks = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    callbacks.push(onFulfilled);</span><br><span class="line">==&gt; <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    callbacks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      callback(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加入延时时机"><a href="#加入延时时机" class="headerlink" title="加入延时时机"></a>加入延时时机</h3><ul><li>保证 <code>resolve</code> 执行之前，<code>then</code> 方法已经注册完所有的回调</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="literal">null</span>,</span><br><span class="line">      callbacks = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    callbacks.push(onFulfilled);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">==&gt; setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callbacks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        callback(value);</span><br><span class="line">      &#125;);</span><br><span class="line">==&gt; &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码逻辑<ul><li>利用 <code>setTimeout</code> 机制，将 <code>resolve</code> 中执行回调的逻辑放置到任务队列末尾，保证执行 <code>resolve</code> 中的代码时，<code>then</code> 方法的回调函数已经注册完成</li></ul></li><li>问题<ul><li>在 <code>Promise</code> 异步操作成功之后才调用 <code>then</code> 注册的回调不会执行</li></ul></li></ul><h3 id="加入状态"><a href="#加入状态" class="headerlink" title="加入状态"></a>加入状态</h3><ul><li>即加入 pending -&gt; fulfilled</li><li>或 pending -&gt; rejected</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="literal">null</span>,</span><br><span class="line">      callbacks = [],</span><br><span class="line">==&gt;   state = <span class="string">'pending'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">==&gt; <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      callbacks.push(onFulfilled);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">==&gt; &#125;</span><br><span class="line">==&gt; onFulfilled(value);</span><br><span class="line">==&gt; <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">==&gt; value = newValue;</span><br><span class="line">==&gt; state = <span class="string">'fulfilled'</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callbacks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        callback(value);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码逻辑<ul><li><code>resolve</code> 执行时，将状态设置为 <code>fultilled</code>，之后调用<code>then</code> 添加的新回调都会立即执行，不需要加入 <code>callbacks</code> 队列</li></ul></li></ul><h3 id="链式-Promise"><a href="#链式-Promise" class="headerlink" title="链式 Promise"></a>链式 Promise</h3><ul><li>如果 <code>then</code> 函数里面注册的仍是 <code>Promise</code>，只要在<code>then</code>方法里面<code>return</code>一个<code>promise</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span>,</span><br><span class="line">      value = <span class="literal">null</span>,</span><br><span class="line">      callbacks = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">&gt;     handle(&#123;</span><br><span class="line">&gt;       onFulfilled: onFulfilled || <span class="literal">null</span>,</span><br><span class="line">&gt;       resolve: resolve</span><br><span class="line">&gt;     &#125;);</span><br><span class="line">&gt;   &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      callbacks.push(callback);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&gt;   <span class="comment">// 如果 then 中没有传递任何东西</span></span><br><span class="line">&gt;   <span class="keyword">if</span> (!callback.onFultilled) &#123;</span><br><span class="line">&gt;     callback.resolve(value);</span><br><span class="line">&gt;     <span class="keyword">return</span>;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   <span class="keyword">var</span> ret = callback.onFulfilled(value);</span><br><span class="line">&gt;   callback.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">if</span> (newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">'object'</span> || <span class="keyword">typeof</span> newValue === <span class="string">'function'</span>)) &#123;</span><br><span class="line">&gt;     <span class="keyword">var</span> then = newValue.then;</span><br><span class="line">&gt;     <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">&gt;       then.call(newValue, resolve);</span><br><span class="line">&gt;       <span class="keyword">return</span>;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">    value = newValue;</span><br><span class="line">    state = <span class="string">'fulfilled'</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callbacks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        handle(callback);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码逻辑<ol><li><code>then</code> 方法中，创建并返回了新的 <code>Promise</code> 实例<ul><li>串行 <code>Promise</code> 的基础，并且支持链式调用</li></ul></li><li><code>handle</code> 方法是 <code>Promise</code> 内部的方法，<code>then</code> 方法传入的行参 <code>onFulfilled</code> 以及创建新 <code>Promise</code> 实例时传入的 <code>resolve</code> 均被 <code>push</code> 到当前 <code>promise</code> 的 <code>callbacks</code> 队列中<ul><li>这是衔接当前 <code>Promise</code> 实例和后邻 <code>promise</code> 的关键</li></ul></li></ol></li></ul><h3 id="失败处理"><a href="#失败处理" class="headerlink" title="失败处理"></a>失败处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span>,</span><br><span class="line">      value = <span class="literal">null</span>,</span><br><span class="line">      callbacks = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onFulfilled: onFulfilled || <span class="literal">null</span>,</span><br><span class="line">&gt;       onRejected: onRejected || <span class="literal">null</span>,</span><br><span class="line">        resolve: resolve,</span><br><span class="line">&gt;       reject: reject</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      callbacks.push(callback);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 then 中没有传递任何东西</span></span><br><span class="line">    <span class="keyword">if</span> (!callback.onFultilled) &#123;</span><br><span class="line">      callback.resolve(value);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&gt;   <span class="keyword">var</span> cb = state === <span class="string">'fullfilled'</span> ? callback.onFulfilled : callback.onRejected;</span><br><span class="line">&gt;   <span class="keyword">if</span> (cb === <span class="literal">null</span>) &#123;</span><br><span class="line">&gt;     cb = state === <span class="string">'fulfilled'</span> ? callback.resolve : callback.reject;</span><br><span class="line">&gt;     cb(value);</span><br><span class="line">&gt;     <span class="keyword">return</span>;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">    <span class="keyword">var</span> ret = cb(value);</span><br><span class="line">    callback.resolve(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">'object'</span> || <span class="keyword">typeof</span> newValue === <span class="string">'function'</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> then = newValue.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(newValue, resolve);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state = <span class="string">'fulfilled'</span>;</span><br><span class="line">    value = newValue;</span><br><span class="line">&gt;   execute();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">&gt;   state = <span class="string">'rejected'</span>;</span><br><span class="line">&gt;   value = reason;</span><br><span class="line">&gt;   execute();</span><br><span class="line">&gt; &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callbacks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        handle(callback);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>抽离 <code>resolve</code> 和 <code>reject</code> 公共部分作为 <code>execute</code> </li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="string">'pending'</span>,</span><br><span class="line">      value = <span class="literal">null</span>,</span><br><span class="line">      callbacks = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onFulfilled: onFulfilled || <span class="literal">null</span>,</span><br><span class="line">        onRejected: onRejected || <span class="literal">null</span>,</span><br><span class="line">        resolve: resolve,</span><br><span class="line">        reject: reject</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      callbacks.push(callback);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 then 中没有传递任何东西</span></span><br><span class="line">    <span class="keyword">if</span> (!callback.onFultilled) &#123;</span><br><span class="line">      callback.resolve(value);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cb = state === <span class="string">'fullfilled'</span> ? callback.onFulfilled : callback.onRejected;</span><br><span class="line">    <span class="keyword">if</span> (cb === <span class="literal">null</span>) &#123;</span><br><span class="line">      cb = state === <span class="string">'fulfilled'</span> ? callback.resolve : callback.reject;</span><br><span class="line">      cb(value);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&gt;   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> ret = cb(value);</span><br><span class="line">      callback.resolve(ret);</span><br><span class="line">&gt;   &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&gt;     callback.reject(e);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">'object'</span> || <span class="keyword">typeof</span> newValue === <span class="string">'function'</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> then = newValue.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(newValue, resolve);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state = <span class="string">'fulfilled'</span>;</span><br><span class="line">    value = newValue;</span><br><span class="line">    execute();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    state = <span class="string">'rejected'</span>;</span><br><span class="line">    value = reason;</span><br><span class="line">    execute();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callbacks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        handle(callback);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>promise里面的then函数仅仅是注册了后续需要执行的代码</li><li>真正的执行是在resolve方法里面执行的</li></ul><blockquote><p>Promise 主要使用了设计模式中的观察者模式：</p><ol><li>通过 Promise.prototype.then 和 Promise.prototype.catch 方法将观察者方法注册到被观察者 Promise 对象中，同时返回一个新的 Promise 对象，以便可以链式调用。</li><li>被观察者管理内部 pending、fulfilled 和 rejected 的状态转变，同时通过构造函数中传递的 resolve 和 reject 方法以主动触发状态转变和通知观察者。</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 面试准备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class的基本语法和继承</title>
      <link href="/2020/03/24/21-22-Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E7%BB%A7%E6%89%BF/"/>
      <url>/2020/03/24/21-22-Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="Class-的基本语法"><a href="#Class-的基本语法" class="headerlink" title="Class 的基本语法"></a>Class 的基本语法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="类的由来"><a href="#类的由来" class="headerlink" title="类的由来"></a>类的由来</h3><ul><li>js 中生成实例对象的传统方法是通过构造函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">','</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li>Es6 为了接近传统语言，引入了 Class，作为对象的模版。</li><li>通过 <code>class</code> 关键字，可以定义类</li><li>Es6 的 <code>clss</code> 看作一个语法糖，大部分功能 es5 都可以做到，只是让写法更像面向对象编程的语法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">','</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ES5 的构造函数 <code>Point</code>，对应 ES6 的 <code>Point</code> 类的构造方法 <code>constructor</code></p></li><li><p>类的数据类型就是函数，类本身就指向构造函数</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>使用的时候，直接用 <code>new</code> 命令，跟构造函数一样</li><li>类的所有方法都定义在类的<code>prototype</code>属性上面</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  toValue() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在类的实例上调用方法，就是调用原型上的方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>类的方法都是定义在 <code>prototype</code> 对象上面所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>prototype</code>对象的<code>constructor</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point.prototype.constructor === Point</span><br></pre></td></tr></table></figure><ul><li>类的内部所有定义的方法，都是不可枚举的（non-enumerable），这与 ES5 的行为不一致</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// ["constructor","toString"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的写法可枚举</span></span><br><span class="line"><span class="keyword">var</span> Point = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// ["toString"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// ["constructor","toString"]</span></span><br></pre></td></tr></table></figure><h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><ul><li><code>constructor</code> 方法都是类的默认方法，通过 <code>new</code> 命令生成对象实例时，自动调用该方法</li><li>一个类必须有 <code>constructor</code> 方法，如果没有显示定义，一个空的 <code>constructor</code> 方法会被默认添加</li><li><code>constructor</code> 方法默认返回实例对象（即 <code>this</code>），可以手动指定返回另外一个对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行</li></ul><h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><ul><li>必须用 <code>new</code> 生成</li><li>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">point.toString() <span class="comment">// (2, 3)</span></span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(<span class="string">'x'</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'y'</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>类的所有实例共享一个原型对象，可以通过实例的<code>__proto__</code>属性为“类”添加方法</li></ul><blockquote><p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf</code> 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p></blockquote><h3 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h3><ul><li>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> prop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> prop(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line"><span class="comment">// 'getter'</span></span><br></pre></td></tr></table></figure><ul><li>存值函数和取值函数是定义在属性的描述对象上面，这与 ES5 完全一致</li></ul><h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'getArea'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Square类的方法名getArea，是从表达式得到的</span></span><br></pre></td></tr></table></figure><h3 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h3><ul><li>与函数一样，类也可以使用表达式的形式定义</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类的名字是Me，但是Me只在 Class 的内部可用，指代当前类</span></span><br><span class="line"><span class="comment">// 在 Class 外部，这个类只能用 MyClass 引用</span></span><br><span class="line"><span class="comment">// 内部不用 Me 可以省略</span></span><br><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li>立即执行的 Class</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">'张三'</span>);</span><br><span class="line"></span><br><span class="line">person.sayName(); <span class="comment">// "张三"</span></span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>严格模式<ul><li>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式</li></ul></li><li>类不存在变量提升</li><li>name 属性的值是类名</li><li>Generator 方法<ul><li>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数</li></ul></li><li>this<ul><li>类的方法内部如果含有<code>this</code>，它默认指向类的实例</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  printName(name = <span class="string">'there'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(text) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line">printName(); <span class="comment">// TypeError: Cannot read property 'print' of undefined</span></span><br><span class="line"><span class="comment">// this会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到print方法而报错</span></span><br></pre></td></tr></table></figure><ul><li>解决办法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法中绑定`this`，这样就不会找不到`print`方法了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="keyword">this</span>.printName.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getThis = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObj = <span class="keyword">new</span> Obj();</span><br><span class="line">myObj.getThis() === myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Proxy，获取方法的时候，自动绑定this</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfish</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> Logger());</span><br></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul><li>类相当于实例的原型，所有在类中定义的方法，都会被实例继承</li><li>如果在一个方法前加上 <code>static</code> 关键字，表示该方法不会被实例继承，而是通过类来调用，称为“静态方法”</li><li>如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例</li><li>静态方法可以与非静态方法重名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> bar() &#123;</span><br><span class="line">    <span class="keyword">this</span>.baz();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> baz() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  baz() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><ul><li>父类的静态方法，可以被子类继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure><ul><li>静态方法也是可以从<code>super</code>对象上调用的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + <span class="string">', too'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// "hello, too"</span></span><br></pre></td></tr></table></figure><h2 id="实例属性和新写法"><a href="#实例属性和新写法" class="headerlink" title="实例属性和新写法"></a>实例属性和新写法</h2><ul><li>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>._count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><ul><li>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法（提案）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> prop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h2><ul><li><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问</p></li><li><p>这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现</p></li></ul><h3 id="现有的解决方案"><a href="#现有的解决方案" class="headerlink" title="现有的解决方案"></a>现有的解决方案</h3><ul><li>命名上加以区别<ul><li>不保险，在类的外部还是可以调用</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    <span class="keyword">this</span>._bar(baz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  _bar(baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将私有方法移出模块，因为模块内部的所有方法都是对外可见的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(<span class="keyword">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值<ul><li><code>Reflect.ownKeys()</code> 可以拿到</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">'snaf'</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span>&#123;</span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo(baz) &#123;</span><br><span class="line">    <span class="keyword">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>提案<ul><li>属性名之前，使用<code>#</code>表示</li></ul></li></ul><h2 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h2><ul><li>用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数</li><li>如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code></li><li>因此这个属性可以用来确定构造函数是怎么调用的</li><li>子类继承父类时，<code>new.target</code>会返回子类</li><li>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类</li><li>在函数外部，使用<code>new.target</code>会报错</li></ul><h1 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul><li>通过<code>extends</code>关键字实现继承</li><li>ES5 通过修改原型链实现继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象</li></ul><blockquote><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p></blockquote><blockquote><p>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p></blockquote><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><ul><li><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类</li><li>可以使用这个方法判断，一个类是否继承了另一个类</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint) === Point</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><ul><li><code>super</code>作为函数调用时，代表父类的构造函数，只能用在子类的构造函数中<ul><li>ES6 要求，子类的构造函数必须执行一次<code>super</code>函数</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// super虽然代表了父类A的构造函数，但是返回的是子类B的实例</span></span><br><span class="line"><span class="comment">// 即super内部的this指的是B的实例</span></span><br><span class="line"><span class="comment">// super()在这里相当于A.prototype.constructor.call(this)。</span></span><br></pre></td></tr></table></figure><ul><li><code>super</code>作为对象时<ul><li>在普通方法中，指向父类的原型对象<ul><li>定义在父类实例上的方法或属性无法通过 <code>super</code> 调用</li><li>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例</li></ul></li><li>在静态方法中，指向父类<ul><li>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例</li></ul></li></ul></li><li>使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错</li></ul><h2 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和 __proto__ 属性"></a>类的 prototype 属性和 __proto__ 属性</h2><blockquote><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链</p></blockquote><ul><li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类</li><li>子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性</li></ul><blockquote><p>作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）</p><p>作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例</p></blockquote><h3 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 __proto__ 属性"></a>实例的 __proto__ 属性</h3><ul><li>子类实例的 <code>__proto__</code> 属性的<code>__proto__</code> 属性，指向父类实例的 <code>__proto__</code> 属性。子类的原型，是父类的原型</li></ul><h2 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h2><ul><li>Boolean()</li><li>Number()</li><li>String()</li><li>Array()</li><li>Date()</li><li>Function()</li><li>RegExp()</li><li>Error()</li><li>Object()</li></ul><h2 id="Mixin-模式的实现"><a href="#Mixin-模式的实现" class="headerlink" title="Mixin 模式的实现"></a>Mixin 模式的实现</h2><ul><li>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  a: <span class="string">'a'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  b: <span class="string">'b'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;...a, ...b&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async函数</title>
      <link href="/2020/03/24/20-async%E5%87%BD%E6%95%B0/"/>
      <url>/2020/03/24/20-async%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><ul><li><p>async 使异步操作变得更加方便，Generator 的语法糖</p></li><li><p>将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await</p></li><li><p>async 对 Generator 函数的改进：</p><ul><li>内置执行器，会自动执行<ul><li>Generator 需要 co 模块才能自动执行</li><li>或者调用 next 手动执行</li></ul></li><li>更好的语义</li><li>更广的适用性<ul><li>await 后面可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，会自动转成立即 resolved 的 Promise 对象）</li></ul></li><li>返回值是 Promise</li></ul></li><li><p>async 可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖</p></li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul><li>async 函数返回一个 Promise 对象，可以使用 <code>then</code> 方法添加回调函数</li><li>当函数执行的时候，一旦遇到 <code>await</code> 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li><p>返回 Promise 对象</p><ul><li><code>async</code> 函数内部 <code>return</code> 语句返回值，会成为 <code>then</code> 方法回调函数的参数</li><li><code>async</code> 函数内部抛出错误，会导致返回的 Promise 对象变为 <code>reject</code> 状态</li></ul></li><li><p>Promise 对象的状态变化</p><ul><li><code>async</code> 函数返回的 Promise 对象，必须等到内部所有 <code>await</code> 命令后面的 Promise 对象执行完，才会发生状态改变</li><li>除非 <code>return</code> 或抛出错误</li><li>也就是说，只有 <code>async</code> 函数内部的异步操作执行完，才会执行 <code>then</code> 方法指定的回调函数</li></ul></li><li><p>await 命令</p><ul><li>如果 await 后面是一个 <code>thenable</code> 对象（定义了 <code>then</code> 方法的对象），会将其同等于 Promise 对象</li><li>任何一个 <code>await</code> 语句后面的 Promise 对象变为 <code>reject</code> 状态，整个 <code>async</code> 函数都会中断执行<ul><li>可以在 <code>async</code>  内部进行错误处理，catch 错误就不会影响后续执行</li></ul></li></ul></li><li><p>注意点</p><ul><li><p>最好把 <code>await</code> 命令放在 <code>try...catch</code> 代码块中</p></li><li><p>多个 <code>await</code> 命令后面的异步操作，如果不存在继发关系，最好同时触发，比较不耗时</p><ul><li><pre><code class="js"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);<span class="comment">// 或</span><span class="keyword">let</span> fooPromise = getFoo();<span class="keyword">let</span> barPromise = getBar();<span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;<span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;&lt;!--￼<span class="number">0</span>--&gt;</code></pre></li></ul></li></ul></li></ul><h2 id="顶层-await"><a href="#顶层-await" class="headerlink" title="顶层 await"></a>顶层 await</h2><ul><li>语法提案</li><li>借用 <code>await</code> 解决模块异步加载的问题</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 常考知识点</title>
      <link href="/2020/03/24/Vue%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/03/24/Vue%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-常考知识点"><a href="#Vue-常考知识点" class="headerlink" title="Vue 常考知识点"></a>Vue 常考知识点</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li><p><code>beforeCreate</code> ：获取不到 <code>props</code> 或者 <code>data</code> 中的数据的，因为这些数据的初始化都在 <code>initState</code> 中。</p></li><li><p><code>created</code> ：可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。</p></li><li><p><code>beforeMount</code> ：开始创建 VDOM，组件中如果有子组件的话，会递归挂载子组件</p></li><li><p><code>mounted</code> ：将 VDOM 渲染为真实 DOM 并且渲染数据</p></li><li><p><code>beforeUpdate</code> ：数据更新前</p></li><li><p><code>updated</code>：数据更新后</p></li></ol><ul><li><code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> <ul><li>用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</li></ul></li></ul><ol start="7"><li><code>beforeDestroy</code> ：适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件</li><li><code>destroyed</code>：所有子组件都销毁完毕后才会执行</li></ol><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><ul><li>props、emit</li><li>访问 <code>$parent</code> 或者 <code>$children</code> 对象</li></ul><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><ul><li>通过查找父组件中的子组件实现，也就是 <code>this.$parent.$children</code></li><li>在 <code>$children</code> 中可以通过组件 <code>name</code> 查询到需要的组件实例</li></ul><h3 id="跨多层级组件通信"><a href="#跨多层级组件通信" class="headerlink" title="跨多层级组件通信"></a>跨多层级组件通信</h3><h3 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h3><ul><li>Vuex</li></ul><h2 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h2><ul><li><p><code>computed</code> 是计算属性，依赖其他属性计算值，并且 <code>computed</code> 的值有缓存，只有当计算值变化才会返回内容。</p></li><li><p><code>watch</code> 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p></li></ul><h2 id="v-show-与-v-if-区别"><a href="#v-show-与-v-if-区别" class="headerlink" title="v-show 与 v-if 区别"></a>v-show 与 v-if 区别</h2><ul><li><p><code>v-show</code> 只是在 <code>display: none</code> 和 <code>display: block</code> 之间切换。</p><ul><li>无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。</li><li>所以总的来说 <code>v-show</code> 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</li></ul></li><li><p><code>v-if</code> 的话就得说到 Vue 底层的编译了。</p><ul><li>当属性初始为 <code>false</code> 时，组件就不会被渲染，直到条件为 <code>true</code>，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。</li><li>并且基于 <code>v-if</code> 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</li></ul></li></ul><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><ul><li>通过正则表达式将模版解析为 AST（Abstract Syntax Tree，抽象语法树）</li><li>优化 AST：对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功</li><li>将 AST 转换为 <code>render</code> 函数：遍历整个 AST，根据不同的条件生成不同的代码</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React和Vue</title>
      <link href="/2020/03/24/React%E5%92%8CVue/"/>
      <url>/2020/03/24/React%E5%92%8CVue/</url>
      
        <content type="html"><![CDATA[<p>内容转自掘金小册《前端面试之道》</p><h1 id="React-和-Vue"><a href="#React-和-Vue" class="headerlink" title="React 和 Vue"></a>React 和 Vue</h1><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>不管是 React 还是 Vue，它们都不是 MVVM 框架，只是借鉴 MVVM 的思路</p><ul><li>View ：用户看到的视图</li><li>Model：本地数据和数据库中的数据</li></ul><p>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。</p><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200324175720375.png" alt="image-20200324175720375" style="zoom:50%;"><ul><li>ViewModel：只关心数据和业务的处理，不关心 View 如何处理数据</li></ul><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200324175836531.png" alt="image-20200324175836531" style="zoom:50%;"><ul><li>Binnder（隐式）：实现了 View 和 ViewModel 的绑定</li></ul><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200324180259118.png" alt="image-20200324180259118" style="zoom:50%;"><ul><li>精髓：<strong>通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象</strong></li></ul><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><h3 id="JS-模拟-DOM"><a href="#JS-模拟-DOM" class="headerlink" title="JS 模拟 DOM"></a>JS 模拟 DOM</h3><ul><li>操作 DOM 很慢，相较于 DOM 来说，操作 JS 对象会快很多，可以通过 JS 来模拟 DOM</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = &#123;</span><br><span class="line">  tag: <span class="string">'ul'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    class: 'list'</span><br><span class="line">  &#125;,</span><br><span class="line">  children: &#123;</span><br><span class="line">    tag: <span class="string">'li'</span>,</span><br><span class="line">    children: <span class="string">'1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对应的 DOM 就是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">'list'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Virtual-DOM-的-diff-算法"><a href="#Virtual-DOM-的-diff-算法" class="headerlink" title="Virtual DOM 的 diff 算法"></a>Virtual DOM 的 diff 算法</h3><ul><li>通过 JS 来模拟 DOM 并且渲染对应的 DOM 只是第一步，难点在于<u>如何判断新旧两个 JS 对象的<strong>最小差异</strong>并且实现<strong>局部更新</strong> DOM。</u></li><li>Virtual DOM 只会对同一个层级的元素进行对比<ul><li>深度优先遍历，每遍历到一个节点就把该节点和新的的树进行对比，如果有差异的话就记录到一个对象里<ul><li>key 作为唯一表示</li></ul></li><li>差异类型<ul><li>替换掉原来的节点</li><li>移动、删除、新增子节点</li><li>修改了节点的属性</li><li>对于文本节点，文本内容可能会改变</li></ul></li></ul></li></ul><h3 id="把差异应用到真正的DOM树上"><a href="#把差异应用到真正的DOM树上" class="headerlink" title="把差异应用到真正的DOM树上"></a>把差异应用到真正的DOM树上</h3><ul><li>对 DOM 树也进行深度优先的遍历，遍历的时候从保存差异的对象中找出当前遍历的节点差异，然后进行 DOM 操作</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1\. 构建虚拟DOM</span></span><br><span class="line"><span class="keyword">var</span> tree = el(<span class="string">'div'</span>, &#123;<span class="string">'id'</span>: <span class="string">'container'</span>&#125;, [</span><br><span class="line">    el(<span class="string">'h1'</span>, &#123;<span class="attr">style</span>: <span class="string">'color: blue'</span>&#125;, [<span class="string">'simple virtal dom'</span>]),</span><br><span class="line">    el(<span class="string">'p'</span>, [<span class="string">'Hello, virtual-dom'</span>]),</span><br><span class="line">    el(<span class="string">'ul'</span>, [el(<span class="string">'li'</span>)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2\. 通过虚拟DOM构建真正的DOM</span></span><br><span class="line"><span class="keyword">var</span> root = tree.render()</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(root)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3\. 生成新的虚拟DOM</span></span><br><span class="line"><span class="keyword">var</span> newTree = el(<span class="string">'div'</span>, &#123;<span class="string">'id'</span>: <span class="string">'container'</span>&#125;, [</span><br><span class="line">    el(<span class="string">'h1'</span>, &#123;<span class="attr">style</span>: <span class="string">'color: red'</span>&#125;, [<span class="string">'simple virtal dom'</span>]),</span><br><span class="line">    el(<span class="string">'p'</span>, [<span class="string">'Hello, virtual-dom'</span>]),</span><br><span class="line">    el(<span class="string">'ul'</span>, [el(<span class="string">'li'</span>), el(<span class="string">'li'</span>)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4\. 比较两棵虚拟DOM树的不同</span></span><br><span class="line"><span class="keyword">var</span> patches = diff(tree, newTree)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5\. 在真正的DOM元素上应用变更</span></span><br><span class="line">patch(root, patches)</span><br></pre></td></tr></table></figure><h2 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h2><ul><li><strong>监听 URL 的变化</strong>，然后匹配路由规则，显示相应的页面</li></ul><h3 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h3><ul><li><code>www.test.com/#/</code> 就是 Hash URL，当 <code>#</code> 后面的哈希值发生变化时，可以通过 <code>hashchange</code> 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 <code>www.test.com</code>。</li></ul><h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><ul><li>History 模式是 HTML5 新推出的功能，主要使用 <code>history.pushState</code> 和 <code>history.replaceState</code> 改变 URL。</li><li>通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>Hash 模式只可以更改 <code>#</code> 后面的内容，History 模式可以通过 API 设置任意的同源 URL</li><li>History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串</li><li>Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 <code>index.html</code> 页面用于匹配不到静态资源的时候。</li></ul><h2 id="Vue-和-React-之间的区别"><a href="#Vue-和-React-之间的区别" class="headerlink" title="Vue 和 React 之间的区别"></a>Vue 和 React 之间的区别</h2><ul><li>v-model</li><li>setState</li><li>JSX</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入响应式原理</title>
      <link href="/2020/03/24/%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2020/03/24/%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在简历上写了熟悉 Vue（并不），只好临时抱佛脚……</p><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/reactivity.html</a></p><h1 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h1><blockquote><p>Vue 最独特的特性之一，是其非侵入性的响应式系统。</p><p>数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新，这使得状态管理非常简单直接。</p><p>不过理解其工作原理同样重要，这样你可以避开一些常见的问题。</p></blockquote><h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><blockquote><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的属性，并使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener"><code>Object.defineProperty</code></a> 把这些属性全部转为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#定义_getters_与_setters" target="_blank" rel="noopener">getter/setter</a>。</p></blockquote><p>先来看看这个<code>Object.defineProperty</code>，查阅 MDN：</p><blockquote><p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><p>直接在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener"><code>Object</code></a> 构造器对象上调用此方法，而不是实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>:<span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(o, &#123;</span><br><span class="line">    <span class="string">"b"</span>: &#123; <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>; &#125; &#125;,</span><br><span class="line">    <span class="string">"c"</span>: &#123; <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">this</span>.a = x / <span class="number">2</span>; &#125; &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">o.c = <span class="number">10</span> <span class="comment">// Runs the setter, which assigns 10 / 2 (5) to the 'a' property</span></span><br><span class="line"><span class="built_in">console</span>.log(o.b) <span class="comment">// Runs the getter, which yields a + 1 or 6</span></span><br></pre></td></tr></table></figure></blockquote><p>其实很简单，就是修改 object 对象的方法嘛，注意这不是实例的方法，而是构造器的。</p><blockquote><p><code>Object.defineProperty</code> 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p></blockquote><p>这里是 shim 是什么呢？shim 可以将新的 API 引入到旧的环境中，而且仅靠就环境中已有的手段实现。所以这里的意思是说，<code>Object.defineProperty</code>  这个方法是无法引入到旧的环境的，所以不支持低版本浏览器。</p><blockquote><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在属性被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener">vue-devtools</a> 来获取对检查数据更加友好的用户界面。</p></blockquote><blockquote><p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p><p><img src="https://cn.vuejs.org/images/data.png" alt="data"></p></blockquote><h2 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a>检测变化的注意事项</h2><blockquote><p>受现代 JavaScript 的限制 (而且 <code>Object.observe</code> 也已经被废弃)，Vue <strong>无法检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。</p><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 <code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.someObject, <span class="string">'b'</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>有时你可能需要为已有对象赋值多个新属性，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。但是，这样添加到对象上的新属性不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.someObject = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.someObject, &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure></blockquote><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br></pre></td></tr></table></figure><h3 id="声明响应式属性"><a href="#声明响应式属性" class="headerlink" title="声明响应式属性"></a>声明响应式属性</h3><blockquote><p>由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明所有根级响应式属性，哪怕只是一个空值。</p></blockquote><h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><blockquote><p>Vue 在更新 DOM 时是<strong>异步</strong>执行的。</p><p>只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p><p>如果同一个 watcher 被多次触发，只会被推入到队列中一次。</p><p>这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。</p></blockquote><p>感觉这种处理类似于防抖，提升性能。</p><blockquote><p>然后，在下一个的事件循环 “tick” 中，Vue 刷新队列并执行实际 (已去重的) 工作。</p><p>Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p></blockquote><p><code>Promise.then</code>： ES6</p><p><code>MutationObserver</code>：接口提供了监视对DOM树所做更改的能力。它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分。</p><p><code>setImmediate</code>：非标准。</p><blockquote><p>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code>，该组件不会立即重新渲染。</p><p>当刷新队列时，组件会在下一个事件循环 “tick” 中更新。</p><p>多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。</p><p>虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。</p><p>为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用。</p></blockquote><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><ul><li>Observe，给对象的属性添加 setter/getter 事件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'aaa'</span>&#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">let</span> name = data.name</span><br><span class="line">data.name = <span class="string">'bbb'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 可配置</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 自定义函数</span></span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Dep，用于解耦属性的依赖手机和派发更新操作</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加依赖</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure><ul><li>Watcher，触发依赖收集时的操作</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己</span></span><br><span class="line">    <span class="comment">// 然后触发属性的 getter 添加监听</span></span><br><span class="line">    <span class="comment">// 最后将 Dep.target 置空</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.obj = obj</span><br><span class="line">    <span class="keyword">this</span>.key = key</span><br><span class="line">    <span class="keyword">this</span>.value = obj[key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">    <span class="comment">// 调用 update 方法更新 Dom</span></span><br><span class="line">    <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>改造 <code>defineReactive</code>，添加依赖收集和派发更新相关代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 可配置</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 自定义函数</span></span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue渲染时机</title>
      <link href="/2020/03/24/Vue%E6%B8%B2%E6%9F%93%E6%97%B6%E6%9C%BA/"/>
      <url>/2020/03/24/Vue%E6%B8%B2%E6%9F%93%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>​        最近在改样式时碰到一个很神奇的bug：qrcode 生成一个二维码，绘制在对应的 canvas 标签中，bug 是二维码不显示。代码总共三行，qrcode 的回调 error 是空的，说明至少二维码的创建到绘制是没有错误的。</p><p>​        查看分支记录，发现了一些相关修改：二维码码是放在一个弹窗中的，以前的弹窗是用绝对定位移出可视区域，实际上弹窗是一直存在的。因为设计的需求换成了 AntD，这个弹窗也换成了 modal 组件，只有在点击个人信息的时候才显示。</p><h2 id="Modal-组件渲染时机"><a href="#Modal-组件渲染时机" class="headerlink" title="Modal 组件渲染时机"></a>Modal 组件渲染时机</h2><ul><li>项目采用的都是同步引入的方式，父子组件渲染顺序如下：</li></ul><blockquote><p>加载渲染过程</p><p>父 beforeCreate<br>父 created<br>父 beforeMount<br>子 beforeCreate<br>子 created<br>子 beforeMount<br>子 mounted<br>父 mounted</p><hr><p>更新过程</p><p>父 beforeUpdate<br>子 beforeUpdate<br>子 updated<br>父 updated</p></blockquote><p>生命周期介绍：<a href="https://cn.vuejs.org/v2/api/#选项-生命周期钩子" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90</a></p><h2 id="Bug-分析流程"><a href="#Bug-分析流程" class="headerlink" title="Bug 分析流程"></a>Bug 分析流程</h2><ul><li>现在在 mouted 里面加入绘制二维码的代码</li></ul><blockquote><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200324140454111.png" alt="image-20200324140454111" style="zoom:50%;"><p>document.getElementById(‘canvas’) 获取到的元素为空</p><p>qrcode 报错，这里主要是用来生成二维码的 userInfo.pri_Key 还没获取到值</p></blockquote><ul><li>在 watch 里面加入绘制二维码的代码，监听的是控制弹窗是否显示的变量</li></ul><blockquote><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200324141141884.png" alt="image-20200324141141884" style="zoom:50%;"><p>document.getElementById(‘canvas’) 获取到的元素为空</p><p>userInfo.pri_Key 有值，qrcode 不报错了</p></blockquote><ul><li>很显然，问题就在为什么这个 canvas 标签一直获取不到，那什么时候才能获取到呢？</li></ul><blockquote><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200324150813733.png" alt="image-20200324150813733" style="zoom:50%;"><p>Click 点击显示 modal，要到子组件 updated 时才能获取到标签</p><p>也就是说在 updated 里面才更新 DOM，watch 里面是不更新的</p></blockquote><ul><li>官网里面关于 updated 的描述</li></ul><blockquote><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p><p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a href="https://cn.vuejs.org/v2/api/#computed" target="_blank" rel="noopener">计算属性</a>或 <a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener">watcher</a> 取而代之。</p></blockquote><ul><li>但我们知道，watch 里 DOM 还没更新，我们如何在 watch 里面修改 canvas 呢？</li></ul><blockquote><p>如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick" target="_blank" rel="noopener">vm.$nextTick</a></p></blockquote><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><blockquote><p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。</p></blockquote><ul><li><p>显然，这就是我们需要的方法了。</p><ul><li>等待 DOM 更新，可以得到 canvas 标签</li><li>调用 qrcode 库创建二维码并会绘制到 canvas 上</li></ul></li><li><p>将绘制二维码的代码封装一层 nextTick</p></li></ul><blockquote><img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200324141636792.png" alt="image-20200324141636792" style="zoom:50%;"><p>document.getElementById(‘canvas’) 可以正常获取到元素，二维码正常显示</p></blockquote><h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><blockquote><p>Vue 在更新 DOM 时是<strong>异步</strong>执行的。</p><p>只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p><p>如果同一个 watcher 被多次触发，只会被推入到队列中一次。</p><p>这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。</p><p>然后，在下一个的事件循环 “tick” 中，Vue 刷新队列并执行实际 (已去重的) 工作。</p><p>Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p></blockquote><ul><li>之前误打误撞使用了 setTimeout(fn, 0)，实际上恰好实现了异步队列</li></ul><blockquote><p>如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。</p><p>虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。</p><p>为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>moda 组件在 mounted 时并不会渲染到页面上</li><li>在控制 modal 显示变量为 true 之后，直到 updated 阶段才更新 DOM</li><li>watch 当中有关 DOM 的操作，要利用 nextTick 延迟到 DOM 渲染之后执行</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0.1+0.2!==0.3</title>
      <link href="/2020/03/23/0.1+0.2!==0.3/"/>
      <url>/2020/03/23/0.1+0.2!==0.3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>axios</title>
      <link href="/2020/03/23/axios/"/>
      <url>/2020/03/23/axios/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Iterator和for...of循环</title>
      <link href="/2020/03/22/17-Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/"/>
      <url>/2020/03/22/17-Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Iterator-和-for…of-循环"><a href="#Iterator-和-for…of-循环" class="headerlink" title="Iterator 和 for…of 循环"></a>Iterator 和 for…of 循环</h1><h2 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h2><ul><li><p>JS 原来表示”集合”的是数组 <code>Array</code> 和对象 <code>Object</code>，ES6 添加了 <code>Map</code> 和 <code>Set</code></p></li><li><p>Iterator 是一种接口，任何数据结构只要部署 Iterator 接口，就可以完成便利操作（即依次处理该数据结构的所有成员）</p></li><li><p>Iterator 作用：</p><ul><li>为各种数据结构提供统一的、简便的访问接口</li><li>使数据结构的成员能够按某种次序排列</li><li>ES6 创造了新的遍历命令 <code>for...of</code> </li></ul></li><li><p>遍历过程</p><ul><li><p>创建指针对象，指向当前数据结构的起始位置</p><ul><li><p>遍历对象本质上是一个指针对象</p></li><li><blockquote><p>js 有指针的概念？</p></blockquote></li></ul></li><li><p>第一次调用指针对象的 <code>next</code> 方法，可以将指针指向数据结构的第一个成员</p></li><li><p>不断调用指针对象的 <code>next</code> 方法，直到它指向数据结构的结束位置</p></li></ul></li><li><p>每次调用 <code>next</code> 返回一个包含 <code>value</code> he <code>done</code> 两个属性的对象。</p><ul><li><code>value</code> 属性是当前成员的值</li><li><code>done</code> 属性是一个布尔值，表示遍历是否结束</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line">it.next();</span><br><span class="line">it.next();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; : &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h2><ul><li>当使用 <code>for...of</code> 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口</li><li>ES6 规定，默认的 Iterator 接口部署在数据结构的 <code>Symbol.iterator</code> 属性，或者说，一个数据结构只要有 <code>Symbol.iterator</code> 属性，就认为是可遍历的<ul><li><code>Symbol.iterator</code> 属性本身是一个函数，就是当前数据结构默认的遍历器生产函数</li><li>执行这个函数，就会返回一个遍历器</li><li>属性名 <code>Symbol.iterator</code> 是一个表达式，返回 <code>Symbol</code> 对象的 <code>iterator</code> 属性</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: <span class="number">1</span>,</span><br><span class="line">          done: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>原生具备 Iterator 接口的数据结构：<ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul></li></ul><blockquote><p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p></blockquote><h2 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h2><ul><li>数组和 Set 结构进行解构赋值时，默认调用 <code>Symbol.iterator</code> 方法</li><li>扩展运算符 <code>...</code><ul><li>部署了 Iterator 接口的数据结构都能用扩展运算符</li></ul></li><li>yield* 后面跟的是一个可遍历的解构，它会调用该结构的遍历器接口</li><li>数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，都调用了遍历器<ul><li>for … of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()</li><li>Promise.all()</li><li>Promise.race()</li></ul></li></ul><h2 id="Iterator-接口与-Generator-函数"><a href="#Iterator-接口与-Generator-函数" class="headerlink" title="Iterator 接口与 Generator 函数"></a>Iterator 接口与 Generator 函数</h2><ul><li><code>Symbol.iterator</code> 方法的最简单实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "hello"</span></span><br><span class="line"><span class="comment">// "world"</span></span><br></pre></td></tr></table></figure><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><ul><li>数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员</li><li>也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法</li><li><code>for...of</code>循环可以使用的范围<ul><li>数组</li><li>Set </li><li>Map </li><li>某些类似数组的对象<ul><li><code>arguments</code>对象</li><li>DOM NodeList 对象</li></ul></li><li>Generator 对象</li><li>字符串</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set和Map数据结构</title>
      <link href="/2020/03/22/13-Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/03/22/13-Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>类似于数组，但成员的值都是唯一的<ul><li>不会发生类型转换，所以 5 和 “5” 不同</li><li>两个 NaN 是相等的，这和 <code>===</code> 不同</li><li>两个对象总是不想等</li></ul></li><li><code>Set</code> 构造函数可以接受一个数组（或具有 iterable 接口的其他数据结构）作为参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><blockquote><p>Array.from 可以将 Set 结构转为数组</p></blockquote><h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><ul><li><p>属性</p><ul><li><code>Set.prototype.constructor</code> 构造函数</li><li><code>Set.prototype.size</code> 返回 <code>Set</code> 实例的成员总数</li></ul></li><li><p>方法</p><ul><li><p>操作方法</p><ul><li><code>Set.prototype.add(value)</code> 添加某个值，返回 Set 结构本身</li><li><code>Set.prototype.delete(value)</code> 删除某个值，返回布尔表示是否成功</li><li><code>Set.prototype.has(value)</code> 返回布尔值，表示是否为 <code>Set</code> 成员</li><li><code>Set.prototype.clear(value)</code>清空，没有返回值</li></ul></li><li><p>遍历方法</p><ul><li><p><code>Set.prototype.keys()</code> 返回键名，遍历器对象</p></li><li><p><code>Set.prototype.values()</code> 返回键值，遍历器对象</p><blockquote><p>Set 结构没有键名，只有键值（或者说键名键值都是同一个值），所以 keys 方法和 values 方法一样</p></blockquote></li><li><p><code>Set.prototype.entries()</code> 返回键值对，遍历器对象</p></li><li><p><code>Set.prototype.forEach()</code> 使用回调函数遍历每个成员</p></li></ul></li></ul></li></ul><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><ul><li>类似 Set</li><li>成员只能是对象<ul><li>弱引用，垃圾回收机制不考虑 WeakSet 的引用，可能会随时被清空</li></ul></li><li>不可遍历</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>类似于对象，是键值对的集合</li><li>对象的键只能是字符串，Map 的键不限制类型</li><li><code>Map</code> 构造函数可接受数组，数组成员表示一个键值对（任何具有 Iterator 接口，且每个成员都是一个双元素的数组的数据结构，例如 Set 和 Map）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'zhangsan'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 实际上执行</span></span><br><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'zhangsan'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">items.forEach(</span><br><span class="line">([key, value]) =&gt; map.set(key, value)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>多次赋值一个键，会覆盖</li><li>读取一个未知的键，返回 <code>undefined</code></li><li>对于对象，地址相同 Map 结构才视为同一个键</li><li>对于简单类型，值严格相等 <code>===</code> 就是一个键</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">'a'</span>]) <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">// ['a'] 是实例，这里两个实例 ['a'] 内存地址不同</span></span><br></pre></td></tr></table></figure><h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><ul><li>属性<ul><li><code>size</code></li></ul></li><li>方法<ul><li>操作方法<ul><li><code>Map.prototype.set(key, value)</code><ul><li>返回当前 <code>Map</code> 对象，可以采用链式写法</li></ul></li><li><code>Map.prototype.get(key)</code></li><li><code>Map.prototype.has(key)</code></li><li><code>Map.prototype.delete(key)</code></li><li><code>Map.prototype.clear(key)</code></li></ul></li><li>遍历方法<ul><li><code>Map.prototype.keys()</code></li><li><code>Map.prototype.values()</code></li><li><code>Map.prototype.entries()</code></li><li><code>Map.prototype.forEach()</code></li></ul></li></ul></li><li>Map 本身没有 <code>map</code> 和 <code>filter</code> 方法，需要结合数组</li></ul><h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><ul><li><p>Map -&gt; 数组</p><ul><li><code>[...map]</code></li></ul></li><li><p>数组 -&gt; Map</p><ul><li><code>new Map(array)</code></li></ul></li><li><p>Map -&gt; 对象</p></li><li><p>对象 -&gt; Map</p></li><li><p>Map -&gt; JSON</p></li><li><p>JSON -&gt; Map</p></li></ul><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><ul><li>类似 Map</li><li>键名只能对象（除了 null）</li><li>指向的对象不计入垃圾回收机制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Generator函数的语法</title>
      <link href="/2020/03/21/18-Generator%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/03/21/18-Generator%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Generator-函数的语法"><a href="#Generator-函数的语法" class="headerlink" title="Generator 函数的语法"></a>Generator 函数的语法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>异步编程解决方案，语法行为与传统函数完全不同</li><li>理解<ul><li>语法上，Generator 函数是一个状态机，封装了多个内部状态<ul><li>执行 Generator 函数会返回一个遍历器对象<ul><li>遍历器对象可以依次遍历 Generator 函数内部的每一个状态</li></ul></li></ul></li><li>形式上，Generator 函数是一个普通函数<ul><li>两个特征<ul><li><code>function</code> 关键字与函数名之间有一个星号，星号位置和空格位置的先后关系没有规定</li><li>函数体内部使用 <code>yield</code> 表达式，定义不同的内部状态</li></ul></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三个状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line"><span class="comment">// 调用</span></span><br></pre></td></tr></table></figure><ul><li>调用 Generator 函数后，该函数并不执行，返回一个指向内部状态的指针对象（iterator Object）</li><li>调用遍历器对象的 <code>next</code> 方法，使得指针移向下一个状态<ul><li>也就是说，每次调用 <code>next</code> 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 <code>yield</code> 表达式（或 <code>return</code> 语句）</li><li>换言之，Generator 函数是分段执行的，<code>yield</code> 表达式是暂停执行的标记，<code>next</code> 方法恢复执行</li></ul></li><li><code>next</code> 返回一个对象<ul><li>属性 <code>value</code> 是当前 <code>yield</code> 表达式的值</li><li>属性 <code>done</code> 表示遍历是否结束</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h3><ul><li><code>next</code> 方法的运行逻辑<ul><li>遇到 <code>yield</code> 表达式，就暂停执行，并将紧跟在 <code>yield</code> 后面的表达式的值作为对象的 <code>value</code> 属性返回</li><li>下次调用 <code>yield</code> 时，再继续往下执行，直到遇到下一个 <code>yield</code> 表达式</li><li>如果没有遇到新的表达式，就一直运行到 <code>return</code>，并将 <code>return</code> 语句后面的表达式的值作为对象的 <code>value</code> 属性</li><li>如果没有<code>return</code> 语句，则返回对象的 <code>value</code> 属性值为 <code>undefined</code></li></ul></li><li><code>yield</code> 表达式后面的表达式，只有调用 <code>next</code> 方法、内部指针指向该语句时才会执行<ul><li>给 JavaScript 提供了手动<strong>惰性求值</strong>的语法功能</li></ul></li><li>不用 <code>yield</code> 的情况下，Generator 就是一个单纯的暂缓执行函数</li><li><code>yield</code> 只能用在 Generator 函数里面，其它地方会报错</li><li><code>yield</code> 如果用在另一个表达式中，必须放在括号里面</li><li><code>yield</code> 用做函数参数或放在赋值表达式右边，不用括号</li></ul><h2 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h2><blockquote><p>这节没看懂</p></blockquote><ul><li><code>yield</code> 表达式本身没有返回值，或者说总是返回 <code>undefined</code></li><li><code>next</code> 方法可以带一个参数，该参数会被当作上一个 <code>yield</code> 表达式的返回值</li></ul><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><ul><li><code>for...of</code> 循环自动遍历 Generator 函数运行时生成的 <code>Iterator</code> 对象，此时不需要调用 <code>next</code> 方法</li><li>斐波那契</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">yield</span> curr;</span><br><span class="line">    [prev, curr] = [curr, prev + curr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> fibonacci()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h2><ul><li><code>throw</code> 方法可以在函数体外抛出错误，在函数体内捕获<ul><li>前提是必须进行过一次 <code>next</code> 方法</li><li>捕获后会自动执行一次 <code>next</code> 方法，不影响下次遍历</li></ul></li><li>如果 Generator 函数内部没有部署 <code>try...catch</code> 代码块，那么错误会被外部的 <code>try...catch</code> 代码块捕获</li><li>如果都没有，那么程序将报错，直接中断执行</li></ul><h2 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h2><ul><li>返回给定的值，并终结遍历 Generator 函数</li></ul><h2 id="next-、throw-、return-的共同点"><a href="#next-、throw-、return-的共同点" class="headerlink" title="next()、throw()、return() 的共同点"></a>next()、throw()、return() 的共同点</h2><ul><li>作用都是让 Generator 函数恢复执行，使用不同的语句替换 <code>yield</code> 表达式</li><li><code>next()</code> 是将 <code>yield</code> 表达式替换成一个值</li><li><code>throw()</code> 是将 <code>yield</code> 表达式替换成一个 <code>throw</code> 语句</li><li><code>return()</code> 是将 <code>yield</code> 表达式替换成一个 <code>return</code> 语句</li></ul><h2 id="yield-表达式-1"><a href="#yield-表达式-1" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h2><ul><li>在一个 Generator 函数里面执行另一个 Generator 函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "x"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// "y"</span></span><br></pre></td></tr></table></figure><ul><li>从语法角度看，如果<code>yield</code>表达式后面跟的是一个遍历器对象，需要在<code>yield</code>表达式后面加上星号，就会执行这个遍历器</li><li>任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历</li></ul><h2 id="作为对象属性的-Generator-函数"><a href="#作为对象属性的-Generator-函数" class="headerlink" title="作为对象属性的 Generator 函数"></a>作为对象属性的 Generator 函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise对象</title>
      <link href="/2020/03/21/16-Promise%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/21/16-Promise%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><h2 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h2><ul><li>异步编程的一种解决方案，比传统的解决方案更合理和更强大<ul><li>传统的解决方案：回调函数和事件</li></ul></li><li>Promise 简单说就是一个容器，保存着某个未来才会结束的事件（通常是一个异步操作）的结果</li><li>从语法上说，Promise 是一个对象，可以获取异步操作的消息</li><li>特点：<ul><li>对象状态不受外界影响<ul><li>Promise 对象代表一个异步操作，有三种状态<ul><li>pending 进行中</li><li>fulfilled 已成功</li><li>rejected 已失败</li></ul></li><li>只有异步操作的结果才能改变状态</li></ul></li><li>一旦状态改变，就不会再改变，任何时候都可以得到这个结果<ul><li>状态改变只有两种可能<ul><li>pending -&gt; fulfilled</li><li>pending -&gt; rejected</li></ul></li></ul></li></ul></li><li>缺点：<ul><li>无法取消。一旦新建就会立即执行，无法中途取消</li><li>如果不设置回调函数，内部抛出的错误无法反应到外部</li><li>处于 pending 状态的时候，无法得知进度</li><li>如果事件不断地反复发生， Stream 模式是比 Promise 更好的选择</li></ul></li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol><li>创建 Promise 实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 成功 */</span>) &#123;</span><br><span class="line">      resolve(value);<span class="comment">// 将 Promise 对象的状态 pending -&gt; fulfilled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  reject(error);<span class="comment">// 将 Promise 对象的状态 pending -&gt; rejected</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>回调函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>调用 <code>resolve</code> 或 <code>reject</code> 并不会终结 Promise 的参数函数的执行</li><li>立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li>一般来说，<code>resolve</code> 或 <code>reject</code> 之后 Promise 的使命就完成了，后续操作应该放到 <code>then</code> 里<ul><li>所以可以 <code>return resolve()</code> 或 <code>return reject()</code> </li></ul></li></ul><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><ul><li><code>then</code> 方法的返回值是一个<strong>新的</strong> Promise 实例，因此可以采用链式写法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(...)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(...)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>箭头函数写法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(</span><br><span class="line">  post =&gt; getJSON(post.commentURL);</span><br><span class="line">).then(</span><br><span class="line">comments =&gt; <span class="built_in">console</span>.log(...),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><ul><li><code>Promise.prototype.catch()</code> 是 <code>.then(null, rejection)</code> 或 <code>.then(undefined, rejection)</code> 的别名，用于指定发生错误的回调函数<ul><li>一般来说，不要用 <code>then</code> 的第二个参数，直接用 <code>catch</code>，可以捕获第一个参数的执行错误</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch (<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJOSN 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>reject</code> 方法的作用等于抛出错误<ul><li>如果 Promise 状态已经变成 <code>resulved</code> 再抛出错误是无效的</li></ul></li><li>Promise 对象的错误具有”冒泡”性质，会一直向后传递，知道被捕获为止<ul><li>也就是说，错误总是会被下一个 <code>catch</code> 语句捕获</li></ul></li><li>如果没有使用 <code>carch</code> 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码</li><li>Node 有一个 <code>unhandledRejection</code> 事件（计划废除），专门监听未捕获的 <code>reject</code> 错误</li><li><code>catch</code> 返回值也是 Promise 对象，还可以接 <code>then</code> ，也可以抛出错误被下一个 <code>catch</code> 捕获</li></ul><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><ul><li>无论 Promise 最后状态如何，都会执行的操作，不接收参数</li><li>本质上是 <code>then</code> 方法的特例（<code>then</code> 中两种情况代码一样）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">  value =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>finally</code> 方法总是返回原来的值</li></ul><h2 id="Promise-prototype-all"><a href="#Promise-prototype-all" class="headerlink" title="Promise.prototype.all()"></a>Promise.prototype.all()</h2><ul><li>将多个 Promise 实例包装成一个新的 Promise 实例<ul><li>参数可以不是数组，但必须具有 Iterator 接口，且每个成员都是 Promise 实例</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><ul><li>p 的状态由 p1, p2, p3 决定<ul><li>都为 <code>fulfilled</code>，p 为 <code>fulfilled</code><ul><li>返回值组成数组，传递给 p 的回调函数</li></ul></li><li>任一 <code>rejected</code>，p 为 <code>rejected</code><ul><li>第一个被 <code>reject</code> 的实例的返回值，传递给 p 的回调函数</li><li>如果 p1, p2, p3 自己定义了 <code>catch</code>，则会执行 <code>catch</code>，状态变成 <code>catch</code> 返回的 <code>resolve</code></li><li>如果没定义 <code>catch</code> 才会调用 <code>Promise.all()</code> 的 <code>catch</code> 方法</li></ul></li></ul></li></ul><h2 id="Promise-prototype-race"><a href="#Promise-prototype-race" class="headerlink" title="Promise.prototype.race()"></a>Promise.prototype.race()</h2><ul><li>将多个 Promise 实例包装成一个新的 Promise 实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><ul><li>只要 p1, p2, p3 任一改变状态，p 就跟着改变<ul><li>率先改变的 Promise 实例的返回值，传递给 p 的回调函数</li></ul></li></ul><h2 id="Promise-prototype-allSettled"><a href="#Promise-prototype-allSettled" class="headerlink" title="Promise.prototype.allSettled()"></a>Promise.prototype.allSettled()</h2><ul><li>接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</li><li>所有参数实例都返回结果，包装实例才会结束</li><li>返回新的 Promise 实例，状态总是 <code>fulfilled</code></li><li>监听函数接收到的参数是对象数组，每个对象分别对应 <code>allSettled</code> 的参数<ul><li>对象属性 status, value, reason</li></ul></li></ul><h2 id="Promise-prototype-any"><a href="#Promise-prototype-any" class="headerlink" title="Promise.prototype.any()"></a>Promise.prototype.any()</h2><ul><li>接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例<ul><li>任一 <code>fulfilled</code> ，包装实例就 <code>fulfilled</code></li><li>全部 <code>rejectd</code> ，包装实例才 <code>rejectd</code></li></ul></li></ul><h2 id="Promise-prototype-resolve"><a href="#Promise-prototype-resolve" class="headerlink" title="Promise.prototype.resolve()"></a>Promise.prototype.resolve()</h2><ul><li>将现有对象转为 Promise 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><ul><li>参数分 4 种情况<ul><li>Promise 实例<ul><li>不做任何修改</li></ul></li><li><code>thenable</code> 对象（具有 <code>then</code> 方法的对象）<ul><li>转为 Promise 对象，立即执行 <code>then</code></li></ul></li><li>不是 <code>thenable</code> 对象（其它对象或不是对象）<ul><li>返回一个新的 Promise 对象，状态 <code>resolved</code></li></ul></li><li>不带参数<ul><li>直接返回一个 <code>resolved</code> 的Promise 对象</li></ul></li></ul></li><li>立即 <code>resolve</code> 的 Promise 对象，在本轮”事件循环”的结束时执行，不是在下一轮”事件循环”开始时</li></ul><h2 id="Promise-prototype-reject"><a href="#Promise-prototype-reject" class="headerlink" title="Promise.prototype.reject()"></a>Promise.prototype.reject()</h2><ul><li>返回一个新的 Promise 实例，状态为 <code>rejected</code></li><li>参数会原封不动作为 <code>reject</code> 理由，和 <code>resolve</code> 处理不同</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>加载图片</li><li>Generator 函数与 Promise 结合</li></ul><h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><ul><li>同步函数同步执行，异步函数异步执行</li><li>模拟 <code>try</code> 代码块</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symbol</title>
      <link href="/2020/03/18/12-Symbol/"/>
      <url>/2020/03/18/12-Symbol/</url>
      
        <content type="html"><![CDATA[<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>ES5 的对象属性名都是字符串，容易造成属性名冲突</li><li>原始数据类型 <code>Symbol</code> 表示独一无二的值</li><li>通过 <code>Symbol</code> 函数生成<ul><li>不能使用 <code>new</code> 命令</li><li>可以接受参数，作为变量的描述，用来区分<ul><li>如果参数是对象，先调用该对象的 <code>toString</code> 方法</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">typeof</span> s<span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure><ul><li><p>现在，对象的属性名可以有两种类型</p><ul><li>字符串</li><li>Symbol 类型</li></ul></li><li><p>Symbol 值不能与其他类型的值进行运算，会报错</p></li><li><p>可以转为字符串和布尔值(true)，但不能转为数值</p></li></ul><h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><ul><li>创建 Symbol 的时候，可以添加一个描述</li><li>读取描述需要将 Symbol 显式转为字符串</li><li>ES2019 提供  <code>description</code> 属性，返回 Symbol 描述</li></ul><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure><ul><li>Symbol 值作为对象属性名时，不能用点运算符，因为点运算符后面总是字符串<ul><li><strong>要放在方括号中定义</strong></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line">a.mySymbol = <span class="string">'Hello'</span>;</span><br><span class="line">a[mySymbol]<span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">'mySymbol'</span>] <span class="comment">// 'Hello'</span></span><br></pre></td></tr></table></figure><ul><li>Symbol 值作为属性名时，该属性是公开属性，不是私有属性</li></ul><h2 id="实例：消除魔术字符串"><a href="#实例：消除魔术字符串" class="headerlink" title="实例：消除魔术字符串"></a>实例：消除魔术字符串</h2><blockquote><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p></blockquote><ul><li>等于哪个值并不重要，只要确保不会跟其他属性的值冲突即可，就很适合改用 Symbol 值</li></ul><h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><ul><li><p>Symbol 作为属性名，遍历对象的时候不会出现在<code>for...in</code>、<code>for...of</code>循环中</p><ul><li>可以利用这个特性，为对象定义非私有、只希望内部使用的方法</li></ul></li><li><p>不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 返回</p></li><li><p><code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名</p><ul><li>该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值</li></ul></li><li><p><code>Reflect.ownKeys(object)</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名</p></li></ul><h2 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h2><ul><li><code>Symbol.for(&#39;string&#39;)</code> 检查是否有以 <code>string</code> 作为名称的 Symbol 值，有则返回，没有则新建，并注册到全局</li><li><code>Symbol()</code>写法没有登记机制</li><li><code>Symbol.keyFor(变量名)</code>方法返回一个已登记的 Symbol 类型值的<code>key</code></li></ul><h2 id="实例：模块的-Singleton-模式"><a href="#实例：模块的-Singleton-模式" class="headerlink" title="实例：模块的 Singleton 模式"></a>实例：模块的 Singleton 模式</h2><ul><li>Singleton 模式（单例模式）指的是调用一个类，任何时候返回到都是同一个实例</li></ul><h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><ul><li>Symbol.hasInstance<ul><li>指向一个内部方法</li><li>当其他对象使用<code>instanceof</code>运算符，会调用这个方法</li><li>比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code></li></ul></li><li>Symbol.isConcatSpreadable<ul><li>等于一个布尔值</li><li>表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开</li></ul></li><li>Symbol.species<ul><li>指向一个构造函数，创建衍生对象时使用该属性</li></ul></li><li>Symbol.match<ul><li>指向一个函数</li><li>如果该属性存在，调用它并返回方法的返回值</li></ul></li><li>Symbol.replace<ul><li>指向一个方法</li><li>当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值</li></ul></li><li>Symbol.search<ul><li>指向一个方法</li><li>当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值</li></ul></li><li>Symbol.split<ul><li>指向一个方法</li><li>当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值</li></ul></li><li>Symbol.iterator</li><li>Symbol.toPrimitive</li><li>Symbol.toStringTag</li><li>SYmbol.unscopables</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的扩展</title>
      <link href="/2020/03/18/8-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
      <url>/2020/03/18/8-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>（<span class="title">x</span> = 0, <span class="title">y</span> = 0) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数默认值是惰性求值，每次重新计算</li></ul><h3 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h3><h3 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h3><ul><li>返回没有指定默认值的参数个数</li></ul><h2 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h2><ul><li><code>...变量名</code> 不需要使用 <code>arguments</code> 对象</li><li><code>arguments</code> 是类数组</li><li><code>rest</code> 是真的数组</li></ul><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><ul><li>返回函数名</li></ul><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>函数体内的 <code>this</code> 对象，是定义时所在的对象，而不是使用时所在的对象<ul><li>箭头函数没有自己的 <code>this</code> ，引用外层的 <code>this</code></li></ul></li><li>不可以当作构造函数，不可以使用 <code>new</code> 命令</li><li>不可以使用 <code>arguments</code> 对象，可以用 <code>rest</code> 参数</li><li>不可以使用 <code>yield</code> 命令，因此不能用做 Generator 函数</li></ul><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><h3 id="什么是尾调用"><a href="#什么是尾调用" class="headerlink" title="什么是尾调用"></a>什么是尾调用</h3><ul><li>某个函数的最后一步是调用另一个函数</li></ul><h3 id="尾调用优化-1"><a href="#尾调用优化-1" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><blockquote><p>函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p></blockquote><ul><li>只有 Safari 支持</li></ul><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><ul><li>尾调用自身，就称为尾递归。</li></ul><blockquote><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p></blockquote><ul><li>斐波那契</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span> (<span class="params">n, ac1 = <span class="number">1</span>, ac2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> ac2;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci2 (n<span class="number">-1</span>, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存</li></ul><h3 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h3><ul><li>把所有用到的内部变量改写成函数的参数</li></ul><blockquote><p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。</p></blockquote><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ul><li>ES6 的尾调用优化只在严格模式下开启</li></ul><h2 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h2><ul><li>ES6 中函数最后一个参数后有逗号不会报错</li></ul><h2 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h2><ul><li><code>toString()</code>方法返回函数代码本身，以前会省略注释和空格</li></ul><h2 id="catch-命令的参数省略"><a href="#catch-命令的参数省略" class="headerlink" title="catch 命令的参数省略"></a>catch 命令的参数省略</h2><ul><li>以前 catch 命令后面必须跟参数，ES6 可以省略</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串的扩展</title>
      <link href="/2020/03/17/4-5-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/03/17/4-5-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h2 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h2><ul><li>ES6 加强了对 Unicode 的支持，允许采用 <code>\uxxxx</code> 形式表示一个字符，<code>xxxx</code> 表示字符的 Unicode 码点</li><li>限制码点在 <code>\u0000</code> ~ <code>\uFFFF</code> 之间的字符，超出范围必须用两个双字节的形式表示</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line"><span class="comment">// " 7"</span></span><br><span class="line"><span class="comment">// JavaScript 会理解成 \u20BB+7</span></span><br><span class="line"><span class="comment">// \u20BB 不可打印，输出空格</span></span><br></pre></td></tr></table></figure><ul><li>只要将码点放入大括号，就能正确解读</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure><blockquote><p>对编码仍然是一窍不通……</p></blockquote><h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><ul><li>ES6 对字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 <code>for...of</code> 循环便利</li><li>除了遍历字符串，遍历器最大的优点是可以识别大于 <code>0xFFFF</code> 的码点</li></ul><h2 id="直接输入-U-2028-和-U-2029"><a href="#直接输入-U-2028-和-U-2029" class="headerlink" title="直接输入 U+2028 和 U+2029"></a>直接输入 U+2028 和 U+2029</h2><ul><li>JavaScript 字符串允许直接输入字符，以及输入字符的转义形式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'中'</span> === <span class="string">'\u4e2d'</span></span><br></pre></td></tr></table></figure><ul><li>规定不能在字符串里直接使用，只能用转义形式<ul><li>U+005C：反斜杠</li><li>U+000D：回车</li><li>U+2028：行分隔符</li><li>U+2029：段分隔符</li><li>U+000A：换行符</li></ul></li><li>JSON 允许使用 U+2028、U+2029<ul><li><code>JSON.parse()</code> 解析这两个会报错</li><li>为了兼容 JSON，ES2019 支持直接输入这两个</li></ul></li></ul><h2 id="JSON-stringify-的改造"><a href="#JSON-stringify-的改造" class="headerlink" title="JSON.stringify() 的改造"></a>JSON.stringify() 的改造</h2><ul><li>根据标准，JSON 数据必须是 UTF-8 编码，但是现在的 <code>JSON.stringify()</code> 有可能返回不符合 UTF-8 标准的字符串</li></ul><blockquote><p>UTF-8 标准规定，<code>0xD800</code> 到 <code>0xDFFF</code> 之间的码点必须配对使用</p></blockquote><ul><li><code>JSON.stringify()</code> 可能返回 <code>0xD800</code> 到 <code>0xDFFF</code> 之间的单个码点</li><li>为了确保返回的是合法的 UTF-8 字符，如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理</li></ul><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><ul><li>增强版的字符串，用反引号（`）标识</li><li>可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入 <code>${变量}</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure><ul><li>反引号需要反斜杠转义</li><li>保留空格和缩进，可以用 <code>trim()</code> 方法消除</li><li>如果变量的值不是字符串，将按照一般的规则转为字符串<ul><li>比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法</li></ul></li></ul><h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><ul><li>模版字符串跟在一个函数名后面，该函数将被调用来处理这个模版字符串</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`hello`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert([<span class="string">'hello'</span>])</span><br></pre></td></tr></table></figure><ul><li>标签模版其实不是模版，而是函数调用的一种特殊形式<ul><li>“标签” 指的是函数，跟在后面的模版字符串是参数</li></ul></li><li>如果有参数，函数会依次受到多个参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123;a + b&#125;</span> world <span class="subst">$&#123;a + b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><ul><li>作用<ul><li>过滤 HTML 字符串，防止用户输入恶意内容</li><li>多语言转换</li><li>嵌入其他语言</li></ul></li><li>模版处理函数的第一个参数（模版字符串数组），还有一个 <code>raw</code> 属性，保存的是<strong>转义</strong>后的原字符串</li></ul><h2 id="模板字符串的限制"><a href="#模板字符串的限制" class="headerlink" title="模板字符串的限制"></a>模板字符串的限制</h2><ul><li>标签模板可以内嵌别的语言，默认将字符串转义，导致报错</li><li>ES2018 放松了对<u>标签模版</u>里面字符串转义的限制<ul><li>遇到不合法的字符串转义，返回 <code>undefined</code></li><li><code>raw</code> 属性上仍可以得到原始字符串</li></ul></li><li>不是标签模版仍然会报错</li></ul><h1 id="字符串的新增方法"><a href="#字符串的新增方法" class="headerlink" title="字符串的新增方法"></a>字符串的新增方法</h1><h2 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h2><ul><li>ES5 提供 <code>String.fromCharCode()</code> 方法从 Unicode 码点返回对应字符，不能识别大于 <code>0xFFFF</code> 的字符</li><li>ES6 提供 <code>String.fromCodePoint()</code> 可识别大于 <code>0xFFFF</code> 的字符<ul><li>多个参数会被合并成一个字符串返回</li></ul></li><li><code>fromCodePoint</code> 方法定义在 <code>String</code> 对象上</li><li><code>codePointAt</code> 方法定义在字符串的实例对象上</li></ul><h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h2><ul><li><p>替换所有变量，并对斜杠进行转义</p></li><li><p>实现</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw = <span class="function"><span class="keyword">function</span> (<span class="params">strings, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> output = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += strings.raw[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  output += strings.raw[index]</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例方法：codePointAt"><a href="#实例方法：codePointAt" class="headerlink" title="实例方法：codePointAt()"></a>实例方法：codePointAt()</h2><ul><li>JavaScript 内部，字符以 UTF-16 的格式存储，每个字符固定 2 字节</li><li>大于 <code>0xFFFF</code> 的字符需要 4 个字节存储，JavaScript 会认为它们是两个字符，字符串长度为 2</li><li>ES5 <code>charCodeAt()</code> 只能 2 个字节 2 个字节处理</li><li>ES6 <code>codePointAt()</code> 能够正确处理 4 个字节</li><li><code>codePointAt()</code> 返回的码点是十进制的，toString(16) 转为十六进制</li></ul><h2 id="实例方法：normalize"><a href="#实例方法：normalize" class="headerlink" title="实例方法：normalize()"></a>实例方法：normalize()</h2><ul><li>合成符号</li></ul><h2 id="实例方法：includes-startsWith-endsWith"><a href="#实例方法：includes-startsWith-endsWith" class="headerlink" title="实例方法：includes(), startsWith(), endsWith()"></a>实例方法：includes(), startsWith(), endsWith()</h2><ul><li>ES5 <code>indexOf</code> 可以确定一个字符串是否包含在另一个字符串中</li><li>ES6<ul><li><code>includes(&#39;subString&#39;, n)</code> 返回布尔值，表示是否找到了参数字符串</li><li><code>startsWith(&#39;subString&#39;, n)</code> 返回布尔值，表示参数字符串是否在原字符串的头部</li><li><code>endsWith(&#39;subString&#39;, n)</code> 返回布尔值，表示参数字符串是否在原字符串的尾部</li></ul></li></ul><h2 id="实例方法：repeat-n"><a href="#实例方法：repeat-n" class="headerlink" title="实例方法：repeat(n)"></a>实例方法：repeat(n)</h2><ul><li>返回一个新字符串，重复 n 次</li><li>小数取整，负数/Infinity 报错</li></ul><h2 id="实例方法：padStart-n-‘string’-padEnd-n-‘string’"><a href="#实例方法：padStart-n-‘string’-padEnd-n-‘string’" class="headerlink" title="实例方法：padStart(n, ‘string’), padEnd(n, ‘string’)"></a>实例方法：padStart(n, ‘string’), padEnd(n, ‘string’)</h2><ul><li>补全长度<ul><li>长度 n</li><li>用来补全的字符串 string</li></ul></li></ul><h2 id="实例方法：trimStart-trimEnd"><a href="#实例方法：trimStart-trimEnd" class="headerlink" title="实例方法：trimStart(), trimEnd()"></a>实例方法：trimStart(), trimEnd()</h2><ul><li>消除空格</li><li>不修改原始字符</li></ul><h2 id="实例方法：matchAll"><a href="#实例方法：matchAll" class="headerlink" title="实例方法：matchAll()"></a>实例方法：matchAll()</h2><ul><li><code>matchAll()</code>返回一个正则表达式在当前字符串的所有匹配</li><li>详见 6-正则的扩展</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量的解构赋值</title>
      <link href="/2020/03/15/3-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
      <url>/2020/03/15/3-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><ul><li>ES6 允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，被称为解构</li></ul><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><ul><li>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 嵌套的例子</span></span><br><span class="line"><span class="keyword">let</span> [head, ...detail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// head = 1, detail = [2, 3, 4]</span></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line"><span class="comment">// x = 'a', y = undefined, z = []</span></span><br></pre></td></tr></table></figure><ul><li>如果解构不成功，变量的值就等于 <code>undefined</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><ul><li>不完全解构，只匹配一部分</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// x = 1, y = 2</span></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line"><span class="comment">// a = 1, b = 2, d = 4</span></span><br></pre></td></tr></table></figure><ul><li>如果等号右边不是数组（严格的说，不是可遍历的结构，参见第 17 章 - Iterator），会报错</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转为对象后不具备 Iterator 接口</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 本身不具备 Iterator 接口</span></span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值</li></ul><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><ul><li>解构赋值允许指定默认值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line"><span class="comment">// foo = true</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>];</span><br><span class="line"><span class="comment">// x = 'a', y = 'b'</span></span><br></pre></td></tr></table></figure><ul><li>ES6 内部使用严格相等运算符判断一个位置是否有值，只有当一个数组成员严格等于 <code>undefined</code> 默认值才会生效</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line"><span class="comment">// x = 1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line"><span class="comment">// x = null</span></span><br></pre></td></tr></table></figure><ul><li>如果默认值是一个表达式，则是惰性求值，也就是只有在用到的时候才会求值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">// x = 1, 函数 f 不会执行</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1] 是只含元素 1 的数组</span></span><br><span class="line"><span class="comment">// [1][0] 表示取该数组第一位，也就是元素 1</span></span><br><span class="line"><span class="comment">// let array = [1];</span></span><br><span class="line"><span class="comment">// let x = array[0];</span></span><br></pre></td></tr></table></figure><ul><li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];</span><br><span class="line"><span class="comment">// x = 1, y = 1</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">// foo = 'aaa', bar = 'bbb'</span></span><br></pre></td></tr></table></figure><ul><li>数组的元素是按次序排列的，变量的取值由位置决定</li><li>对象的属性没有次序，变量必须与属性同名才能赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">// baz = undefined</span></span><br></pre></td></tr></table></figure><ul><li>对象的解构赋值可以很方便的将现有对象的方法赋值到某个变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line">log(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><ul><li>如果变量名与属性名不一致，写法如下</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;;</span><br><span class="line"><span class="comment">// baz = 'aaa'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, last = <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj</span><br><span class="line"><span class="comment">// f = 'hello', l = 'world'</span></span><br></pre></td></tr></table></figure><blockquote><p>说明对象的解构赋值是下面形式的简写（参见第 10 章 - 对象的扩展）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br></pre></td></tr></table></figure><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋值给对应变量</p><p>真正被赋值的是后者，而不是前者</p><p>前者是匹配的模式，后者才是变量</p></blockquote><ul><li>嵌套</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line"><span class="comment">// line = 1</span></span><br><span class="line"><span class="comment">// start = Object &#123;line: 1, column: 5&#125;</span></span><br><span class="line"><span class="comment">// loc = Object &#123; start: Object &#125;</span></span><br></pre></td></tr></table></figure><ul><li>对象的解构赋值可以取到继承的属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line"><span class="comment">// foo = 'bar'</span></span><br></pre></td></tr></table></figure><h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><ul><li>生效条件是对象的属性值严格等于 <code>undefined</code></li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>如果要将一个已经声明的变量用于解构赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// js 引擎会将 &#123;x&#125; 理解为一个代码块，从而发生语法错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">// 放在圆括号里即可正确执行</span></span><br></pre></td></tr></table></figure><ul><li>解构赋值允许等号左边的模式中不放任何变量名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><ul><li>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span>: first, [arr.length = <span class="number">1</span>]: last&#125; = arr;</span><br><span class="line"><span class="comment">// first = 1, last = 3</span></span><br></pre></td></tr></table></figure><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><ul><li>字符串在解构赋值时被转换成一个类似数组的对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// a = 'h', b = 'e', C = 'c', d = 'l', e = 'o'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">length</span>: len &#125; = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// len = 5</span></span><br></pre></td></tr></table></figure><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><ul><li>数值和布尔值在解构赋值时被转为对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toString</span>: s &#125; = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// s === Number.prototype.toString =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toString</span>: s &#125; = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// s === Boolean.prototype.toString =&gt; true</span></span><br></pre></td></tr></table></figure><ul><li>数组和布尔值的包装对象都有 <code>toString</code> 属性，因此变量 <code>s</code> 都能取到值</li><li>解构赋值的规则：只要等号右边的值不是对象或数组，就先将其转为对象</li><li>由于 <code>undefined</code> 和 <code>null</code> 无法转为对象，所以它们无法进行解构赋值，会报错</li></ul><p>##函数参数的解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [3, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);</span><br><span class="line"><span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;&#125;);</span><br><span class="line"><span class="comment">// [0, 0]</span></span><br><span class="line">move();</span><br><span class="line"><span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><ul><li>对于编译器来说，一个式子到底是模式还是表达式，只有在解析到（或解析不到）等号才能知道</li><li>如果模式中出现圆括号怎么处理？<ul><li>只要有可能导致解构的歧义，就不得使用圆括号</li><li>尽量不要在模式中放置圆括号</li></ul></li></ul><h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><ul><li>变量声明语句</li><li>函数参数</li><li>赋值语句的模式</li></ul><h3 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h3><ul><li>赋值语句的非模式部分</li></ul><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li>交换变量的值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><ul><li><p>从函数返回多个值</p></li><li><p>函数参数的定义</p></li><li><p>提取 JSON 数据</p></li><li><p>函数参数的默认值</p></li><li><p>遍历 Map 解构</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">con s t map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">' is '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输入模块的指定方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapCounsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>let 和 const 命令</title>
      <link href="/2020/03/15/2-let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/03/15/2-let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h1><h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>let 声明的变量值在 let 命令坐在的代码块内有效</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// var 声明的 i 在全局有效，最终所有的 i 都指向同一个 i，也就是最后一轮循环时 i 的值</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><ul><li>for 循环变量是一个父作用域，循环体是一个子作用域</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><ul><li><code>var</code> 声明会出现”变量提升”现象，即变量可以在声明之前使用，值为 <code>undefined</code></li><li><code>let</code> 改变了语法行为，声明之前使用会报错</li></ul><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><ul><li>块级作用域内存在 <code>let</code> 或 <code>const</code> 命令，它所声明的变量就”绑定(binding)”这个区域，不受外部影响</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>;<span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>暂时性死区的本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</li></ul><h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><ul><li><code>let</code> 不允许在相同作用域内重复声明同一个变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h3><p>ES5 只有全局作用域和函数作用域，可能会导致：</p><ol><li>内层变量可能会覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ol><h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><ul><li>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</li><li>ES6 明确允许在块级作用域之中声明函数，且函数声明语句的行为类似于 let，在块级作用域外不可引用</li><li>但为了兼容，浏览器在实现时，函数声明的行为可以类似于 var，即会提升到全局作用域或函数作用域的头部</li></ul><h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li><code>const</code> 声明一个只读的常量，一旦声明，常量的值就不能改变</li><li>由于不能改变，声明时就必须初始化，否则报错</li></ul><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><ul><li><code>csont</code> 实际上保证的是变量指向的那个内存地址所保存的数据不得改动<ul><li>对于简单类型（数值、字符串、布尔值）的数据，变量指向的地址保存值，等同于常量</li><li>对于符合类型（对象、数组）的数据，变量指向的地址保存指针，指针再指向实际数据，这里只能保证指针不变，但不能保证实际数据不变<ul><li>如果想将对象冻结，可以使用 <code>Object.freeze()</code> 方法</li></ul></li></ul></li></ul><h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><ul><li>ES5<ul><li>var</li><li>function</li></ul></li></ul><hr><ul><li>ES6 新增<ul><li>let</li><li>const</li><li>import</li><li>class</li></ul></li></ul><h2 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h2><ul><li>顶层对象<ul><li>浏览器：window</li><li>Node：global</li></ul></li><li>ES5 之中，顶层对象的属性和全局变量等价</li><li>ES6 规定<ul><li>var、function 声明的全局变量，依旧是顶层对象的属性</li><li>let、const、class 声明的全局变量，不属于顶层对象的属性</li></ul></li></ul><h2 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h2><ul><li>顶层对象提供全局环境（即全局作用域）</li><li>各个实现不一致<ul><li>浏览器：<code>window</code></li><li>浏览器和 Web Worker：<code>self</code></li><li>Node：<code>global</code></li></ul></li><li>为了兼容，一般使用 <code>this</code> ，但有限制<ul><li>全局环境中，<code>this</code> 会返回顶层对象。但 Node 模块和 ES6 模块中，<code>this</code> 返回当前模块</li><li>函数里面的 <code>this</code>，如果函数不是作为对象的方法运行，<code>this</code> 指向顶层对象。严格模式下 <code>undefined</code></li><li><code>new Function(&#39;return this&#39;)()</code> 返回全局对象。如果浏览器用了 CSP（内容安全策略），则该方法无法使用</li></ul></li><li>ES2020 引入 <code>globalThis</code> 作为顶层对象，指向全局环境下的 <code>this</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二十二章 高级技巧</title>
      <link href="/2020/03/14/%E7%AC%AC22%E7%AB%A0-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/03/14/%E7%AC%AC22%E7%AB%A0-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="第二十二章-高级技巧"><a href="#第二十二章-高级技巧" class="headerlink" title="第二十二章 高级技巧"></a>第二十二章 高级技巧</h1><h2 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h2><h3 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h3><p><code>Object.toString()</code> 方法返回一个 <code>[object NativeConstructorName]</code> 格式的字符串。每个类内部都有一个 <code>[[Class]]</code> 属性，指定了上述字符串中的构造函数名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(value);</span><br><span class="line"><span class="comment">// "[object Array]"</span></span><br></pre></td></tr></table></figure><p>开发人员定义的构造函数返回 <code>object Object</code>。</p><h3 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h3><ul><li><p>当 new 调用构造函数时，构造函数内用到的 this 对象会指向新创建的对象实例。</p></li><li><p>如果不用 new，this 会映射到全局对象 widow 上，导致属性被添加到全局。</p></li><li><p>解决：构造函数内部检查 this 对象是否正确</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(name, age, job);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h3><p>函数执行的分支只执行一次</p><ul><li>函数被调用时处理<ul><li>第一次调用时用合适函数覆盖原来的函数<ul><li>例如检查浏览器是否支持某功能，执行一次就行</li></ul></li><li>在声明时就指定适当函数<ul><li>加载时损失性能，执行时不会</li></ul></li></ul></li></ul><h3 id="函数绑定-bind"><a href="#函数绑定-bind" class="headerlink" title="函数绑定 bind()"></a>函数绑定 bind()</h3><p>创建一个函数，可以在特定的 this 环境中以指定参数调用另一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  message: <span class="string">"Event handled"</span>,</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"my-btn"</span>);</span><br><span class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, handler.handleClick);</span><br><span class="line"><span class="comment">// 由于没有保存 handler.handleClick() 的执行环境</span></span><br><span class="line"><span class="comment">// this 指向 DOM 按钮而非 handler</span></span><br><span class="line"><span class="comment">// 本来应该显示 “Event handled”，会显示 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用闭包解决：</span></span><br><span class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  handler.handleClick(event);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind() 可以将函数绑定到指定环境的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, bind(handler,handleClick, handler));</span><br></pre></td></tr></table></figure><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><ul><li>用于创建已经设置好了一个或多个参数的函数</li><li>基本方法和函数绑定一样：使用一个闭包返回一个函数</li><li>区别在于：函数被调用时，返回的函数还需要设置一些传入的参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.all(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context, finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="防篡改对象"><a href="#防篡改对象" class="headerlink" title="防篡改对象"></a>防篡改对象</h2><p>一旦把对象定义为防篡改，就无法撤销了</p><ul><li><code>Object.preventExtensions()</code> 不可扩展对象<ul><li>无法添加新属性和方法</li><li>已有成员可以修改/删除</li></ul></li><li><code>Object.seal()</code> 密封对象<ul><li>不可扩展</li><li>不能删除</li><li>可以修改</li></ul></li><li><code>Object.freeze()</code> 冻结对象<ul><li>不可扩展</li><li>密封</li><li><code>[[Writable]]</code> 设置为 false，若定义 <code>[[Set]]</code> 属性可写</li></ul></li></ul><h2 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h2><ul><li><p>定时器不是线程</p></li><li><p>Javascript 运行于单线程环境中</p></li><li><p>定时器是计划代码在未来的某个时间执行，执行时机不能保证</p></li><li><p>因为在页面的生命周期中，不同时间可能有其他代码在控制 Javascript 进程</p></li><li><p>在页面下载完后的代码运行、事件处理程序、Ajax 回调函数都必须使用同样的线程来执行</p></li><li><p>浏览器负责进行排序，指派某段代码在某个时间点运行的优先级</p></li><li><p>除了主 JavaScript 执行进程外，还有一个需要在进程下一次空闲时执行的代码队列</p></li><li><p>没有任何代码是立即执行的，但一旦进程空闲则尽快执行</p></li><li><p>定时器时间过去时，将代码插入队列末尾</p><ul><li>若队列不空，则仍需等待</li><li>若主 JavaScript 执行进程正在执行，也仍需等待</li></ul></li></ul><h3 id="重复的定时器"><a href="#重复的定时器" class="headerlink" title="重复的定时器"></a>重复的定时器</h3><p>当使用 <code>setInterval()</code> 仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中</p><ul><li>某些间隔会被跳过</li><li>多个定时器的代码执行之间的间隔可能会比预期小</li></ul><p>解决：链式 <code>setTimeout()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">  setTimeout(<span class="built_in">arguments</span>.callee, interval);</span><br><span class="line">&#125;, interval);</span><br></pre></td></tr></table></figure><h3 id="Yielding-Processes"><a href="#Yielding-Processes" class="headerlink" title="Yielding Processes"></a>Yielding Processes</h3><p>如果代码运行超过特定的时间或者特定语句数量就不会让它继续执行</p><p>展开循环前，思考：</p><ul><li>该处理是否必须同步完成？</li><li>数据是否必须按顺序完成？</li></ul><p>如果答案都为否，可以使用<strong>数组分块</strong>技术</p><ul><li>为要处理的项目创建一个队列，使用定时器取出下一个要处理的项目，再设置另一个定时器</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params">array, process, context</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> item = array.shift();</span><br><span class="line">    process.call(context, item);</span><br><span class="line">    <span class="keyword">if</span> (array.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流 throttle"></a>函数节流 throttle</h3><ul><li><p>DOM 操作比非 DOM 交互需要更多的内存和 CPU 时间</p></li><li><p>连续尝试进行过多的 DOM 相关操作可能会导致浏览器挂起，甚至崩溃。例如 onresize 调整浏览器大小</p></li><li><p>防止连续触发，使用定时器进行<strong>节流</strong></p></li><li><p>基本思想</p><ul><li>某些代码不可以在没有间断的情况连续重复执行</li><li>第一次调用函数时，创建一个定时器，在指定的时间间隔之后运行代码</li><li>第二次调用函数时，清除前一次的定时器，并设置另一个<ul><li>如果前一次的定时器已经执行，这个操作无意义</li><li>如果前一次的定时器还未执行，就是替换新定时器</li></ul></li><li>目的是只有在执行函数的请求停止了一段时间之后才执行</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> processor = &#123;</span><br><span class="line">  timeoutId: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 实际进行处理的方法</span></span><br><span class="line">  performPorcessing: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 初始处理调用的方法</span></span><br><span class="line">  process: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.timeoutId);</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      that.performProcessing();</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 尝试开始执行</span></span><br><span class="line">processor.process();</span><br></pre></td></tr></table></figure><p>简化的 <code>throttle()</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, context</span>) </span>&#123;</span><br><span class="line">  clearTimeout(method.tId);</span><br><span class="line">  method.tId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    method.call(context);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><ul><li><p>事件是 Javascript 与浏览器交互的主要途径</p></li><li><p>事件是观察者模式，一种创建松散耦合代码的技术</p></li><li><p>观察者模式有两类对象组成</p><ul><li>主体<ul><li>发布事件</li><li>不知道观察者的存在，独立运行</li></ul></li><li>观察者<ul><li>通过订阅事件来观察主体</li><li>知道主体并能注册事件的回调函数（事件处理程序）</li></ul></li></ul></li></ul><h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><ul><li>创建一个绝对定位的元素，使其可以用鼠标移动</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二十三章 离线应用与客户端存储</title>
      <link href="/2020/03/14/%E7%AC%AC23%E7%AB%A0-%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
      <url>/2020/03/14/%E7%AC%AC23%E7%AB%A0-%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="第二十三章-离线应用与客户端存储"><a href="#第二十三章-离线应用与客户端存储" class="headerlink" title="第二十三章 离线应用与客户端存储"></a>第二十三章 离线应用与客户端存储</h1><p>离线 Web 应用：设备不能上网的情况下仍然可以运行的应用</p><h2 id="离线检测"><a href="#离线检测" class="headerlink" title="离线检测"></a>离线检测</h2><ul><li><code>navigator.onLine</code> 属性</li></ul><ul><li>应用缓存</li></ul><h2 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h2><ul><li>appache 从浏览器的缓存中分出一块缓存区<ul><li>使用一个<strong>描述文件(manifest file)</strong>，列出要下载和缓存的资源</li><li>将描述文件与页面关联起来，可以在 <code>html</code> 中的 <code>manifest</code> 属性指定文件路径</li></ul></li><li>applicationCache 对象</li></ul><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h3><ul><li>要求服务器对任意 HTTP 请求发送 Set-Cookie HTTP 作为响应的一部分，其中包含会话信息</li></ul><blockquote><p>如：</p><p>HTTP/1.1 200 OK</p><p>Content-type: text / html</p><p>Set-Cookie: name = value</p><p>Other-header: other-header-value</p></blockquote><ul><li><p>限制</p><ul><li>Cookie 在性质上是绑定在特定的域名下的</li><li>当设定了一个 cookie 后，再给创建它的域名发送请求时，都会包含这个 cookie</li><li>确保 cookie 中的信息只能让批准的接受者访问，而无法被其他域访问</li></ul></li><li><p>构成</p><ul><li>名称：不区分大小写（实践最好区分），经过 URL 编码</li><li>值：URL 编码</li><li>域：有效域</li><li>路径：对于指定的路径，应该向服务器发送 cookie<ul><li>若指定 <a href="http://www.wrox.com/books/，就不会给" target="_blank" rel="noopener">http://www.wrox.com/books/，就不会给</a> <a href="http://www.wrox.com" target="_blank" rel="noopener">http://www.wrox.com</a> 发送 cookie</li></ul></li><li>失效时间：cookie 何时应该被删除的时间戳</li><li>安全标志：指定后之后 SSL 连接时才发送到服务器</li></ul></li><li><p>JS 中的 cookie</p><ul><li>BOM 的 document.cookie 属性</li></ul></li><li><p>子 cookie</p><ul><li><p>存放在单个 cookie 中的更小段的数据</p></li><li><p>使用 cookie 值来存储多个名称值对</p></li><li><blockquote><p>如 name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5</p></blockquote></li><li><p>查询字符串的格式进行格式化</p></li></ul></li></ul><blockquote><p>所有的 cookie 都会由浏览器作为请求头发送，所以在 cookie 中存储大量信息会影响到特定域的请求性能</p></blockquote><h3 id="Web-存储机制"><a href="#Web-存储机制" class="headerlink" title="Web 存储机制"></a>Web 存储机制</h3><ul><li>Web Storage 的两个主要目标<ul><li>提供一种在 cookie 之外存储会话数据的途径</li><li>提供一种存储大量可以跨会话存在的数据的机制</li></ul></li></ul><h5 id="Storage-类型"><a href="#Storage-类型" class="headerlink" title="Storage 类型"></a>Storage 类型</h5><ul><li>只能存储字符串</li><li>提供最大的存储空间</li><li><code>clear()</code></li><li><code>getItem(name)</code></li><li><code>key(index)</code></li><li><code>removeItem(name)</code></li><li><code>setItem(name, value)</code></li></ul><h5 id="sessionStorage-对象"><a href="#sessionStorage-对象" class="headerlink" title="sessionStorage 对象"></a>sessionStorage 对象</h5><ul><li>Storage 的一个实例</li><li>存储特定于某个会话的数据，只保持到浏览器关闭<ul><li>如果浏览器支持，崩溃重启可以继续使用</li></ul></li><li>可以跨越页面刷新而存在</li><li>存储在 sessionStorage 的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制</li></ul><h5 id="globalStorage-对象"><a href="#globalStorage-对象" class="headerlink" title="globalStorage 对象"></a>globalStorage 对象</h5><ul><li>不是 Storage 实例，globalStorage[“xxx.com”] 才是 Storage 的实例</li><li>跨越会话存储数据，有特定的访问限制</li><li>如果不删除，或者用户未清除浏览器缓存，存储在 globalStorage 属性中的数据会一直保留在磁盘上</li><li>合在客户端存储文档或者长期保存用户偏好设置</li></ul><h5 id="localStorage-对象"><a href="#localStorage-对象" class="headerlink" title="localStorage 对象"></a>localStorage 对象</h5><ul><li>Storage 实例，用法与 sessionStorage 相同</li><li>取代 globalStorage，不用设置规则</li><li>同域名、同协议、同端口</li><li>保留到通过 JavaScript 删除或者是用户清除浏览器缓存</li></ul><h5 id="storage-事件"><a href="#storage-事件" class="headerlink" title="storage 事件"></a>storage 事件</h5><ul><li>修改 Storage 对象会在文档上触发 storage 事件</li></ul><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><ul><li>浏览器中保存结构化数据的一种数据库</li><li>替代被废弃的 Web SQL Database API</li><li>创建一套 API，方便保存和读取 JavaScript 对象，同时还支持查询及搜索</li><li>异步</li><li>做为全局对象 windows.indexedDB，具体名称根据浏览器不同</li></ul><h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><ul><li>用对象保存数据，而不是用表来保存</li><li>一个 IndexedDB 数据库，就是一组位于相同命名空间下的对象的集合</li><li>indexDB.open() 创建/打开</li><li>返回 IDBRequest 对象<ul><li>onerror</li><li>onsuccess</li></ul></li></ul><h5 id="对象存储空间"><a href="#对象存储空间" class="headerlink" title="对象存储空间"></a>对象存储空间</h5><ul><li>可以把这里的对象存储空间(object storge)想象成表，把其中保存的对象想象成表中的记录</li><li><code>add()</code></li><li><code>put()</code></li></ul><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><ul><li>读取或修改数据都要通过事务来组织所有操作</li><li>使用事务可以直接通过已知的键检索单个对象</li></ul><h5 id="使用游标查询"><a href="#使用游标查询" class="headerlink" title="使用游标查询"></a>使用游标查询</h5><ul><li>需要检索多个对象的情况下，需要在事务内 部创建游标</li><li>与传统数据库查询不同<ul><li>游标不提前收集结果</li><li>游标指针会先指向结果中的第一项，在接到查找下一项的指令时指向下一项</li></ul></li></ul><h5 id="键范围"><a href="#键范围" class="headerlink" title="键范围"></a>键范围</h5><h5 id="设定游标方向"><a href="#设定游标方向" class="headerlink" title="设定游标方向"></a>设定游标方向</h5>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二十一章 Ajax与Comet</title>
      <link href="/2020/03/13/%E7%AC%AC21%E7%AB%A0-Ajax%E4%B8%8EComet/"/>
      <url>/2020/03/13/%E7%AC%AC21%E7%AB%A0-Ajax%E4%B8%8EComet/</url>
      
        <content type="html"><![CDATA[<p>AJAX - Asynchronous JavaScript + XML</p><p>向服务器请求额外的数据而无须卸载页面</p><p>核心是 XMLHttpRequest 对象，简称 XHR</p><p>使用 XHR 对象取得新数据，通过 DOM 将新数据插入页面</p><h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure><h3 id="XHR的用法"><a href="#XHR的用法" class="headerlink" title="XHR的用法"></a>XHR的用法</h3><ol><li><code>open(请求类型, URL, 是否异步)</code><ul><li>get / post</li><li>相对于当前页面 / 绝对路径</li><li>Boolean</li></ul></li><li><code>send(请求主体)</code><ul><li>无内容则传入 null</li></ul></li><li>收到响应后，自动填充 XHR 对象的属性<ul><li><code>responseText</code> 做为响应主体</li><li><code>responseXML</code> “text/xml” 或 “application/xml”</li><li><code>status</code> 响应的 HTTP 状态<ul><li>200 成功，responseText 就绪 </li><li>304 资源未修改，可使用缓存</li></ul></li><li><code>statusText</code> HTTP 状态的说明</li><li><code>readyState</code> 异步请求的活动阶段<ul><li>0 位初始化</li><li>1 启动</li><li>2 发送</li><li>3 接收</li><li>4 完成</li><li>值每次改变都触发 <code>readystatechange</code> 事件</li></ul></li><li>收到响应前调用 <code>abort()</code> 取消异步请求</li></ul></li></ol><h3 id="HTTP头部信息"><a href="#HTTP头部信息" class="headerlink" title="HTTP头部信息"></a>HTTP头部信息</h3><p>XHR 提供操作请求头部和响应头部信息的方法</p><p>默认情况，发送 XHR 请求的同时还会发送以下头部信息</p><ul><li>Accept：浏览器能够处理的内容类型</li><li>Accept-Charset：浏览器能够显示的字符集</li><li>Accept-Encoding：浏览器能够处理的压缩编码</li><li>Accept-Language：浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cookie：当前页面设置的任何 Cookie</li><li>Host：发出请求的页面所在的域</li><li>Referer：发出请求的页面的 URI</li><li>User-Agent：浏览器的用户代理字符串</li></ul><ul><li><p><code>setRequestHeader(头部字段名称，头部字段值)</code> </p><ul><li>设置自定义的请求头部信息</li><li>open 之后 send 之前</li></ul></li><li><p><code>getRequestHeader(头部字段名称)</code></p></li><li><p><code>getAllResponseHeaders()</code></p></li></ul><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><p>每个参数的名称和值必须使用 <code>encodeURIComponent()</code> 编码才能放到 URL 末尾，所有名-值对都由 &amp; 分隔</p><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><p><code>serialize()</code> 格式化数据</p><h2 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h2><ul><li>FormData 序列化表单</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(键, 值);</span><br></pre></td></tr></table></figure><ul><li>超时设定 <code>timeout</code>属性</li></ul><p>open 之后 send 之前设定，请求在等待响应多少毫秒之后停止</p><p>触发 timeout 事件，调用 ontimeout 事件处理程序</p><ul><li><code>overrideMimeType()</code> 方法</li></ul><p>重写 XHR 响应的 MIME 类型，send 之前调用</p><h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><ul><li>loadstart：接收到响应数据的第一个字节时触发</li><li>progress：接收响应期间不断地触发</li><li>error：请求发生错误时触发</li><li>abort：在因为调用 abort() 方法而终止连接时触发</li><li>load：在接收到完整的响应数据时触发</li><li>loaded：在通信完成或者触发 error、abort 或 load 事件后触发</li></ul><h2 id="跨资源共享-CORS"><a href="#跨资源共享-CORS" class="headerlink" title="跨资源共享 CORS"></a>跨资源共享 CORS</h2><p>基本思想：使用自定义的 HTTP 头部让浏览器与服务器进行沟通</p><p>发送：<code>Origin：http://www...</code></p><p>接收：<code>Access-Control-Allow-Origin：http://www...</code></p><ul><li><p>在 XHR 对象的 open 中传入绝对 URL 可以请求跨域，：限制</p><ul><li>不能使用 setRequestHeader() 设置自定义头部</li><li>不能发送和接收 cookie</li><li>调用 getAllResponseHeaders() 会返回空字符串</li></ul></li><li><p>Preflighted Requests 透明服务器验证机制</p><ul><li>发送<ul><li>Origin：与简单的请求相同</li><li>Access-Control-Request-Method:请求自身使用的方法</li><li>Access-Control-Request-Headers:(可选)自定义的头部信息，多个头部以逗号分隔</li></ul></li><li>接收<ul><li>Access-Control-Allow-Origin：与简单的请求相同</li><li>Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔</li><li>Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔</li><li>Access-Control-Max-Age：应该将这个 Preflight 请求缓存多长时间(以秒表示)</li></ul></li></ul></li><li><p>带凭据的请求</p><ul><li>默认跨源请求不提供凭据（cookie、HTTP 认证及客户端 SSL 证明）</li><li>将 withCredentials 属性设置为 true 可以指定某个请求应该发送凭据</li><li>响应：<code>Access-Control-Allow-Credentials: true</code></li></ul></li><li><p>跨浏览器的 CROS</p><ul><li>所有浏览器都支持简单的（非 Preflight 和不带凭据的）请求</li></ul></li></ul><h2 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h2><ul><li>图像 Ping<ul><li><code>&lt;img&gt;</code> 标签</li><li>只能发送 GET 请求</li><li>无法访问服务器的响应文本</li></ul></li><li>JSONP - JSON with padding<ul><li>包含两部分：回调函数和数据</li><li>通过 <code>&lt;script&gt;</code> 元素使用</li><li>能直接访问响应文本</li><li>从其他域中加载代码执行，不安全</li><li>很难确定 JSONP 请求是否成功</li></ul></li><li>Comet 服务器推送<ul><li>长轮询：浏览器发送请求，服务器保持连接，直到有数据发送才发送数据。浏览器收到数据后关闭连接，再重新发起新请求</li><li>HTTP 流：浏览器发送请求，服务器保持连接，周期性地向浏览器发送数据</li></ul></li><li>SSE 服务器发送事件<ul><li>围绕只读 Comet 交互推出的 API 或者模式</li></ul></li><li>Web Socket<ul><li>单独的持久连接上提供全双工、双向通信</li></ul></li><li>SSE 与 Web Socket<ul><li>Web Socket 需要服务器支持，双向通信</li><li>SSE 不需要服务器支持，一般单向，结合 XHR 可以双向</li></ul></li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>要求以 SSL 连接来访问可以通过 XHR 请求的资源</li><li>要求每一次请求都要附带经过响应算法计算得到的验证码</li></ul><p>以下措施对防范 CSRF（Cross-Saite Request Forgery）攻击不起作用</p><ul><li>要求发送 POST 而不是 GET —— 容易改变</li><li>检查来源 URL 以确定 是否可信 —— 容易伪造</li><li>基于 cookie 信息进行验证 ——容易伪造</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二十章 JSON</title>
      <link href="/2020/03/12/%E7%AC%AC20%E7%AB%A0-JSON/"/>
      <url>/2020/03/12/%E7%AC%AC20%E7%AB%A0-JSON/</url>
      
        <content type="html"><![CDATA[<p><strong>JSON 是一种数据格式，不是编程语言</strong></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>简单值<ul><li>字符串</li><li>数组</li><li>布尔值</li><li>null</li></ul></li><li>复杂数据类型<ul><li>对象<ul><li>无序的键值对</li></ul></li><li>数组<ul><li>有序的值的列表</li><li>可以通过数值索引访问</li></ul></li></ul></li></ul><h3 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h3><p>JSON 字符串必须使用双引号，JavaScript 字符串可以单引号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello world!"</span></span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"属性"</span>: <span class="string">"值"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>属性必须加双引号</li><li>值可以是简单值/复杂类型</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">25</span>, <span class="string">"hi"</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure><p>}</p><h2 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h2><h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><ul><li><code>stringify()</code> js 对象序列化为 JSON 字符串<ul><li>函数及原型成员会被忽略</li><li>值为 undefined 的属性也会被跳过</li></ul></li><li><code>parse()</code> JSON 字符串解析为 js 值</li></ul><h3 id="序列化选项"><a href="#序列化选项" class="headerlink" title="序列化选项"></a>序列化选项</h3><ul><li><code>JSON.stringify()</code> 参数<ul><li>过滤器<ul><li>数组</li><li>函数 replacer</li></ul></li><li>选项<ul><li>是否在 JSON 字符串中保留缩进</li></ul></li></ul></li></ul><h5 id="过滤结果"><a href="#过滤结果" class="headerlink" title="过滤结果"></a>过滤结果</h5><ul><li><p>如果过滤器参数是数组，那么 stringily() 的结果中将只包含数组中列出的属性</p></li><li><p>如果是函数：该函数接收两个参数（属性名，属性值），根据属性名进行自定义序列化</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">  <span class="string">"authors"</span>: [</span><br><span class="line">    <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">  ],</span><br><span class="line">  edition: <span class="number">3</span>,</span><br><span class="line">  year: <span class="number">2011</span></span><br><span class="line">&#125;;<span class="comment">// js 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(key)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"authors"</span>: <span class="keyword">return</span> value.join(<span class="string">","</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"year"</span>: <span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"edition"</span>: <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;"title":"Professional JavaScript","authors":"Nicholas C. Zakas","year":5000&#125;</span></span><br></pre></td></tr></table></figure><h5 id="字符串缩进"><a href="#字符串缩进" class="headerlink" title="字符串缩进"></a>字符串缩进</h5><ul><li>数字：空格数，最大缩进空格数 10</li><li>字符串：缩进字符，不是用空格，最长10</li></ul><h5 id="toJSON-方法"><a href="#toJSON-方法" class="headerlink" title="toJSON() 方法"></a>toJSON() 方法</h5><p>Date 对象自带，也可以自定义</p><p>做为函数过滤器的补充</p><blockquote><p> stringify() 执行顺序</p><ol><li>如果存在 toJSON() <ul><li>能取得有效值就调用</li><li>否则返回对象本身</li></ul></li><li>如果提供了过滤器（第2个参数）<ul><li>应用过滤器，传入的值是 1 返回的值</li></ul></li><li>对 2 返回的每个值进行相应的序列化</li><li>如果提供第 3 个参数，执行相应的格式化</li></ol></blockquote><h3 id="解析选项"><a href="#解析选项" class="headerlink" title="解析选项"></a>解析选项</h3><ul><li><code>JSON.parse()</code> 参数<ul><li>还原函数 reviver<ul><li>在每个键值对上调用</li><li>接收两个参数（属性即键，值）</li><li>返回 undefined 表示删除相应的键</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十七章 错误处理与调试</title>
      <link href="/2020/03/10/%E7%AC%AC17%E7%AB%A0-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
      <url>/2020/03/10/%E7%AC%AC17%E7%AB%A0-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="try-catch-语句"><a href="#try-catch-语句" class="headerlink" title="try-catch 语句"></a>try-catch 语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 可能会导致错误的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">  <span class="comment">// 在错误发生时怎么处理</span></span><br><span class="line">  <span class="built_in">console</span>.log(error.message)</span><br><span class="line">  <span class="comment">// 所有浏览器都支持 message 属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>finally 子句<ul><li>无论 try 或 catch，都会执行 finally</li><li>如果 try 或 catch 中有 return，会被忽略<ul><li>因为一定要执行 finally</li></ul></li></ul></li><li>错误类型<ul><li>Error<ul><li>基类型，其它都继承这个</li><li>主要用于自定义</li></ul></li><li>EvalError<ul><li>没有把 eval() 当成函数调用，抛出异常<ul><li>eval() 函数在第五章</li></ul></li></ul></li><li>RangeError<ul><li>数值超出响应范围</li></ul></li><li>ReferenceError<ul><li>找不到对象</li></ul></li><li>SyntaxError<ul><li>传入语法错误的 JavaScript 给 eval()</li></ul></li><li>TypeError<ul><li>变量中保存着意外的类型</li><li>访问不存在的方法</li><li>执行特定于类型的操作时，变量类型不符合要求</li></ul></li><li>URIError<ul><li>encodeURI()、decodeURI() 时 URI 格式不正确</li></ul></li></ul></li></ul><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p><code>throw</code> 操作符</p><blockquote><p>捕获错误的目的在于避免浏览器以默认方式处理它们</p><p>抛出错误的目的在于提供错误发生具体原因的消息</p></blockquote><h3 id="错误（error）事件"><a href="#错误（error）事件" class="headerlink" title="错误（error）事件"></a>错误（error）事件</h3><p>没有通过 try-catch 处理的错误会触发 window 对象的 error 事件</p><h3 id="常见的错误类型"><a href="#常见的错误类型" class="headerlink" title="常见的错误类型"></a>常见的错误类型</h3><ul><li>类型转换错误<ul><li><code>===</code>  <code>!==</code></li><li><code>if</code> <code>for</code> <code>while</code></li></ul></li><li>数据类型错误<ul><li><code>typeof</code></li><li><code>instanceof</code></li></ul></li><li>通信错误<ul><li><code>encodeURIComponent()</code></li></ul></li></ul><h2 id="调试技术"><a href="#调试技术" class="headerlink" title="调试技术"></a>调试技术</h2><ul><li><code>error(message)</code></li><li><code>info(message)</code></li><li><code>log(message)</code></li><li><code>warn(message)</code></li></ul><h3 id="抛出错误-1"><a href="#抛出错误-1" class="headerlink" title="抛出错误"></a>抛出错误</h3><ul><li><code>throw</code></li><li><code>assert(条件, 如果条件不为 true 抛出的错误)</code> 可以代替 if 语句</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十四章 表单脚本</title>
      <link href="/2020/03/07/%E7%AC%AC14%E7%AB%A0-%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC/"/>
      <url>/2020/03/07/%E7%AC%AC14%E7%AB%A0-%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="第十四章-表单脚本"><a href="#第十四章-表单脚本" class="headerlink" title="第十四章 表单脚本"></a>第十四章 表单脚本</h1><h2 id="表单的基本知识"><a href="#表单的基本知识" class="headerlink" title="表单的基本知识"></a>表单的基本知识</h2><p>HTML 中，<code>&lt;form&gt;</code> 元素</p><p>Javascript 中，<code>HTMLFormElement</code>类型，继承 <code>HTMLElement</code></p><ul><li><code>acceptCharset</code> 服务器能够处理的字符集 <code>accept-charset</code></li><li><code>action</code> 接受请求的 URL <code>action</code></li><li><code>elements</code> 表单中所有控件集合 <code>HTMLCollection</code></li><li><code>enctype</code> 请求的编码类型 <code>enctype</code></li><li><code>length</code> 表单中控件的数量</li><li><code>method</code> 要发送的HTTP请求类型 get/post <code>method</code></li><li><code>name</code> 表单名称 <code>name</code></li><li><code>reset()</code> 将所有表单域重置为默认值</li><li><code>submit()</code> 提交表单</li><li><code>target</code> 用于发送和接受响应窗口的名称 <code>target</code></li></ul><h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><ul><li><p><code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 都可以定义提交按钮，<code>type = submit</code> 即可</p></li><li><p>提交表单时，浏览器将请求发送给服务器之前触发 submit 事件，这样就有机会验证表单数据。</p></li><li><p>提交表单最大的问题是重复提交表单</p><ul><li>第一次提交后禁用按钮</li><li>利用 onsubmit 事件处理程序 取消后续的表单提交操作</li></ul></li></ul><h3 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h3><ul><li><code>&lt;input&gt;</code> 或 <code>&lt;button&gt;</code> 中 <code>type = reset</code>，单击即可重置</li></ul><h3 id="表单字段"><a href="#表单字段" class="headerlink" title="表单字段"></a>表单字段</h3><p>每个表单都有 <code>elements</code> 属性，内容是所有表单元素的集合。集合是一个有序列表，包含表单中所有字段。</p><ul><li>共有的表单字段属性<ul><li><code>disabled</code></li><li><code>form</code></li><li><code>name</code></li><li><code>readOnly</code></li><li><code>tabIndex</code></li><li><code>type</code></li><li><code>value</code></li></ul></li><li>共有的表单字段方法<ul><li><code>focus()</code></li><li><code>blur()</code></li><li><code>autofocus</code> 页面加载时自动获得焦点</li></ul></li><li>共有的表单字段事件<ul><li><code>blur</code></li><li><code>change</code></li><li><code>focus</code><ul><li><code>blur</code> 和 <code>change</code> 先后顺序在各浏览器中不同</li></ul></li></ul></li></ul><h2 id="文本框脚本"><a href="#文本框脚本" class="headerlink" title="文本框脚本"></a>文本框脚本</h2><p><code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code></p><p>处理文本框时最好不要使用 DOM 方法（<code>setAttribute</code>）</p><h3 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h3><p><code>select()</code> 方法获得焦点时选择其所有文本</p><ul><li>选择事件</li><li>取得选择的文本<ul><li><code>selectionStart</code> 数值，开头位置</li><li><code>selectionEnd</code> 数值，结尾位置</li></ul></li><li>选择部分文本<ul><li><code>setSelectionRange()</code></li></ul></li></ul><h3 id="过滤输入"><a href="#过滤输入" class="headerlink" title="过滤输入"></a>过滤输入</h3><ul><li><p>屏蔽字符</p></li><li><p>操作剪贴板</p><ul><li><p>剪贴板事件</p><ul><li><code>beforecopy</code></li><li><code>copy</code></li><li><code>beforecut</code></li><li><code>cut</code></li><li><code>beforepaste</code></li><li><code>paste</code></li></ul></li><li><p>clipboardData 对象</p><ul><li><code>getData()</code></li><li><code>setData()</code></li><li><code>clearData()</code></li></ul></li></ul></li></ul><h3 id="自动切换焦点"><a href="#自动切换焦点" class="headerlink" title="自动切换焦点"></a>自动切换焦点</h3><p><code>tabForward()</code></p><h3 id="HTML5-约束验证-API"><a href="#HTML5-约束验证-API" class="headerlink" title="HTML5 约束验证 API"></a>HTML5 约束验证 API</h3><ul><li>必填字段 <code>required</code> 属性</li><li>其它输入类型<ul><li><code>email</code></li><li><code>url</code></li></ul></li><li>数值范围<ul><li><code>min</code></li><li><code>max</code></li></ul></li><li>输入模式 <code>pattern</code></li><li>检测有效性<ul><li><code>checkValidity()</code></li><li><code>validity</code></li></ul></li><li>禁用验证 <code>novalidate</code></li></ul><h2 id="选择框脚本"><a href="#选择框脚本" class="headerlink" title="选择框脚本"></a>选择框脚本</h2><p><code>&lt;select&gt;</code>、<code>&lt;option&gt;</code></p><ul><li><code>add(newOption, relOption)</code></li><li><code>multiple</code></li><li><code>options</code> 控件中所有 <code>&lt;option&gt;</code> 元素的 <code>HTMLCollection</code>，每个元素都是  <code>HTMLOptionElement</code> 对象<ul><li><code>index</code></li><li><code>label</code></li><li><code>selected</code></li><li><code>text</code></li><li><code>value</code></li></ul></li><li><code>remove(index)</code></li><li><code>selectedIndex</code></li><li><code>size</code></li></ul><h2 id="表单序列化"><a href="#表单序列化" class="headerlink" title="表单序列化"></a>表单序列化</h2><blockquote><p> 表单提交期间，浏览器怎样将数据发送给服务器？</p><ul><li><p>对表单字段的名称和值进行 URL 编码，使用 &amp; 分隔</p></li><li><p>不发送禁用的表单字段</p></li><li><p>只发送勾选的复选框和单选按钮</p></li><li><p>不发送 type 为 reset 和 button 的按钮</p></li><li><p>多选选择框中的每个选中的值单独一个条目</p></li><li><p>在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。</p></li><li><p>&lt;select&gt; 元素的值，就是选中的 &lt;option&gt; 元素的 value 特性的值</p></li></ul></blockquote><h2 id="富文本编辑"><a href="#富文本编辑" class="headerlink" title="富文本编辑"></a>富文本编辑</h2><p>WYSIWYG（What You See Is What You Get）</p><p>在页面中嵌入一个包含空 HTML 页面的 iframe</p><p>通过设置 designMode 属性，可以编辑，编辑的对象是该页面 body 元素的 HTML 代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十六章 HTMl5 脚本编程</title>
      <link href="/2020/03/07/%E7%AC%AC16%E7%AB%A0-HTMl5%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/03/07/%E7%AC%AC16%E7%AB%A0-HTMl5%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第十六章-HTML5-脚本编程"><a href="#第十六章-HTML5-脚本编程" class="headerlink" title="第十六章 HTML5 脚本编程"></a>第十六章 HTML5 脚本编程</h1><h2 id="跨文档消息传递-XDM"><a href="#跨文档消息传递-XDM" class="headerlink" title="跨文档消息传递 XDM"></a>跨文档消息传递 XDM</h2><p>来自不同域的页面间传递消息</p><ul><li><code>postMessage(消息，域)</code> 发送【消息】给【域】中的 <code>&lt;iframe&gt;</code> 元素</li><li>接收到 XDM 消息时，会触发 window 对象的 message 事件，异步，有延迟</li><li><code>onmessage</code><ul><li><code>data</code></li><li><code>origin</code></li><li><code>source</code></li></ul></li></ul><h2 id="原生拖放"><a href="#原生拖放" class="headerlink" title="原生拖放"></a>原生拖放</h2><h3 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h3><ol><li><code>dragstart</code> 按下鼠标触发</li><li><code>drag</code> 拖动期间持续触发</li><li><code>dragend</code> 拖动停止时触发，无论放置目标是否有效</li></ol><ul><li>当被拖动到一个有效的放置目标上</li></ul><ol><li><code>dragenter</code> 拖动到放置目标上</li><li><code>dragover</code> 放置目标范围内移动持续触发</li><li><code>dragleave</code> 拖出放置目标范围 或 <code>drop</code> 放到放置目标中</li></ol><h3 id="自定义放置目标"><a href="#自定义放置目标" class="headerlink" title="自定义放置目标"></a>自定义放置目标</h3><p>元素默认不允许放置，修改为可放置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> droptarget = <span class="built_in">document</span>.getElementById(<span class="string">"droptarget"</span>);</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragover"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragenter"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="dataTransfet-对象"><a href="#dataTransfet-对象" class="headerlink" title="dataTransfet 对象"></a>dataTransfet 对象</h3><p>用于从被拖动元素向放置目标传递字符串格式的数据</p><ul><li><code>getData()</code></li><li><code>setData()</code></li></ul><p>保存在 dataTransfer 对象中的数据只能在 drop 事件中被读取</p><ul><li><code>dropEffect</code> 被拖动元素能执行的放置行为<ul><li>none</li><li>move</li><li>copy</li><li>link</li></ul></li><li><code>effectAllowed</code> 允许拖动元素的哪种 dropEffect<ul><li>uninitialized</li><li>none</li><li>copy</li><li>link</li><li>move</li><li>copyLink</li><li>copyMove</li><li>linkMove</li><li>all</li></ul></li></ul><h3 id="可拖动"><a href="#可拖动" class="headerlink" title="可拖动"></a>可拖动</h3><p>默认情况下，图像、链接、文本可拖动</p><p>其它元素可以手动设置 draggable 属性为 ture</p><h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><p><code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code> 必须 src 指向要加载的媒体</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>表示媒体的当前状态</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>触发事件，监听属性变化，可能是播放结果，也可能是操作结果</p><h2 id="历史状态管理"><a href="#历史状态管理" class="headerlink" title="历史状态管理"></a>历史状态管理</h2><p>history 对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十三章 事件</title>
      <link href="/2020/03/05/%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E4%BB%B6/"/>
      <url>/2020/03/05/%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="第十三章-事件"><a href="#第十三章-事件" class="headerlink" title="第十三章 事件"></a>第十三章 事件</h1><p>js 和 html 之间的交互是通过<strong>事件</strong>实现的，事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。<br>可以使用<strong>侦听器</strong>来预定事件，以便事件发生时执行相应的代码。<br>这种在传统软件工程中被称为<strong>观察员模式</strong>的模型，支持 js 和 html+css 之间的松散耦合。</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p><strong>事件流</strong>描述的是从页面中接收事件的顺序</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>按照 DOM 树逐级向上，在每一级节点上都会发生，直到 document</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>顺序与事件冒泡相反</p><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><p>“DOM2 级事件”规定的事件流包括三个阶段：</p><ul><li>事件捕获阶段<ul><li>Document 到 目标元素的上一级</li></ul></li><li>处于目标阶段<ul><li>事件在目标元素上发生，事件处理被看成冒泡的一部分</li></ul></li><li>事件冒泡阶段<ul><li>目标元素 到 Document<blockquote><p>DOM2 规定捕获阶段不设计目标，但浏览器实现时都会出发事件对象上的事件</p></blockquote></li></ul></li></ul><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><ul><li><strong>事件</strong>就是某种动作，如 click、load、mouseovre</li><li><strong>事件处理程序（事件侦听器）</strong>就是响应事件的函数，以 on 开头，onclick、onload 等</li></ul><h3 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span><span class="params">()</span> </span>&#123;……&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果用户在页面解析事件处理程序之前点击元素，会引发错误</li><li>扩展作用域链在不同浏览器中会导致不同结果</li><li>HTML 与 JavaScript 代码紧密耦合</li></ul><h3 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h3><p>将一个函数赋值给事件处理程序属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;……&#125;</span><br></pre></td></tr></table></figure><ul><li>代码运行之前不会指定事件处理程序，可能导致点击无效</li><li>事件处理程序是在元素的作用域中运行的，this 引用当前元素</li><li>null 即删除</li></ul><h3 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h3><ul><li><p><code>addEventListener(a, b, c)</code></p></li><li><p><code>removeEventListener(a, b, c)</code></p><ul><li>a 要处理的事件名</li><li>b 作为事件处理程序的函数</li><li>c 一个布尔值<ul><li>true 捕获阶段调用事件处理程序</li><li>false 冒泡阶段调用事件处理程序 ☑️<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>事件处理程序是在元素的作用域中运行的，this 引用当前元素</p></li><li><p>存在多个事件处理程序会按照添加顺序触发</p></li><li><p>addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除</p></li><li><p>addEventListener() 添加的匿名函数无法移除</p></li></ul><h3 id="IE-事件处理程序"><a href="#IE-事件处理程序" class="headerlink" title="IE 事件处理程序"></a>IE 事件处理程序</h3><ul><li><p><code>attachEvent(a, b)</code></p></li><li><p><code>detachEvent(a, b)</code></p><ul><li>a 事件处理程序名称</li><li>b 事件处理程序函数</li></ul></li><li><p>只支持冒泡</p></li><li><p>事件处理程序的作用域是全局</p></li><li><p>存在多个事件处理程序会按照添加顺序相反的顺序触发</p></li></ul><h3 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h3><p>关注冒泡阶段</p><ul><li><code>addHandler(a, b, c)</code></li><li><code>EventUtil(a, b, c)</code><ul><li>a 要操作的元素</li><li>b 事件名称</li><li>c 事件处理程序</li></ul></li></ul><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与时间有关的信息</p><h3 id="DOM-中的事件对象"><a href="#DOM-中的事件对象" class="headerlink" title="DOM 中的事件对象"></a>DOM 中的事件对象</h3><p>兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中</p><ul><li><code>event.preventDefault()</code> 阻止特定事件的默认行为，如链接到默认行为是导航到 href</li><li><code>event.stopPropagation()</code> 停止事件在 DOM 层次中的传播（捕获或冒泡）</li><li><code>event.eventPhase</code> 确定事件当前正位于事件流的哪个阶段<ul><li>捕获 1</li><li>处于目标 2</li><li>冒泡 3</li></ul></li><li>事件处理器执行期间 event 对象才会存在，执行完就销毁</li></ul><h3 id="IE-中的事件对象"><a href="#IE-中的事件对象" class="headerlink" title="IE 中的事件对象"></a>IE 中的事件对象</h3><h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><p>不一定与用户操作有关</p><ul><li><code>load</code> 当页面完全加载后在 window 上触发，当图像加载完毕时在<img>元素上面触发</li><li><code>unload</code> 当页面完全卸载后在 window 上触发（页面切换时）</li><li><code>resize</code> 浏览器窗口调整大小时 window 上触发，通过 js 或 body 元素中 onresize 指定事件处理程序</li><li><code>scroll</code> window 对象上发生，表示页面中相应元素的变化</li></ul><h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><p>获得或失去焦点时触发</p><ul><li><code>document.hasFocus()</code></li><li><code>document.activeElement</code></li></ul><hr><ul><li><code>blur</code> 元素失去焦点时触发，不冒泡</li><li><code>focus</code> 获得焦点时触发，不冒泡</li><li><code>focusin</code> 获得焦点时，冒泡</li><li><code>focusout</code> 失去焦点时，冒泡</li></ul><h3 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h3><ul><li><code>click</code> 单击或回车</li><li><code>dblclick</code> 双击</li><li><code>mousedown</code> 按下任意鼠标按钮</li><li><code>mouseup</code> 释放鼠标按钮</li><li><code>mouseenter</code> 光标从外部首次移动到元素范围之内，不冒泡，移动到后代元素上不会触发</li><li><code>mouseleave</code> 元素上的光标移动到元素范围之外，不冒泡，移动到后代元素不触发</li><li><code>mousemove</code> 光标在元素内部移动时重复触发</li><li><code>mouseout</code> 鼠标位于一个元素上方，移入另一个元素时触发。另一个元素可能是原来元素的外部或子元素</li><li><code>mouseover</code> 光标位于一个元素外部，首次移入另一个元素边界之内</li></ul><hr><ul><li>客户区坐标位置<ul><li><code>event.clientX</code></li><li><code>event.clientY</code></li></ul></li><li>页面坐标位置<ul><li><code>event.pageX</code></li><li><code>event.pageY</code></li></ul></li><li>屏幕坐标位置<ul><li><code>event.screenX</code></li><li><code>event.screenY</code></li></ul></li><li>修改键<ul><li>click + 键盘 -&gt; 属性（Boolean）<ul><li>Shift <code>shiftKey</code></li><li>Ctrl <code>ctrlKey</code></li><li>Alt <code>altKey</code></li><li>Meta(Windows/Cmd) <code>metaKey</code></li></ul></li></ul></li><li>相关元素<ul><li>针对 <code>moseover</code>、<code>mouseout</code><ul><li><code>relatedTarget</code> 属性</li></ul></li></ul></li><li>鼠标按钮<ul><li>针对 <code>mousedown</code>、<code>mouseup</code><ul><li><code>button</code> 属性<ul><li>0 主鼠标</li><li>1 滚轮</li><li>2 次鼠标</li></ul></li></ul></li></ul></li><li>鼠标滚轮事件<ul><li><code>mousewheel</code><ul><li>冒泡</li><li><code>wheelDelta</code> 属性</li></ul></li></ul></li></ul><h3 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h3><ul><li><code>keydown</code> 任意键</li><li><code>keypress</code> 字符键</li><li><code>keyup</code> 释放案件</li></ul><hr><ul><li><code>event.keyCode</code> 键码，ASCII 小写字母相同</li><li><code>event.charCode</code> 字符编码，针对 keypress</li></ul><h3 id="变动事件"><a href="#变动事件" class="headerlink" title="变动事件"></a>变动事件</h3><ul><li>删除节点</li><li>插入节点</li></ul><h3 id="HTML5-事件"><a href="#HTML5-事件" class="headerlink" title="HTML5 事件"></a>HTML5 事件</h3><ul><li><code>contextmenu</code> 冒泡</li><li><code>beforeunload</code></li><li><code>DOMContentLoaded</code></li><li><code>readystatechange</code><ul><li>uninitialized</li><li>loading</li><li>loaded</li><li>interactive</li><li>complete</li></ul></li><li><code>pageshow</code> <code>pagehide</code></li><li><code>hashchange</code></li></ul><h3 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h3><p>智能手机和平板电脑</p><h3 id="触摸与手势"><a href="#触摸与手势" class="headerlink" title="触摸与手势"></a>触摸与手势</h3><h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><p>添加到页面上 的事件处理程序数量将直接关系到页面的整体运行性能</p><ul><li>函数对象占用内存</li><li>指定事件处理程序导致的 DOM 访问</li></ul><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>利用事件冒泡，只指定一个事件处理程序</p><h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><p>将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的 JavaScript 代码之间就 会建立一个连接。连接越多，页面执行起来就越慢。</p><h2 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h2><p>js 触发事件</p><h3 id="DOM-中的事件模拟"><a href="#DOM-中的事件模拟" class="headerlink" title="DOM 中的事件模拟"></a>DOM 中的事件模拟</h3><ul><li><p><code>document.createEvent()</code></p><ul><li>UIEvents</li><li>MouseEvents</li><li>MutationsEvents</li><li>HTMLEvents</li></ul></li><li><p>模拟鼠标</p></li><li><p>模拟键盘</p></li><li><p>模拟其他</p></li></ul><h3 id="IE-中"><a href="#IE-中" class="headerlink" title="IE 中"></a>IE 中</h3>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十章 DOM &amp; 第十一章 DOM 扩展 &amp; 第十二章 DOM2 和 DOM3</title>
      <link href="/2020/03/04/%E7%AC%AC10-12%E7%AB%A0-DOM%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/03/04/%E7%AC%AC10-12%E7%AB%A0-DOM%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a>第十章 DOM</h1><ul><li>针对 HTML 和 XML 文档的一个 API</li></ul><h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><ul><li><strong>文档元素</strong>是最外层元素，每个文档只有一个文档元素，HTML 中是 <code>html</code></li></ul><h3 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h3><ul><li>js 所有节点类型都继承自 Node 类型</li><li><code>nodeType</code> 值为 node 的类型常量（12种）<ul><li>元素节点 Node.ELEMENT_NODE(1)</li><li>文本节点 Node.TEXT_NODE(3)</li></ul></li></ul><h5 id="nodeName-和-nodeValue-属性"><a href="#nodeName-和-nodeValue-属性" class="headerlink" title="nodeName 和 nodeValue 属性"></a>nodeName 和 nodeValue 属性</h5><ul><li><code>nodeName</code> 元素标签名</li><li><code>nodeValue</code> 元素的值</li></ul><h5 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h5><p><img src="/.com//%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB.png" alt="节点关系.png"></p><ul><li><code>hashChildNodes()</code> </li><li><code>ownerDocument</code> 指向文档节点（最外层节点）</li></ul><h5 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h5><ul><li><code>appendChild(newNode)</code> childNodes 列表末尾添加一个节点<ul><li>如果 newNode 已经存在 DOM 树中，会移动位置，而不是新建</li></ul></li><li><code>insertBefore(NewNode, Node)</code> 将 NewNode 插入到 Node 前面的位置</li><li><code>replaceChild(NewNode, Node)</code></li><li><code>removeChild(Node)</code><br>以上方法通过父节点调用</li></ul><hr><p>以下方法所有节点都有</p><ul><li><code>cloneNode(Boolean)</code><ul><li>true 深复制，整个子节点树</li><li>false 浅复制，节点本身</li><li>返回的节点属于文档，但没有父节点</li></ul></li><li><code>normalize()</code> 处理文档节点</li></ul><h3 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h3><p>浏览器中 document 对象是 <code>HTMLDocument</code>（继承自 Document 类型）的一个实例，是 window 对象的一个属性</p><ul><li>nodeType = 9</li><li>nodeName = “#document”</li><li>nodeValue = null</li><li>parentNode = null</li><li>ownerDocument = null</li><li>子节点可能是一个 DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction 或 Comment</li></ul><h5 id="文档的子节点"><a href="#文档的子节点" class="headerlink" title="文档的子节点"></a>文档的子节点</h5><ul><li><code>document.documentElement</code> 始终指向 HTML 页面中的 <code>html</code> 元素</li><li><code>document.body</code> 指向 <code>body</code> 元素</li><li><code>document.doctype</code> </li></ul><h5 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h5><p>浏览器专供属性，存在 HTTP 头部</p><ul><li><code>document.title</code></li><li><code>document.URL</code></li><li><code>document.domain</code></li><li><code>document.referrer</code></li></ul><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><ul><li><code>document.getElementById()</code> 多个元素相同 id 则返回第一个</li><li><code>document.getElementsByTagName()</code> 返回 NodeList，HTML 文档中返回 <code>HTMLCollection</code> 对象</li><li><code>document.getElementsByName()</code> 返回 <code>HTMLCollection</code> 对象</li></ul><h5 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h5><ul><li><code>document.anchors</code></li><li><code>document.forms</code></li><li><code>document.images</code></li><li><code>document.links</code> 带 href 特性的 a 元素</li></ul><h5 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h5><ul><li><code>document.write()</code></li><li><code>document.writeln()</code></li><li><code>document.open()</code> 打开网页输出流</li><li><code>document.close()</code> 关闭网页输出流</li></ul><h3 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h3><ul><li>nodeType = 1</li><li>nodeName = 元素的标签名</li><li>nodeValue = null</li><li>parentNode 可能是 Document 或 Element</li><li>子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference</li></ul><p><code>nodeName</code> 和 <code>tagName</code> 属性都是标签名</p><h5 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h5><p>HTMLElement 继承 Element 并添加了一些属性</p><ul><li><code>id</code></li><li><code>title</code></li><li><code>lang</code></li><li><code>dir</code></li><li><code>className</code></li></ul><h5 id="操作特性"><a href="#操作特性" class="headerlink" title="操作特性"></a>操作特性</h5><ul><li><code>getAttribute(‘class’)</code></li><li><code>setAttribute(‘class’, &#39;ft&#39;)</code></li><li><code>removeAttribute(&#39;class&#39;)</code></li></ul><h5 id="attributes-属性"><a href="#attributes-属性" class="headerlink" title="attributes 属性"></a>attributes 属性</h5><p><code>attributes</code> 属性中包含一个 <code>NamedNodeMap</code> 对象，元素每个特性都由一个 Attr 节点表示，节点保存在 <code>NamedNodeMap</code> 对象中<br>对象方法</p><ul><li><code>getNamedItem(name)</code></li><li><code>removeNamedItem(name)</code></li><li><code>setNamedItem(node)</code></li><li><code>item(pos)</code></li></ul><p>节点属性</p><ul><li><code>nodeName</code></li><li><code>nodeValue</code></li></ul><h5 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h5><ul><li><code>document.createElement(标签名)</code><br>创建完成后需要调用前面介绍的方法将其添加到文档树中</li></ul><h3 id="Text-类型（开始和结束标签中的文本）"><a href="#Text-类型（开始和结束标签中的文本）" class="headerlink" title="Text 类型（开始和结束标签中的文本）"></a>Text 类型（开始和结束标签中的文本）</h3><ul><li>nodeType = 3</li><li>nodeName = #text</li><li>nodeValue 节点所包含的文本</li><li>parentNode 是 Element</li><li>没有子节点</li></ul><hr><ul><li><code>document.createTextNode()</code> 创建文本节点</li><li><code>normalize()</code> 相邻的文本节点之间不存在空格，可以将所有相邻的文本节点拼接起来</li><li><code>splitText()</code> 分割文本节点</li></ul><h3 id="Comment-类型"><a href="#Comment-类型" class="headerlink" title="Comment 类型"></a>Comment 类型</h3><ul><li>nodeType = 8</li><li>nodeName = #comment</li><li>nodeValue = 注释的内容</li><li>parentNode 可能是 Document 或 Element</li><li>没有子节点</li></ul><h3 id="CDATASection-类型"><a href="#CDATASection-类型" class="headerlink" title="CDATASection 类型"></a>CDATASection 类型</h3><ul><li>针对 XML 文档，表示 CDATA 区域</li><li>浏览器会解析为 Comment 或 Element</li></ul><h3 id="DocumentType-类型"><a href="#DocumentType-类型" class="headerlink" title="DocumentType 类型"></a>DocumentType 类型</h3><p>包含 doctype 有关的信息</p><h3 id="DocumentFragment-类型"><a href="#DocumentFragment-类型" class="headerlink" title="DocumentFragment 类型"></a>DocumentFragment 类型</h3><h3 id="Attr-类型"><a href="#Attr-类型" class="headerlink" title="Attr 类型"></a>Attr 类型</h3><p>元素的特性，不是 DOM 文档树的一部分</p><h2 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h2><h3 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h3><p>DOM 操作 script 标签</p><h3 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h3><p>DOM 操作 link 标签 和 style 标签</p><h3 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h3><p>DOM 操作 table 标签</p><h3 id="使用-NodeList"><a href="#使用-NodeList" class="headerlink" title="使用 NodeList"></a>使用 NodeList</h3><ul><li><code>NodeList</code></li><li><code>NamedNodeMap</code></li><li><code>HTMLCollection</code><br>每当文档结构发生变化，它们都会更新，保存最新的信息</li></ul><blockquote><p>理解 DOM 的关键，就是理解 DOM 对性能的影响。DOM 操作往往是 JavaScript 程序中开销最大的 部分，而因访问 NodeList 导致的问题为最多。NodeList 对象都是“动态的”，这就意味着每次访问 NodeList 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作。</p></blockquote><h1 id="第十一章-DOM-扩展"><a href="#第十一章-DOM-扩展" class="headerlink" title="第十一章 DOM 扩展"></a>第十一章 DOM 扩展</h1><h2 id="选择符-API"><a href="#选择符-API" class="headerlink" title="选择符 API"></a>选择符 API</h2><ul><li>参数为 CSS 选择符<ul><li><code>querySelector()</code> 返回元素</li><li><code>querySelectorAll()</code> 返回 NodeList 快照</li></ul></li></ul><h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><ul><li><code>childElementCount</code> 不包括文本节点和注释</li><li><code>firstElementChild</code></li><li><code>lastElementChild</code></li><li><code>previousElementSibling</code></li><li><code>nextElementSibling</code></li></ul><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="与类相关的扩充"><a href="#与类相关的扩充" class="headerlink" title="与类相关的扩充"></a>与类相关的扩充</h3><ul><li><code>getElementsByClassName()</code></li><li><code>classList</code> DOMTokenList 的实例</li></ul><h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><ul><li><code>activeElement</code> 当前获得焦点的元素</li><li><code>hasFocus()</code> 文档是否获得焦点（用户是否正在与页面交互）</li></ul><h3 id="HTMLDocument-的变化"><a href="#HTMLDocument-的变化" class="headerlink" title="HTMLDocument 的变化"></a>HTMLDocument 的变化</h3><ul><li><code>readyState</code> 属性<ul><li>loading</li><li>complete</li></ul></li><li><code>compatMode</code> 兼容模式<ul><li>CSS1Compat 标准模式</li><li>BackCompat 混杂模式</li></ul></li><li><code>head</code> 引用 head 标签元素</li></ul><h3 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h3><ul><li><code>charset</code> 默认 ”UTF-16“</li><li><code>defaultCharset</code> 根据默认浏览器及操作系统设置</li></ul><h3 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h3><ul><li>添加前缀 data-</li><li><code>dataset</code> 属性访问自定义属性的值<ul><li>值是 DOMStringMap 的一个实例</li><li>也就是一个名值对的映射</li></ul></li></ul><h3 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h3><ul><li><code>innerHTML</code> 属性</li><li><code>outerHTML</code> 属性</li><li><code>insertAdjacentHTML()</code> 方法<ul><li>params1 插入位置<ul><li>beforebegin</li><li>afterbegin</li><li>beforeend</li><li>afterend</li></ul></li><li>params2 HTML 文本</li></ul></li><li>内存与性能问题</li></ul><h3 id="scrollIntoView-方法"><a href="#scrollIntoView-方法" class="headerlink" title="scrollIntoView() 方法"></a>scrollIntoView() 方法</h3><p>让当前的元素滚动到浏览器窗口的可视区域内</p><h1 id="第十二章-DOM2-和-DOM3"><a href="#第十二章-DOM2-和-DOM3" class="headerlink" title="第十二章 DOM2 和 DOM3"></a>第十二章 DOM2 和 DOM3</h1><p>DOM1 主要定义的是 HTML 和 XML 文档的底层结构，DOM2 和 DOM3 分为许多模块，分表描述 DOM 的某个非常具体的子集，目的在于扩展 DOM API</p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>定义样式</p><ul><li><code>&lt;link/&gt;</code> 外部样式表</li><li><code>&lt;style/&gt;</code> 嵌入式样式</li><li><code>style 特性</code> 针对特定元素的样式</li></ul><h3 id="访问元素的样式"><a href="#访问元素的样式" class="headerlink" title="访问元素的样式"></a>访问元素的样式</h3><ul><li>元素的 style 特性是 <code>CSSStyleDeclaration</code> 的实例</li><li>CSS 属性的短线转为驼峰才能通过 js 访问</li><li>float 是保留字所以 转为 cssFloat</li></ul><h3 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h3><p>CSSStyleSheet 类型表示的是样式表，继承自 StyleSheet，后者可以作为一个基础接口来定义非 CSS 样式表</p><h3 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h3><ul><li><p>偏移量<br><img src="/.com//%E5%81%8F%E7%A7%BB%E9%87%8F.png" alt="偏移量.png"></p></li><li><p>客户区大小<br><img src="/.com//%E5%AE%A2%E6%88%B7%E5%8C%BA%E5%A4%A7%E5%B0%8F.png" alt="客户区大小.png"></p></li></ul><p>所有偏移量、客户区大小都是只读的，每次访问要重新计算。避免重复访问，有需要可以保存下来。</p><ul><li><p>滚动大小<br><img src="/.com//%E6%BB%9A%E5%8A%A8%E5%A4%A7%E5%B0%8F.png" alt="滚动大小.png"></p></li><li><p>确定元素大小<br><code>getBoundingClientRect()</code> 返回 DOMRect 对象，包含四个值<br><img src="/.com//%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F.png" alt="确定元素大小.png"></p></li></ul><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul><li>NodeIterator</li><li>TreeWalker</li></ul><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><ul><li>范围是选择 DOM 结构中特定部分，然后再执行相应操作的一种手段。</li><li>使用范围选区可以在删除文档中某些部分的同时，保持文档结构的格式良好，或者复制文档中的相应部分。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八章 BOM</title>
      <link href="/2020/03/02/%E7%AC%AC8%E7%AB%A0-BOM/"/>
      <url>/2020/03/02/%E7%AC%AC8%E7%AB%A0-BOM/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-BOM"><a href="#第八章-BOM" class="headerlink" title="第八章 BOM"></a>第八章 BOM</h1><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><ul><li>BOM 的核心对象是 window，表示浏览器的一个实例<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3></li><li>Window 作为 Global 对象，所有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法</li><li>全局变量不能通过 delete 删除，直接在 window 对上定义的属性可以</li></ul><h3 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h3><ul><li><code>window.screenLeft</code></li><li><code>window.screenTop</code></li><li><code>window.screenX</code></li><li><code>window.screenY</code></li><li><code>window.moveTo(x, y)</code></li><li><code>window.moveBy(a, b)</code></li></ul><h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><ul><li><code>window.innerWidth</code></li><li><code>window.innerHeight</code></li><li><code>window.outerWidth</code></li><li><code>window.outerHeight</code></li><li><code>window.resizeTo(w, h)</code></li><li><code>window.resizeBy(w, h)</code></li></ul><h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><ul><li><code>window.open(URL, target, String, Boolean)</code></li></ul><h3 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h3><ul><li><code>setTimeout(function, ms)</code><ul><li>ms 后把当前任务添加到任务队列，如果此时任务队列是空的才会立即执行<ul><li>所以不一定 ms 后就会执行 function</li></ul></li><li>返回一个数值 ID</li></ul></li><li><code>clearTimeout(timeoutID)</code></li><li><code>setInterVal(function, ms)</code></li><li><code>clearInterval(timeoutID)</code></li></ul><h3 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h3><p>样式由操作系统或浏览器决定<br>显示这些对话框的时候代码会停止执行</p><ul><li><code>alert()</code></li><li><code>confirm()</code></li><li><code>prompt()</code></li><li><code>find()</code></li><li><code>print()</code></li></ul><h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><ul><li>既是 window 对象的属性，也是 document 对象的属性</li><li>window.LOcation 和 document.location 引用的是同一个对象</li></ul><h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><ul><li><p><code>location.assign(url)</code></p></li><li><p><code>window.location = &quot;url&quot;</code></p></li><li><p><code>location.href = &quot;url&quot;</code><br>修改 location 其它属性页面都会重新加载，浏览器的历史记录会生产一条新记录</p></li><li><p><code>replace(url)</code> 不会产生新记录</p></li><li><p><code>reload()</code> </p><ul><li>无参数，可能是用缓存</li><li>参数 true，强制从服务器重新加载</li><li>调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。最好将 reload()放在代码的最后一行</li></ul></li></ul><h2 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h2><h2 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h2><ul><li><code>history.go()</code><ul><li>number 前进或后退页面</li><li>string 跳转到历史记录中包含string最近的位置</li></ul></li><li><code>history.back()</code> 后退</li><li><code>history.forward()</code> 前进</li><li><code>history.length</code> 历史记录数量</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十五章 使用 Canvas 绘图</title>
      <link href="/2020/03/02/%E7%AC%AC15%E7%AB%A0-%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%9B%BE/"/>
      <url>/2020/03/02/%E7%AC%AC15%E7%AB%A0-%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol><li>设置 width 和 height 属性，制定绘图区域<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"drawing"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span>A drawing of something.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>取得绘图上下文<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定浏览器支持 &lt;canvas&gt; 元素</span></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>导出绘制的图像<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123;</span><br><span class="line">    <span class="comment">//取得图像的数据 URI</span></span><br><span class="line">    <span class="keyword">var</span> imgURI = drawing.toDataURL(<span class="string">"imge/png"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示图像</span></span><br><span class="line">    <span class="keyword">var</span> image = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">    image.src = imgURI;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2D上下文"><a href="#2D上下文" class="headerlink" title="2D上下文"></a>2D上下文</h2><ul><li>坐标开始于左上角，原点坐标 (0, 0)</li><li>x 越大靠右，y 越大靠下</li><li>width 和 height 表示水平和垂直两个方向上可用的像素数</li></ul><h3 id="填充和描边"><a href="#填充和描边" class="headerlink" title="填充和描边"></a>填充和描边</h3><ul><li><code>fillStyle</code> 填充（字符串、渐变对象或模式对象）</li><li><code>strokeStyle</code> 描边（字符串、渐变对象或模式对象）</li><li><code>lineWidth</code> 线条宽度（整数）</li><li><code>lineCap</code> 线条末端形状（“butt”、“round”、“square”）</li><li><code>lineJoin</code> 线条相交形状（“round”、“bevel”、“miter”）</li></ul><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><ul><li><code>fillRect(x, y, w, h)</code></li><li><code>strokeRect(x, y, w, h)</code></li><li><code>clearRect(x, y, w, h)</code><ul><li>x: x 坐标</li><li>y: y 坐标</li><li>w: 矩形宽度</li><li>h: 矩形高度</li></ul></li></ul><h3 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h3><ol><li>调用<code>beginPath()</code>表示开始绘制新路径</li><li>绘制路径<ul><li><code>arc(x, y, radius, startAngle, endAngle, counterclockwise)</code> </li><li><code>arcTo(x1, y1, x2, y2, radius)</code> </li><li><code>bezierCurveTo(c1x, c1y, c2x, c2y, x, y)</code></li><li><code>lineTo(x, y)</code></li><li><code>moveTo(x, y)</code></li><li><code>quadraticCurveTo(cx, cy, x, y)</code></li><li><code>rect(x, y, width, height)</code></li></ul></li><li>绘制到画布<ul><li><code>closePath()</code></li><li><code>fill()</code></li><li><code>stroke()</code></li><li><code>clip()</code></li></ul></li></ol><ul><li><code>isPointInpath(x, y)</code> 点(x, y)是否在路径上</li></ul><h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><ul><li><code>fillText(string, x, y, (可选)font-size)</code></li><li><code>strokeText(string, x, y, (可选)font-size)</code></li></ul><hr><ul><li><code>font</code> 文本样式、大小、字体</li><li><code>textAlign</code> 文本对齐方式</li><li><code>textBaseline</code> 文本基线</li></ul><hr><ul><li><code>measureText()</code> 确定文本大小</li></ul><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><ul><li><code>rotate(angle)</code> 绕原点旋转图像</li><li><code>scale(scaleX, scaleY)</code> 缩放图像</li><li><code>translate(x, y)</code> 将坐标原点移动到 (x, y)</li><li><code>transform(m1_1, m1_2, m2_1, m2_2, dx, dy)</code> 修改变换矩阵</li><li><code>setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)</code> 将变换矩阵重置为默认状态再调用 transform()</li></ul><hr><ul><li><code>save()</code> 保存上下文状态</li><li><code>restore()</code> 读取保存的状态</li></ul><h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><ul><li><code>drawImage()</code><ul><li>要绘制的图像</li><li>源图像的 x 坐标</li><li>源图像的 y 坐标</li><li>源图像的宽度</li><li>源图像的高度</li><li>目标图像的 x 坐标</li><li>目标图像的 y 坐标</li><li>目标图像的宽度</li><li>目标图像的高度</li></ul></li></ul><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><ul><li><code>shadowColor</code></li><li><code>shadowOffsetXr</code></li><li><code>shadowOffsetY</code></li><li><code>shadowBlur</code></li></ul><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><ol><li><code>cg = createLinearGradient()</code> 创建新的渐变，返回 CanvasGradient 对象</li><li><code>cg.addColorStop()</code> 制定色标</li><li><code>fillStyle = cg</code>/<code>strokeStyle = cg</code> 绘制</li></ol><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li>重复的图像</li><li><code>createPattern()</code></li></ul><h3 id="使用图像数据"><a href="#使用图像数据" class="headerlink" title="使用图像数据"></a>使用图像数据</h3><ul><li><code>getImageData()</code></li></ul><h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><ul><li><code>globalAlpha</code> 透明度</li><li><code>globalCompositionOperation</code><ul><li>source-over(默认值):后绘制的图形位于先绘制的图形上方</li><li>……</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 函数表达式</title>
      <link href="/2020/03/01/%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/03/01/%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>定义函数的方式</p><ol><li>函数声明<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionName(); <span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数声明提升</span></span><br><span class="line"><span class="comment">// 执行代码前会读取函数声明，意味着可以把函数声明放在调用后面</span></span><br></pre></td></tr></table></figure></li><li>函数表达式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionName(); <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有函数声明提升</span></span><br><span class="line"><span class="comment">// 使用前必须先赋值</span></span><br></pre></td></tr></table></figure><blockquote><p>function 关键字后面没有标识符，所以叫<strong>匿名函数</strong>，也叫<strong>拉姆达函数</strong>。</p></blockquote></li></ol><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        reutrn <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line">alert(anotherFactorial(<span class="number">4</span>)); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为调用 anotherFactorial(num) 时，函数内部会执行 factorial(num-1)，而此时 factorial 已经被置为 null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为 arguments.callee 即可，如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>闭包</strong>是指(有权访问[另一个函数作用域中的变量]的)函数。<br>创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">        <span class="comment">// 这个匿名函数的作用域链中包含 createComparisonFunction() 的作用域，所以这两行代码可以访问外部函数中的变量 propertyName</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当函数执行完毕后，局部活动对象会被销毁，内存仅保留全局作用域。但是闭包有所不同。<br>在另一个函数内部定义的函数会将包含它的函数（即外部函数）的活动对象添加到它的作用域链中。<br>因此，createComparisonFunction() 函数内部定义的匿名函数的作用域链中，实际上会包含外部函数 createComparisonFunction() 的活动对象。<br><img src="/.com//%E9%97%AD%E5%8C%85.png" alt="闭包.png"><br>在匿名函数从 createComparisonFunction() 中被返回后，它的作用域链被初始化为 包含 createComparisonFunction() 函数的活动对象和全局变量对象。<br>这样，匿名函数就可以访问在 createComparisonFunction() 中定义的所有变量。<br>同时，createComparisonFunction() 的活动对象由于被匿名函数的作用域链引用，在函数执行完毕之后不会被销毁。</p></blockquote><p>由于闭包会携带外部函数的作用域，因此会比其他函数占更多的内存。所以要慎重使用闭包。</p><h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><ul><li>闭包只能取得包含函数中每个变量的最新值</li><li>因为每个函数作用域链中都保存着外部函数的活动对象，是共享的，最后更新的内容会被引用。</li></ul><h3 id="关于-this-对象"><a href="#关于-this-对象" class="headerlink" title="关于 this 对象"></a>关于 this 对象</h3><ul><li>匿名函数的执行环境具有全局性，this 通常指向 window。用 call 或 apply 改变制定环境时会指向其他对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">" "</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(object.getNameFunc()());  <span class="comment">// "The Window My Object"</span></span><br><span class="line">alert(object.getName());  <span class="comment">// "My Object"</span></span><br></pre></td></tr></table></figure><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3></li><li>闭包会引用包含函数的整个活动对象，可以活动对象中的变量赋值 null 解除引用，保证内存正常回收。</li></ul><h2 id="模仿块级作用域（）私有作用域"><a href="#模仿块级作用域（）私有作用域" class="headerlink" title="模仿块级作用域（）私有作用域"></a>模仿块级作用域（）私有作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 定义并立即调用了一个匿名函数</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理解过程</span></span><br><span class="line"><span class="comment">// 定义一个函数并立即调用</span></span><br><span class="line"><span class="keyword">var</span> someFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;;</span><br><span class="line">someFunction();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用函数的值直接取代函数名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;(); <span class="comment">// 报错，函数声明后不能跟圆括号</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;)(); <span class="comment">// 正确，函数表达式可以跟圆括号</span></span><br></pre></td></tr></table></figure><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><ul><li><p>严格来说，js 中没有私有成员的概念，所有的对象属性都是公有的</p><blockquote><p>个人理解：oop 语言中私有成员不能被子类继承，而 js 中所有对象属性都能被继承，因此都是公有的</p></blockquote></li><li><p>但有私有变量的概念，任何在函数中定义的变量都可以认为是私有变量，因为不能在函数的外部访问这些变量</p></li><li><p>私有变量包括</p><ul><li>函数的参数</li><li>局部变量</li><li>在函数内部定义的其他函数</li></ul></li></ul><h6 id="特权方法：有权访问私有变量和私有函数的公有方法"><a href="#特权方法：有权访问私有变量和私有函数的公有方法" class="headerlink" title="特权方法：有权访问私有变量和私有函数的公有方法"></a>特权方法：有权访问私有变量和私有函数的公有方法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在构造函数中定义特权方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fasle;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数（没有var，全局变量）</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公有/特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><ul><li>模块模式：为单例创建私有变量和特权方法<ul><li>单例：只有一个实例的对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = &#123;</span><br><span class="line">    name: value,</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回单例的公共接口</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicProperty: <span class="literal">true</span>,</span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">     <span class="comment">//私有变量和私有函数</span></span><br><span class="line">     <span class="keyword">var</span> privateVariable = <span class="number">10</span>; </span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//创建对象</span></span><br><span class="line">     <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">     <span class="comment">//添加特权/公有属性和方法</span></span><br><span class="line">     object.publicProperty = <span class="literal">true</span>; </span><br><span class="line">     object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">         privateVariable++; </span><br><span class="line">         <span class="keyword">return</span> privateFunction(); </span><br><span class="line">         &#125;; </span><br><span class="line">     <span class="comment">//返回这个对象</span></span><br><span class="line">     <span class="keyword">return</span> object; </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 面向对象程序设计</title>
      <link href="/2020/02/28/%E7%AC%AC6%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2020/02/28/%E7%AC%AC6%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li>面向对象语言的标志是都有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。</li><li>而 ECMAScript 中没有类的概念，因此它的对象和基于类的语言中的对象有所不同。</li><li>ECMAscript 对象定义：<u>无序属性的集合，其属性可以包含基本值、对象或函数。</u></li><li>每个对象都是基于一个引用类型创建的。可以是原生类型，也可以是开发人员定义的类型。</li></ul><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><h5 id="属性数据"><a href="#属性数据" class="headerlink" title="属性数据"></a>属性数据</h5><ul><li><code>[[Configurable]]</code>:表示能否通过 delete 删除属性从而定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li><li><code>[[Enumerable]]</code>:表示能否通过 for-in 循环返回属性。</li><li><code>[[Writable]]</code>:表示能否修改属性的值。</li><li><code>[[Value]]</code>:包含设个属性的数据值。<blockquote><p><code>Object.defineProperty(属性所在对象，属性的名字，描述符对象)</code>：修改属性默认的特性</p></blockquote></li></ul><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><ul><li><code>[[Configurable]]</code>:表示能否通过 delete 删除属性从而定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li><li><code>[[Enumerable]]</code>:表示能否通过 for-in 循环返回属性。</li><li><code>[[Get]]</code>:在读取属性时调用的函数，默认值 <code>undefined</code>。</li><li><code>[[Set]]</code>:在写入属性时调用的函数，默认值 <code>undefined</code>。<blockquote><p>访问器属性不能直接定义，必须使用<code>Object.defineProperty()</code>来定义。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">     _year: <span class="number">2004</span>,</span><br><span class="line">     edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123; </span><br><span class="line">     <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="keyword">set</span>: function(newValue) &#123; </span><br><span class="line">     <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123; </span><br><span class="line">         <span class="keyword">this</span>._year = newValue; </span><br><span class="line">         <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>; </span><br><span class="line">alert(book.edition); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><ul><li><code>Object.defineProperties(对象，要添加和修改属性)</code> 通过描述赋一次定义多个属性<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3></li><li><code>Object.getOwnPropertyDescriptor(属性所在的对象，要读取其描述符的属性名称)</code>返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。</li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul><li>抽象了创建具体对象的过程<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3></li><li>定义在 Global 对象（浏览器即 window 对象）中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（this 就指向了这个新对象）</li><li>执行构造函数中的代码</li><li>返回新对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor == Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h5><ul><li>构造函数与其他函数唯一的区别是调用方式不同<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">person.sayName();</span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"><span class="built_in">window</span>.sayName();</span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">o.sayName();</span><br></pre></td></tr></table></figure></li></ul><h5 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h5><ul><li><p>每个方法都要在每个实例上重新创建一遍</p></li><li><p>不同实例上的同名函数是不相等的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> <span class="keyword">this</span>.age = age; </span><br><span class="line"> <span class="keyword">this</span>.job = job; </span><br><span class="line"> <span class="keyword">this</span>.sayName = sayName; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> alert(<span class="keyword">this</span>.name); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果需要很多方法，就需要定义很多全局函数</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3></li><li><p>每个函数都有 prototype（原型）属性</p><ul><li>是一个指针，指向一个对象<ul><li>对象包含所有实例共享的属性和方法</li><li>换句话说，prototype 就是通过调用构造函数而创建的对象实例的原型对象</li></ul></li></ul></li><li><p>好处</p><ul><li>让所有对象实例共享它所包含的属性和方法</li><li>不必在构造函数中定义对象实例的信息，而且将这些信息直接添加到原型对象中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Grey"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Doctor"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h5></li></ul></li><li><p>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象</p></li><li><p>默认情况下，所有原型对象会自动获得一个 constructor(构造函数) 属性，这个属性包含一个指向 prototype 属性所在函数（也就是构造函数）的指针</p></li><li><p><code>Person.prototype.constructor</code> 指向 <code>Person</code><br><img src="/.com//%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p></li><li><p>每个实例有一个<code>[[Prototype]]</code>（<code>__proto__</code>）属性，指向构造函数的原型对象</p></li><li><p><code>isPrototypeOf()</code>确定原型关系</p><ul><li><code>Person.prototype.isPrototypeOf(person)</code></li></ul></li><li><p><code>Object.getPrototypeOf()</code> 返回[[Prototype]] 的指针</p><ul><li><code>Object.getPrototypeOf(person) == Person.prototype</code></li></ul></li><li><p>在实例中修改属性值，会屏蔽原型中的同名属性</p><ul><li><code>delete person.name</code> 删除实例中的 name 属性，<code>console.log(person.name)</code> 将输出原型中的 name 属性 <code>Person.prototype.name</code></li></ul></li><li><p><code>hasOwnProperty()</code> 检测一个属性是否在实例中，false 来自原型</p></li></ul><h5 id="原型与-in-操作符"><a href="#原型与-in-操作符" class="headerlink" title="原型与 in 操作符"></a>原型与 in 操作符</h5><ul><li>单独使用<ul><li>属性 in 实例</li><li>无论属性在实例还是在原型，都返回 true</li></ul></li><li>for-in<ul><li>返回可枚举的（enumerated）属性</li><li>无论属性在实例还是在原型<blockquote><p><code>Object.keys(对象)</code> 返回所有可枚举属性名<br><code>Object.getOwnPropertyNames(对象)</code> 返回所有属性名</p></blockquote></li></ul></li></ul><h5 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Grey"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Doctor"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>字面量形式创建原型<ul><li><code>Person.prototype.constructor</code> 不再指向 Person</li><li>（前面说）每创建一个函数，就会同时创建它的 prototype 对象，这个对象自动获得 constructor 属性</li><li>这里完全重写了默认的 prototype 对象，constructor 属性指向 Object 构造函数<h5 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h5></li></ul></li><li>实例中的指针仅指向原型，而不指向构造函数</li><li>重写原型对象切断了现有原型与之前任何一件存在的对象实例直接的联系；对象实例引用的原型是重写之前的</li></ul><h5 id="原型模式的缺点"><a href="#原型模式的缺点" class="headerlink" title="原型模式的缺点"></a>原型模式的缺点</h5><p>如果原型包含引用类型值的属性，由于原型中的值是所有实例对象共享的，在一个实例对象中修改引用类型，会体现在别的实例对象中</p><h3 id="组合使用构造函数模型和原型模式"><a href="#组合使用构造函数模型和原型模式" class="headerlink" title="组合使用构造函数模型和原型模式"></a>组合使用构造函数模型和原型模式</h3><ul><li>构造函数模型用于定义实例属性</li><li>原型模式用于定义方法和共享属性</li></ul><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><ul><li><p>在构造函数中检查是否存在某个方法，再决定是否需要初始化原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3></li><li><p>不能用 instanceof</p></li><li><p>不推荐</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寄生构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3></li><li><p>稳妥对象</p><ul><li>没有公共属性，方法也不引用 this</li></ul></li><li><p>安全的环境中禁止使用 this 和 new</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只有 sayName() 能访问数据成员</p></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>面向对象语言中<ul><li>接口继承<ul><li>只继承方法签名</li></ul></li><li>实现继承<ul><li>继承实际的方法</li></ul></li></ul></li><li>ECMAScript 中函数没有签名，无法实现接口继承，故只支持实现继承<ul><li>依靠原型链<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3></li></ul></li><li>利用原型让一个引用类型继承另一个引用类型的属性和方法<blockquote><p>构造函数 A 和原型 A 都有一个指向原型对象 A 的指针，而原型对象 A 有一个指向构造函数 A 的指针。<br>让原型对象 A 等于另一个类型的实例 B。<br>此时原型对象 A（也就是实例 B）将包含一个指向原型对象 B 的指针，原型对象 B 中包含一个指向构造函数 B 的指针。<br>假如原型 B 又是另一个类型的实例 C，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。<br>这就是所谓原型链的基本概念。</p></blockquote></li></ul><h5 id="默认的原型"><a href="#默认的原型" class="headerlink" title="默认的原型"></a>默认的原型</h5><p>所有引用类型默认继承 Object，在原型链最后都是 Object 原型对象，包含一个指针指向 Object 构造函数。</p><h5 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h5><ul><li><code>实例 instanceof 构造函数</code> 实例的原型链中出现过构造函数就返回 true</li><li><code>原型对象.isPrototypeOf(实例)</code> 实例的原型链中出现过原型对象就返回 true</li></ul><h5 id="对象字面量创建原型方法会重写原型链"><a href="#对象字面量创建原型方法会重写原型链" class="headerlink" title="对象字面量创建原型方法会重写原型链"></a>对象字面量创建原型方法会重写原型链</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 导致上一行代码无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    getSubValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">    &#125;,</span><br><span class="line">    someOtherMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="原型链的缺点"><a href="#原型链的缺点" class="headerlink" title="原型链的缺点"></a>原型链的缺点</h5><ul><li>不能给超类型的构造函数传递参数<h3 id="借用构造函数（伪造对象-经典继承）"><a href="#借用构造函数（伪造对象-经典继承）" class="headerlink" title="借用构造函数（伪造对象/经典继承）"></a>借用构造函数（伪造对象/经典继承）</h3></li><li>在子类型构造函数的内部调用超类型构造函数（利用 call 或 apply）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承了 SuperType</span></span><br><span class="line">    SUperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以给超类型的构造函数传递参数<h3 id="组合继承（伪经典继承）"><a href="#组合继承（伪经典继承）" class="headerlink" title="组合继承（伪经典继承）"></a>组合继承（伪经典继承）</h3></li><li>最常用</li><li>组合原型链和借用构造函数</li><li>原型链实现对原型属性和方法的继承</li><li>借用构造函数实现对实例属性的继承</li><li>缺点<ul><li>调用两次超类型构造函数<ul><li>创建子类型原型</li><li>子类型构造函数内部</li></ul></li></ul></li></ul><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><ul><li><code>Object.create(作为新对象原型的对象， 作为新对象定义额外属性的对象)</code> 返回一个新对象</li></ul><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><ul><li>创建一个仅用于封装继承过程的函数，该<br>函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3></li><li>通过借用构造函数来继承属性</li><li>通过原型链的混成形式来继承方法</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 引用类型</title>
      <link href="/2020/02/22/%E7%AC%AC5%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/02/22/%E7%AC%AC5%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>引用类型</strong>是一种数据结构，用于将数据和功能组织在一起。</li><li>引用类型的值（对象）是引用类型的一个实例。</li><li><u>引用类型与类看起来相似，但并不相同。</u></li><li>ECMAScript 从技术上讲是一门面向对象的语言，但不具备传统的面向对象语言所支持的类和接口等基本结构。</li><li>引用类型也被称为<strong>对象定义</strong>，描述一类对象所具有的属性和方法。</li><li>ECMAScript 提供类很多原生引用类型（例如 Object）</li></ul><h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>大多数对象都是 Object 类型的实例</p><h6 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h6><ul><li>new 操作符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure></li><li>对象字面量<ul><li>对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义只包含默认属性和方法的对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><blockquote><p>通过对象字面量定义对象时，实际上不会调用 Object 构造函数<br>疑问：对象字面量是怎么定义对象的？</p></blockquote></li></ul></li></ul><h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>和其他语言的区别：每一项可以保存任何类型的数据，互相之间不影响</p><h6 id="创建实例-1"><a href="#创建实例-1" class="headerlink" title="创建实例"></a>创建实例</h6><ul><li>new<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>); <span class="comment">// length = 20</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Grey"</span>); <span class="comment">// length = 1</span></span><br></pre></td></tr></table></figure></li><li>省略 new<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// length = 3</span></span><br></pre></td></tr></table></figure></li><li>数组字面量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [];</span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br></pre></td></tr></table></figure><blockquote><p>数组字面量表示法时不会调用 Array 构造函数</p></blockquote></li></ul><hr><ul><li>length 可修改，会移除超出的项</li><li>当把一个值放在超出当前数组大小的位置上时，会重新计算长度，长度值为最后一项的索引 + 1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="comment">// ["red", "blue", "green"]</span></span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// ["red", "blue"]</span></span><br><span class="line">colors.length = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// ["red", "blue", empty]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// ["red", "blue", empty, "green"] length = 4</span></span><br></pre></td></tr></table></figure><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><code>value instanceof Array</code> 假定只有一个全局执行环境，如果从一个框架向另一个框架传入数组，就具有不同的构造函数<br><code>Array.isArray()</code><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3></li><li><code>Array.toString()</code></li><li><code>Array.toLocaleString()</code></li><li><code>Array.valueOf()</code><h3 id="栈-队列方法"><a href="#栈-队列方法" class="headerlink" title="栈/队列方法"></a>栈/队列方法</h3></li><li><code>Array.push</code> 末尾添加</li><li><code>Array.pop</code> 取最后一项并移除</li><li><code>Array.shift</code> 取第一项并移除</li><li><code>Array.unshift</code> 头部添加<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3></li><li><code>Array.reverse()</code> 反转顺序</li><li><code>Array.sort()</code> 先转 toString()，字符串升序<ul><li>sort 接收比较函数<ul><li>params1 -&gt; params2 ===&gt; -1</li><li>params2 -&gt; params1 ===&gt; 1<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3></li></ul></li></ul></li><li><code>Array.concat</code></li><li><code>Array.slice(a, b)</code> [a, b)<ul><li>负数则从末尾开始数</li></ul></li><li><code>Array.splice(a, b, ...c)</code><ul><li>a 位置</li><li>b 要删除的项数</li><li>c 插入的内容（若干）</li><li>return 被删除的内容</li></ul></li></ul><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>查找数组内容，<code>===</code>，返回下标</p><ul><li><code>Array.indexOf()</code></li><li><code>Array.lastIndexOf()</code><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3></li><li>两个参数<ul><li>要在每一项上运行的函数<ul><li>三个参数<ul><li>数组项的值</li><li>该项再数组中的位置</li><li>数组对象本身</li></ul></li></ul></li><li>（可选的）运行该函数的作用域对象<ul><li>影响this的值</li></ul></li></ul></li><li><code>Array.every()</code> 每一项都返回 true，则返回 true</li><li><code>Array.some()</code> 任一项返回 true，则返回 true</li><li><code>Array.filter()</code> 返回该函数返回 true 的项组成的数组</li><li><code>Array.map()</code> 返回每次函数调用的结果组成的数组</li><li><code>Array.forEach()</code> 没有返回值 </li></ul><p>以上方法都不回修改数组中包含的值</p><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><ul><li><p><code>Array.reduce()</code></p></li><li><p><code>Array.reduceRight()</code></p></li><li><p>两个参数</p><ul><li>每一项上调用的函数<ul><li>四个参数<ul><li>前一个值</li><li>当前值</li><li>项的索引</li><li>数组对象</li></ul></li></ul></li><li>（可选的）作为归并基础的初始值</li></ul></li><li><p>返回值作为第一个参数传给下一项</p></li><li><p>第一次迭代发生在第二项上，第一个参数是数组的第一项，第二个参数是数组的第二项</p></li></ul><h2 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h2><ul><li><code>Date.parse()</code> <ul><li>params: 表示日期字符串，格式因地区而异</li><li>return: 毫秒</li></ul></li><li><code>Date.UTC()</code><ul><li>params: 年份、月份（0开始）、天数、小时、分钟、秒、毫秒</li><li>return: 毫秒</li></ul></li><li><code>Date.now()</code><h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3></li><li><code>Date.toLocaleString()</code> 根据当地时区</li><li><code>Date.toString()</code> 带有时区信息</li><li><code>Date.valueOf()</code> 毫秒<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3></li><li><code>Date.toDateString()</code></li><li><code>Date.toTimeString()</code></li><li><code>Date.toLocaleDateString()</code></li><li><code>Date.toLocaleTimeString()</code></li><li><code>Date.toUTCString()</code></li><li><code>Date.toLocaleString()</code></li></ul><p>因浏览器而异</p><h2 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</span><br></pre></td></tr></table></figure><ul><li>pattern<ul><li>( [ { \ ^ $ | ) ? * + . ] } 需要转义</li></ul></li><li>flags<ul><li>g 全局，默认匹配第一个停止</li><li>i 不区分大小写</li><li>m 多行模式<h3 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h3></li></ul></li><li><code>global</code> </li><li><code>ignoreCase</code> </li><li><code>lastIndex</code> </li><li><code>multiline</code> </li><li><code>source</code> </li></ul><h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><ul><li><code>exec</code> </li><li><code>test</code> </li><li><code>toString</code> </li><li><code>toLocaleString</code> </li><li><code>valueOf</code> </li></ul><h3 id="构造函数属性"><a href="#构造函数属性" class="headerlink" title="构造函数属性"></a>构造函数属性</h3><p>其他语言中被看成是<strong>静态属性</strong></p><table><thead><tr><th>长属性名</th><th>短属性名</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>$_</td><td>最近一次要匹配的字符串</td></tr><tr><td>lastMatch</td><td>$&amp;</td><td>最近一次的匹配项</td></tr><tr><td>lastParen</td><td>$+</td><td>最近一次匹配的捕获组</td></tr><tr><td>leftContext</td><td>$`</td><td>input 字符串中 lastMatch 之前的文本</td></tr><tr><td>multiline</td><td>$*</td><td>布尔值，是否所有表达式都使用多行模式</td></tr><tr><td>rightContext</td><td>$’</td><td>input 字符串中 lastMatch 之后的文本</td></tr></tbody></table><h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><ul><li><p>每个函数都是 Function 类型的实例，具有属性和方法。</p></li><li><p>函数名是一个只想函数对象的指针，不会与某个函数绑定。</p><h5 id="创建实例-2"><a href="#创建实例-2" class="headerlink" title="创建实例"></a>创建实例</h5></li><li><p>函数声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>区别：<br>解析器会先读取函数声明，在执行任何代码之前可用（函数声明提升）<br>函数表达式要等解析器执行到它所在的代码行才会被解释执行</p></blockquote></li><li><p>Function 构造函数（不推荐）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>);</span><br></pre></td></tr></table></figure><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>声明两个同名函数，后面的函数覆盖前面的，结合 “函数是对象，函数名是指针” 很好理解。</p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3></li><li><p>函数名本身是变量，可以作为值来使用</p></li><li><p>可以作为参数，也可以作为返回值</p></li></ul><h3 id="函数的内部属性"><a href="#函数的内部属性" class="headerlink" title="函数的内部属性"></a>函数的内部属性</h3><ul><li><code>arguments</code> 类数组对象<ul><li><code>callee</code> 属性，该属性是一个指针，指向拥有这个 arguments 对象的函数</li></ul></li><li><code>this</code> 引用的是执行函数的环境对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sindow.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">// "red"</span></span><br><span class="line"></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();   <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure></li><li><code>caller</code> 调用当前函数的函数的引用，全局中调用当前函数则 null<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(inner.caller);</span><br><span class="line">    <span class="comment">// inner.callr 指向 outer()</span></span><br><span class="line">    <span class="comment">// 等价于 arguments.callee.caller</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3></li><li><code>length</code> 函数希望接收的命名参数的个数</li><li><code>prototype</code><ul><li>对引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，toString() 和 valueOf() 等方法都是保存在 prototype 名下，只是通过各自对象的实例访问。</li><li>不可枚举，for-in 无法发现。</li></ul></li></ul><p>每个函数都包含两个非继承而来的方法，都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。</p><ul><li><p><code>apply</code> </p><ul><li>两个参数<ul><li>在其中运行函数的作用域</li><li>参数数组</li></ul></li></ul></li><li><p><code>call</code> </p><ul><li>1 + n 个参数<ul><li>在其中运行函数的作用域</li><li>一个一个地传入参数</li></ul></li></ul></li><li><p><code>bind</code> 创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值</p></li></ul><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript 提供 3 个特殊的引用类型：<code>Boolean</code>、<code>Number</code>、<code>String</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"smoe.txt"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>基本类型不是对象，理论上不应该有方法。<br>当第二行代码访问 s1 时，访问过程处于一种读取模式，从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台自动完成：<br>(1) 创建 String 类型的一个实例<br>(2) 在实例上调用指定的方法<br>(3) 销毁这个实例</p></blockquote><ul><li>引用类型与基本包装类型的主要区别是对象的生存期<ul><li>引用类型的实例在执行流离开当前作用域之前一直保存在内存中</li><li>基本包装类型只存在于一行代码的执行瞬间</li></ul></li><li>可以显示的创建基本包装类型的对象，但会分不清自己在处理基本类型还是引用类型的值</li><li>new 调用基本包装类型的构造函数，和转型函数是不一样的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value); <span class="comment">// 转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number); <span class="comment">// "number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);     <span class="comment">// “object"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>布尔表达式中，所有的对象都会转为 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>产生误解，建议不要使用</p><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><ul><li><code>toString(n)</code> n 进制</li><li><code>toFixed(n)</code> 四舍五入 n 位小数</li><li><code>toExponential(n)</code> n 位数表示一个数字</li></ul><h4 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h4><ul><li><code>charAt</code></li><li><code>charCodeAt</code></li><li><code>方括号表示法[]下标读取字符</code></li></ul><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><ul><li><code>concat</code> 拼接字符串，常用<code>+</code></li><li><code>slice</code></li><li><code>substr</code></li><li><code>substring</code></li></ul><h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><ul><li><code>indexOf</code></li><li><code>lastIndexOf</code></li></ul><h4 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim() 方法"></a>trim() 方法</h4><p>创建一个字符串的副本，删除前置以及后缀的所有空格，然后返回结果</p><h4 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h4><ul><li><code>toLowerCase</code></li><li><code>toLocaleLowerCase</code></li><li><code>toUpperCase</code></li><li><code>toLocaleUpperCase</code></li></ul><h4 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h4><ul><li><code>match</code><ul><li>params:正则表达式或 RegExp 对象</li><li>本质调用 RegExp 的 exec</li></ul></li><li><code>search</code><ul><li>params:正则表达式或 RegExp 对象</li><li>return: 下标，找不到 -1</li></ul></li><li><code>replace</code> <ul><li>两个参数，用第二个参数替换第一个</li><li>第一个参数可以是正则</li><li>第二个参数可以是函数</li></ul></li><li><code>split</code> 基于一个制定的分隔符，将一个字符串分割成多个子字符串</li></ul><h4 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare() 方法"></a>localeCompare() 方法</h4><p>比较两个字符串，各地区实现不同</p><h4 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode() 方法"></a>fromCharCode() 方法</h4><p>接收一个或多个字符编码，然后转换成一个字符串</p><h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>ECMA-262对<strong>单体内置对象</strong>的定义：<u>由 ECMAScript 实现提供的，不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。</u></p><p>前面已经介绍了大多数内置对象，如 Object、Array、String</p><h3 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h3><ul><li>不属于任何其他对象的属性和方法，最终都是 Global 对象的属性和方法</li><li>事实上，没有全局变量或全局函数。所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。如<ul><li>isNan()、isFinite()、parseint()</li><li>encodeURI() 用于整个 URI<br>encodeURIEomponent() 用于 URI 中的一段<br>decodeURI()<br>decodeURIEomponent()</li><li>eval() 像一个完整的 ECMAScript 解析器<ul><li>params: 要执行的 ECMAScript 字符串</li></ul></li><li>Global 对象属性<ul><li>undefined、NaN、Infinity 等</li><li>Object、Function 等</li></ul></li><li>window 对象<ul><li>Web 浏览器中，Global 对象是 window 对象的一部分</li></ul></li></ul></li></ul><h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><ul><li>Math 对象的属性<ul><li>Math.E</li><li>Math.LN10</li><li>Math.LN2</li><li>Math.LOG2E</li><li>Math.LOG10</li><li>Math.PI</li><li>Math.SQRT1_2</li><li>Math.SQRT2</li></ul></li><li>min()、max()</li><li>舍入方法<ul><li>Math.ceil() 向上舍入</li><li>Math.floor() 向下舍入</li><li>Math.round() 四舍五入</li></ul></li><li>random() [0, 1) 随机数</li><li>其他方法<ul><li>Math.abs(num)</li><li>Math.exp(num)</li><li>Math.log(num)</li><li>Math.pow(num, power)</li><li>Math.sqrt(num)</li><li>Math.acos(x)</li><li>……</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 变量、作用域和内存问题</title>
      <link href="/2020/02/17/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/17/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><ul><li>基本数据类型（5）按值访问，可以操作保存在变量中的实际的值。占据固定大小的空间，被保存在栈内存中。</li><li>引用类型（1）的值是保存在内存中的对象，保存在堆内存中。JS 不能直接操作对象的内存空间：复制保存对象的某个变量时，操作对象的引用；为对象添加属性时，操作的是实际的对象。</li></ul><h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><ul><li>基本类型：创建新值</li><li>引用类型：创建新值，值是指针，实际与旧值引用同一个对象</li></ul><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript 中所有函数的参数都是按值传递的。</p><ul><li>基本类型：被传递的值会被复制给一个局部变量。</li><li>引用类型：被传递的值的<strong>地址</strong>复制给一个局部变量。因此这个局部变量的变化会反应在函数的外部。<blockquote><p>若在函数体内对这个局部变量进行重新赋值，那么保存的地址就改变了，指向的内存也不再是被传入的对象。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//“Nicholas”</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = <span class="string">"Greg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//“Nicholas”</span></span><br></pre></td></tr></table></figure><p>在内部重写 obj 时，变量引用的就是一个局部对象了。局部对象在函数执行完毕后立即被销毁。</p><h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><ul><li>基本类型：<code>typeof</code></li><li>引用类型：<code>instanceof</code></li><li>根据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result = variable instanceof constructor</span></span><br><span class="line"><span class="comment">// 根据原型链来识别</span></span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>);</span><br></pre></td></tr></table></figure>所有引用类型的值都是 Object 的实例。<code>Obj instanceof Object</code> 始终返回 true，检测基本类型始终 false，因为基本类型不是对象。</li></ul><h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><ul><li>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</li><li>每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的所有变量和函数都保存在这个对象中。</li><li><strong>全局执行环境</strong>：根据宿主环境。WEB 浏览器中是 window 对象。</li><li><strong>执行环境</strong>，函数的环境，保存在栈中。</li><li>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，<u>保证对执行环境有权访问的所有变量和函数的有序访问。</u><blockquote><p>作用域链的前端，始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>作为变量对象。活动对象在最开始时只包含一个变量（即arguments对象，全局环境中不存在）。下一个变量对象来自包含（外部）环境……一直到全局执行环境。<br>标识符解析是沿着作用域链一级一级地搜索标识符的过程。<br>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境重的变量和函数。</p></blockquote></li></ul><h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><ul><li>try-catch 语句的 catch 块</li><li>with 语句<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</span><br><span class="line">    <span class="keyword">with</span> (location) &#123;</span><br><span class="line">        <span class="keyword">var</span> url = href + qs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>with 语句接收 location 对象，因此其变量对象中包含了 location 对象的所有属性和方法，而这个变量被添加到了作用域链的前端。<blockquote><p>疑问：<br>作用域链：全局执行环境-&gt;buildUrl()-&gt;with(location)<br>with 中定义的变量 url 为什么能够在外部环境 buildUrl 中访问？url是被定义在全局执行环境中的 location 变量对象中吗？</p><hr><p>因为没有块级作用域，变量声明会被添加到当前的执行环境（这里是buildUrl（））中</p></blockquote></li></ul><h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(color);</span><br></pre></td></tr></table></figure><p>js 中，if 语句中的变量声明会将变量添加到当前的执行环境（这里是全局环境）<br>如果没有用 var 声明，会直接被添加到全局环境。</p><blockquote><p>let 似乎解决了这个问题，本书没有讲到，看完 es6 再来补。</p></blockquote><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><ul><li>当变量进入环境，标记为“进入环境”。<ul><li>逻辑上讲，永远不能释放进入环境的变量所占用的内存。</li></ul></li><li>当变量离开环境时，则标记“离开环境”。</li><li>可以使用任何方式来标记变量。如：<ul><li>翻转某个特殊的位</li><li>“进入环境”变量列表及“离开环境”变量列表<blockquote><p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后再被加上标记的变量将被视为准备删除的变量。最后完成内存清除工作，销毁值并回收内存空间。</p></blockquote></li></ul></li></ul><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>跟踪记录每个值被引用的次数，赋值给变量则该值+1，若变量取得另一个值，则该值-1。</p><blockquote><p>垃圾收集器下次运行时，释放计数 0 的值占用的内存。</p></blockquote><blockquote><p>循环引用会导致引用次数永远不为 0<br>BOM 和 DOM 中的对象是使用 C++ 以 COM（Component Object Model，组件对象模型）对象的形式实现的，COM 对象的垃圾收集机制就是引用计数策略。<br>解决：手动断开循环引用（赋值为null）</p></blockquote><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>垃圾收集器是周期运行的，如果为变量分配的内存数量很大，那么回收工作量也相当大，确定时间间隔很重要。</p><h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>使用具备垃圾收集机制的语言编写程序，一般不必操心内存管理。但 js 比较特殊，因为分配给 Web 浏览器的可用内存通常比桌面应用少。<br>尽量少用内存页面会有更好的性能。一旦数据不再有用，赋值 null 来<strong>解除引用</strong>。适用于大多数全局变量和全局对象的属性，局部变量会在离开执行环境时自动解除。<br>解除引用不是自动回收内存，是让值脱离环境，垃圾收集器下次运行的时候将其回收。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 基本概念</title>
      <link href="/2020/02/15/%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/02/15/%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>ECMAScript 标示符采用驼峰大小写格式</p><h3 id="严格模式-strict-mode"><a href="#严格模式-strict-mode" class="headerlink" title="严格模式 strict mode"></a>严格模式 strict mode</h3><p>在顶部添加代码 <code>&quot;use strict&quot;;</code><br>编译指示(pragma)，用于告诉支持的 JavaScript 引擎切换到严格模式。<br>函数体中包含指定函数在严格模式下执行。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>松散类型：可以用来保存任何类型的数据。每个变量仅仅用于保存值的占位符。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>5 基本数据类型 - <code>Undefined、Null、Boolean、Number、String</code><br>1 复杂数据类型 - <code>Object</code><br><code>Oobject</code> 本质上是由一组无序的名值对组成的<br>ECMAScript 不支持任何创建自定义类型的机制</p><p><code>typeof</code> 操作符，返回值（均为字符串）<br>未定义：<code>&quot;undefined&quot;</code><br>布尔值：<code>&quot;boolean&quot;</code><br>字符串：<code>&quot;string&quot;</code><br>数值：<code>&quot;number&quot;</code><br>对象或<code>null</code>：<code>&quot;object&quot;</code><br>函数：<code>&quot;function&quot;</code><br>特殊值 <code>null</code> 被认为是一个空的对象引用，因此返回 <code>&quot;object&quot;</code>。<br>safari 5 和 Chrome 7 及之前版本 <code>typeof 正则表达式</code> 会返回 <code>&quot;function&quot;</code>，而其他浏览器返回<code>&quot;object&quot;</code></p><blockquote><p>从技术角度讲，函数在 ECMAScript 中是对象，而不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 <code>typeof</code> 操作符区分函数和其他对象是有必要的。</p></blockquote><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><p><code>Undefined</code> 类型只有一个值，即 <code>undefined</code></p><blockquote><p>变量已声明但未初始化（message）：该变量的值为 <code>undefined</code>,<code>typeof</code> 返回<code>&quot;undefined&quot;</code><br>若变量未声明（age）：只可以执行<code>typeof</code> 操作符，返回<code>&quot;undefined&quot;</code>，其他操作产生错误。</p><p> <img src="/.com//%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="变量初始化"></p></blockquote><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h3><p><code>Null</code> 类型只有一个值，即 <code>null</code>，表示一个空对象指针，因此 <code>typeof null</code> 返回 <code>&quot;object&quot;</code>。<br>如果定义的变量准备用于保存对象，那么最好初始化为 <code>null</code>，可以直接判断是否已经保存了一个对象的引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>) &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，<code>undefined</code> 派生自 <code>null</code>，因此：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>); </span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。调用 <code>转型函数 Boolean()</code> 获得对应 Boolean 值。</p><table><thead><tr><th>数据类型</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>任何非空字符串</td><td>“”（空字符串）</td></tr><tr><td>Number</td><td>任何非零数字值（包括无穷大）</td><td>0 和 NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>N/A</td><td>undefined</td></tr><tr><td>N/A：not applicable 的缩写，不适用</td><td></td><td></td></tr></tbody></table><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>使用 <a href="https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin" target="_blank" rel="noopener">IEEE754</a> 格式来表示整数和浮点数值（双精度数值）。<br>为了支持各种数值类型，ECMA-262定义了不同的数值字面量格式。</p><ul><li>十进制</li><li>八进制（0）</li><li>十六进制（0x）<br>在进行算数计算时，都会转为十进制数值。<h5 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h5>浮点数值需要的内存空间是整数值的两倍。<br>6 个 0 以上，e表示法：3.125e7、3e-17<br>浮点数值最高精度 17 位小数，但在算数计算时精度远不如整数。<img src="/.com//%E7%B2%BE%E5%BA%A6.png" alt="精度"><br>（IEEE745 数值的浮点计算通病，不是 ECMAScript 独有）</li></ul><h5 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h5><p><code>Number.MIN_VALUE</code> 5e-324<br><code>Number.MAX_VALUE</code> 1.7976931348623157e+308<br><code>Number.POSITIVE_INFINITY</code> 或 <code>Infinity</code> 正无穷<br><code>Number.NEGATIVE_INFINITY</code> 或 <code>-Infinity</code> 负无穷<br><code>isFinite()</code>有穷返回 <code>true</code></p><h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><ul><li>任何涉及 NaN 的操作都会返回 NaN</li><li>NaN 与任何值都不相等，包括自己本身</li><li><code>isNaN()</code> 函数判断变量是否<strong>可以转为数值</strong></li></ul><blockquote><p>isNaN(object):<br>首先调用对象的 valueOf() 方法，检查该方法的返回值是否可以转换为数值<br>如果不能，基于这个返回值再调用 toString() 方法，再测试返回值。</p></blockquote><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><p><code>Number()</code> 任何类型<br><code>parseInt()</code> 字符串<br><code>parseFloat()</code> 字符串</p><blockquote><p>parseInt 和 parseFloat 从第一个符合条件的字符开始转换，开始后若碰到不符合的字符，抛弃之后的字符。</p></blockquote><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><ul><li>Unicode 字符组成的字符序列。</li><li>ECMAScript 中双引号/单引号没有区别。</li></ul><h5 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h5><p>字符字面量，即转义字符，被作为一个字符来解析。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>不可改变<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">"Java"</span>;</span><br><span class="line">lang = lang + <span class="string">"Script"</span>;</span><br><span class="line"><span class="comment">// 首先创建一个能容纳 10 个字符的新字符串，然后填充 “Java” 和 “Script”，最后销毁原来的字符串。（不在原字符串上修改）</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="转为字符串"><a href="#转为字符串" class="headerlink" title="转为字符串"></a>转为字符串</h5><ul><li><p><code>toString()</code> 几乎每个值都有这个方法，<code>null</code> 和 <code>undefined</code> 值没有。</p><ul><li>通常不需要参数。</li><li>调用数值的 <code>toString()</code> 方法时可以传递进制基数作为参数。</li></ul></li><li><p>不知道是不是 <code>null</code> 或 <code>undefined</code> 的时候可以使用转型函数 <code>String()</code></p><ul><li>如果值有 <code>toString()</code> 方法，调用</li><li>如果值是 <code>null</code>，返回 <code>&quot;null&quot;</code></li><li>如果值是 <code>undefined</code>，返回 <code>&quot;undefined&quot;</code></li></ul></li><li><p><code>obj + &quot;&quot;</code> 和字符串加在一起</p></li></ul><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><ul><li>对象是一组数据和功能的集合。<blockquote><p>在 ECMAScript 中，<code>Object</code> 类型所具有的任何属性和方法也同样存在于更具体的对象中。<br><code>Object</code> 的每个实例都具有下列属性和方法。</p></blockquote></li><li><code>Constructor</code> 构造函数</li><li><code>hasOwnProperty(propertyName)</code> 检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。参数（propertyName）为字符串</li><li><code>isProtorypeOf(object)</code> 检查传入的对象是否是另一个对象的原型</li><li><code>propertyIsEnumerable(propertyName)</code> 检查给定的属性是否能够使用 for-in 语句。参数（propertyName）为字符串</li><li><code>toLocaleString()</code> 根据本地规范进行格式化</li><li><code>toString()</code> </li><li><code>valueOf()</code> 通常自动调用</li></ul><blockquote><p>从技术角度讲，ECMA-262 中对象的行为不一定适用于 JS 中的其他对象。如 BOM 和 DOM 中的对象属于宿主对象，宿主对象可能会也可能不会继承 Object。</p></blockquote><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符应用于对象时，通常会调用对象的 <code>valueOf()</code> 和（或）<code>toString()</code> 方法。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>枚举对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性没有顺序，所以先后顺序因浏览器而异。</p><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>类似 go to 不建议使用</p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>简化多次编写同一个对象的工作<br>大量使用 with 会导致性能下降，不建议使用</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>比较值时使用全等 <code>===</code></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>未指定返回值的函数返回 <code>undefined</code></p><blockquote><p>函数要么始终返回一个值，要么永远都不要返回值。</p></blockquote><h3 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h3><ul><li>函数体内通过 arguments 对象来访问参数数组。</li><li>ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。<blockquote><p>详看第四章 —— 传递参数</p></blockquote></li></ul><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>不存在函数签名的特性，ECMAScript 函数不能重载<br>定义两个名字相同的函数，会被后面定义的函数覆盖</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 在 HTML 中使用 JavaScript</title>
      <link href="/2020/02/09/%E7%AC%AC2%E7%AB%A0-%E5%9C%A8%20HTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20JavaScript/"/>
      <url>/2020/02/09/%E7%AC%AC2%E7%AB%A0-%E5%9C%A8%20HTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20JavaScript/</url>
      
        <content type="html"><![CDATA[<h2 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a><code>script</code>元素</h2><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li><p>src 可选。包含要执行代码的外部文件。</p><blockquote><p>如果有 src，标签内嵌入的 JavaScript 代码会被忽略<br>可以包含来自外部域的 JavaScript 文件。这点与 <code>img</code> 相同</p></blockquote></li><li><p>async 可选。立即下载脚本，但不妨碍页面中其他操作。只对外部脚本文件有效。<strong>不能保证按顺序执行。不要修改 DOM 会在load 事件前执行，可能会在 <code>DOMContentLoaded</code> 事件触发之前或之后执行。</strong></p></li><li><p>defer 可选。延迟到文档完全被解析和显示之后（<code>/html</code>标签后）执行。<strong>只对外部脚本文件有效。</strong>（嵌入脚本的 defer 属性会被忽略）<strong>延迟脚本不一定会按照顺序执行，也不一定会在 <code>DOMContentLoaded</code> 事件触发前执行，因此最好只有一个延迟脚本。</strong></p><blockquote><p>只要不存在 defer 和 async 属性，浏览器都会按照 <code>scrip</code> 元素在页面中出现的先后顺序进行解析</p></blockquote></li></ul><ul><li>type 可选。language（已废弃）的替代属性；脚本语言的内容类型（MIME 类型）。默认值 text/javascript<blockquote><p>不推荐 text/javascript 和 text/ecmascript<br>服务器在传送 JavaScript 文件时使用的 MIME 类型通常是 application/x-javascript<br>非 IE 浏览器中可以使用 application/javascript 和 application/ecmascript</p></blockquote></li><li>charset 可选。表示通过 src 属性指定代码的字符集。大多数浏览器忽略</li></ul><h3 id="标签的位置"><a href="#标签的位置" class="headerlink" title="标签的位置"></a>标签的位置</h3><p>放在 <code>head</code> 中必须先把 js 代码下载、解析和执行完成后才能开始呈现页面内容，此时页面空白。<br>把 js 引用放在 <code>body</code> 中，空白时间会缩短。<br>或者设置 defer 属性，立即下载，延迟（<code>/html</code>标签后）执行。</p><h2 id="外部文件的优点"><a href="#外部文件的优点" class="headerlink" title="外部文件的优点"></a>外部文件的优点</h2><ul><li>可维护性：集中精力编辑 js 代码</li><li>可缓存：如果两个页面使用同一个文件，只需下载一次</li><li>适应未来</li></ul><h2 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h2><p><code>!DOCTYPE html</code></p><h2 id="noscript元素"><a href="#noscript元素" class="headerlink" title="noscript元素"></a><code>noscript</code>元素</h2><ul><li>浏览器不支持脚本</li><li>浏览器支持脚本，但脚本被禁用<br>符合上述条件，元素内容会被显示。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 JavaScript 简介</title>
      <link href="/2020/01/16/%E7%AC%AC1%E7%AB%A0-JavaScript%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/01/16/%E7%AC%AC1%E7%AB%A0-JavaScript%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>ECMA-262——定义一种名为 ECMAScript 的新脚本语言的标准<br>浏览器开发商将 ECMAScript 作为各自 JavaScript 实现的基础</p><blockquote><p>JavaScript 包括：</p><ul><li>核心： ECMAScript</li><li>文档对象模型： DOM</li><li>浏览器对象模型： BOM</li></ul></blockquote><h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><ul><li>没有输入和输出定义</li><li>ECMA-262 定义了 ECMAScript 基础，在此基础上可以构建更完善的脚本语言</li><li>宿主环境提供基本的 ECMAScript 实现，也提供该语言的拓展，以便语言和环境之间对接交互</li></ul><p>ECMA-262 标准规定了</p><ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>对象<br>ECMAScript 就是对实现该标准规定的各个方面内容的语言的描述<br>JavaScript 实现了 ECMAScript<br>Adobe ActionScript 也实现了 ECMAScript<h6 id="什么是-ECMAScript-兼容"><a href="#什么是-ECMAScript-兼容" class="headerlink" title="什么是 ECMAScript 兼容"></a>什么是 ECMAScript 兼容</h6><blockquote><p>要想成为 ECMAScript 的实现，必须做到：</p><ul><li>支持 ECMA-262 描述的所有“类型、值、对象、属性、函数以及程序语法和语义”</li><li>支持 Unicode 字符标准</li><li>可以进行拓展：<ul><li>添加 ECMA-262 没有描述的“更多类型、值、对象、属性和函数”。主要指新对象和对象的新属性</li><li>支持 ECMA-262 没有定义的“程序和正则表达式语法”。即可以修改和拓展内置的正则表达式语法</li></ul></li></ul><p>为开发人员基于 ECMAScript 开发一门新语言提供了广阔的空间和极大的灵活性</p></blockquote></li></ul><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM（Document Object Model）是针对 XML 但经过拓展用于 HTML 的 API（Application Programming Interface）</p><ul><li>W3C 制定了 DOM 标准</li><li>DOM 不止针对 JavaScript，很多别的语言也实现了 DOM</li><li>DOM 包括 DOM 核心和 DOM HTML<ul><li>DOM 核心规定如何映射基于 XML 的文档结构</li><li>DOM HTML 模块则在 DOM 核心 的基础上添加了针对 HTML 的对象和方法</li></ul></li></ul><p>除了 DOM 核心和 DOMHTML 接口之外，另外几种语言发布了只针对自己的 DOM 标准。以下语言都是基于 XML 的，每种语言的 DOM 标准都添加了与特定语言相关的新方法和新接口：</p><ul><li>SVG(Scalable Vector Graphic)</li><li>MathML（Mathematical Markup Language）</li><li>SMIL（Synchronized Multimedia Integration Language）<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3>开发人员使用 BOM（Browser Object Model）控制浏览器显示的页面以外的部分<br>BOM 作为 JavaScript 实现的一部分却没有相关的标准。H5 致力于把很多 BOM 功能写入正式规范。<br>根本上讲，BOM 只处理浏览器窗口和框架；但习惯上把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
