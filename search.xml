<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Iterator和for...of循环</title>
      <link href="/2020/03/22/17-Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/"/>
      <url>/2020/03/22/17-Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Iterator-和-for…of-循环"><a href="#Iterator-和-for…of-循环" class="headerlink" title="Iterator 和 for…of 循环"></a>Iterator 和 for…of 循环</h1><h2 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h2><ul><li><p>JS 原来表示”集合”的是数组 <code>Array</code> 和对象 <code>Object</code>，ES6 添加了 <code>Map</code> 和 <code>Set</code></p></li><li><p>Iterator 是一种接口，任何数据结构只要部署 Iterator 接口，就可以完成便利操作（即依次处理该数据结构的所有成员）</p></li><li><p>Iterator 作用：</p><ul><li>为各种数据结构提供统一的、简便的访问接口</li><li>使数据结构的成员能够按某种次序排列</li><li>ES6 创造了新的遍历命令 <code>for...of</code> </li></ul></li><li><p>遍历过程</p><ul><li><p>创建指针对象，指向当前数据结构的起始位置</p><ul><li><p>遍历对象本质上是一个指针对象</p></li><li><blockquote><p>js 有指针的概念？</p></blockquote></li></ul></li><li><p>第一次调用指针对象的 <code>next</code> 方法，可以将指针指向数据结构的第一个成员</p></li><li><p>不断调用指针对象的 <code>next</code> 方法，直到它指向数据结构的结束位置</p></li></ul></li><li><p>每次调用 <code>next</code> 返回一个包含 <code>value</code> he <code>done</code> 两个属性的对象。</p><ul><li><code>value</code> 属性是当前成员的值</li><li><code>done</code> 属性是一个布尔值，表示遍历是否结束</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line">it.next();</span><br><span class="line">it.next();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; : &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h2><ul><li>当使用 <code>for...of</code> 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口</li><li>ES6 规定，默认的 Iterator 接口部署在数据结构的 <code>Symbol.iterator</code> 属性，或者说，一个数据结构只要有 <code>Symbol.iterator</code> 属性，就认为是可遍历的<ul><li><code>Symbol.iterator</code> 属性本身是一个函数，就是当前数据结构默认的遍历器生产函数</li><li>执行这个函数，就会返回一个遍历器</li><li>属性名 <code>Symbol.iterator</code> 是一个表达式，返回 <code>Symbol</code> 对象的 <code>iterator</code> 属性</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: <span class="number">1</span>,</span><br><span class="line">          done: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>原生具备 Iterator 接口的数据结构：<ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul></li></ul><blockquote><p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p></blockquote><h2 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h2><ul><li>数组和 Set 结构进行解构赋值时，默认调用 <code>Symbol.iterator</code> 方法</li><li>扩展运算符 <code>...</code><ul><li>部署了 Iterator 接口的数据结构都能用扩展运算符</li></ul></li><li>yield* 后面跟的是一个可遍历的解构，它会调用该结构的遍历器接口</li><li>数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，都调用了遍历器<ul><li>for … of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()</li><li>Promise.all()</li><li>Promise.race()</li></ul></li></ul><h2 id="Iterator-接口与-Generator-函数"><a href="#Iterator-接口与-Generator-函数" class="headerlink" title="Iterator 接口与 Generator 函数"></a>Iterator 接口与 Generator 函数</h2><ul><li><code>Symbol.iterator</code> 方法的最简单实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "hello"</span></span><br><span class="line"><span class="comment">// "world"</span></span><br></pre></td></tr></table></figure><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><ul><li>数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员</li><li>也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法</li><li><code>for...of</code>循环可以使用的范围<ul><li>数组</li><li>Set </li><li>Map </li><li>某些类似数组的对象<ul><li><code>arguments</code>对象</li><li>DOM NodeList 对象</li></ul></li><li>Generator 对象</li><li>字符串</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set和Map数据结构</title>
      <link href="/2020/03/22/13-Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/03/22/13-Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>类似于数组，但成员的值都是唯一的<ul><li>不会发生类型转换，所以 5 和 “5” 不同</li><li>两个 NaN 是相等的，这和 <code>===</code> 不同</li><li>两个对象总是不想等</li></ul></li><li><code>Set</code> 构造函数可以接受一个数组（或具有 iterable 接口的其他数据结构）作为参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><blockquote><p>Array.from 可以将 Set 结构转为数组</p></blockquote><h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><ul><li><p>属性</p><ul><li><code>Set.prototype.constructor</code> 构造函数</li><li><code>Set.prototype.size</code> 返回 <code>Set</code> 实例的成员总数</li></ul></li><li><p>方法</p><ul><li><p>操作方法</p><ul><li><code>Set.prototype.add(value)</code> 添加某个值，返回 Set 结构本身</li><li><code>Set.prototype.delete(value)</code> 删除某个值，返回布尔表示是否成功</li><li><code>Set.prototype.has(value)</code> 返回布尔值，表示是否为 <code>Set</code> 成员</li><li><code>Set.prototype.clear(value)</code>清空，没有返回值</li></ul></li><li><p>遍历方法</p><ul><li><p><code>Set.prototype.keys()</code> 返回键名，遍历器对象</p></li><li><p><code>Set.prototype.values()</code> 返回键值，遍历器对象</p><blockquote><p>Set 结构没有键名，只有键值（或者说键名键值都是同一个值），所以 keys 方法和 values 方法一样</p></blockquote></li><li><p><code>Set.prototype.entries()</code> 返回键值对，遍历器对象</p></li><li><p><code>Set.prototype.forEach()</code> 使用回调函数遍历每个成员</p></li></ul></li></ul></li></ul><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><ul><li>类似 Set</li><li>成员只能是对象<ul><li>弱引用，垃圾回收机制不考虑 WeakSet 的引用，可能会随时被清空</li></ul></li><li>不可遍历</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>类似于对象，是键值对的集合</li><li>对象的键只能是字符串，Map 的键不限制类型</li><li><code>Map</code> 构造函数可接受数组，数组成员表示一个键值对（任何具有 Iterator 接口，且每个成员都是一个双元素的数组的数据结构，例如 Set 和 Map）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'zhangsan'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 实际上执行</span></span><br><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'zhangsan'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">items.forEach(</span><br><span class="line">([key, value]) =&gt; map.set(key, value)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>多次赋值一个键，会覆盖</li><li>读取一个未知的键，返回 <code>undefined</code></li><li>对于对象，地址相同 Map 结构才视为同一个键</li><li>对于简单类型，值严格相等 <code>===</code> 就是一个键</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">'a'</span>]) <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">// ['a'] 是实例，这里两个实例 ['a'] 内存地址不同</span></span><br></pre></td></tr></table></figure><h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><ul><li>属性<ul><li><code>size</code></li></ul></li><li>方法<ul><li>操作方法<ul><li><code>Map.prototype.set(key, value)</code><ul><li>返回当前 <code>Map</code> 对象，可以采用链式写法</li></ul></li><li><code>Map.prototype.get(key)</code></li><li><code>Map.prototype.has(key)</code></li><li><code>Map.prototype.delete(key)</code></li><li><code>Map.prototype.clear(key)</code></li></ul></li><li>遍历方法<ul><li><code>Map.prototype.keys()</code></li><li><code>Map.prototype.values()</code></li><li><code>Map.prototype.entries()</code></li><li><code>Map.prototype.forEach()</code></li></ul></li></ul></li><li>Map 本身没有 <code>map</code> 和 <code>filter</code> 方法，需要结合数组</li></ul><h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><ul><li><p>Map -&gt; 数组</p><ul><li><code>[...map]</code></li></ul></li><li><p>数组 -&gt; Map</p><ul><li><code>new Map(array)</code></li></ul></li><li><p>Map -&gt; 对象</p></li><li><p>对象 -&gt; Map</p></li><li><p>Map -&gt; JSON</p></li><li><p>JSON -&gt; Map</p></li></ul><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><ul><li>类似 Map</li><li>键名只能对象（除了 null）</li><li>指向的对象不计入垃圾回收机制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Generator函数的语法</title>
      <link href="/2020/03/21/18-Generator%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/03/21/18-Generator%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Generator-函数的语法"><a href="#Generator-函数的语法" class="headerlink" title="Generator 函数的语法"></a>Generator 函数的语法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>异步编程解决方案，语法行为与传统函数完全不同</li><li>理解<ul><li>语法上，Generator 函数是一个状态机，封装了多个内部状态<ul><li>执行 Generator 函数会返回一个遍历器对象<ul><li>遍历器对象可以依次遍历 Generator 函数内部的每一个状态</li></ul></li></ul></li><li>形式上，Generator 函数是一个普通函数<ul><li>两个特征<ul><li><code>function</code> 关键字与函数名之间有一个星号，星号位置和空格位置的先后关系没有规定</li><li>函数体内部使用 <code>yield</code> 表达式，定义不同的内部状态</li></ul></li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三个状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line"><span class="comment">// 调用</span></span><br></pre></td></tr></table></figure><ul><li>调用 Generator 函数后，该函数并不执行，返回一个指向内部状态的指针对象（iterator Object）</li><li>调用遍历器对象的 <code>next</code> 方法，使得指针移向下一个状态<ul><li>也就是说，每次调用 <code>next</code> 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 <code>yield</code> 表达式（或 <code>return</code> 语句）</li><li>换言之，Generator 函数是分段执行的，<code>yield</code> 表达式是暂停执行的标记，<code>next</code> 方法恢复执行</li></ul></li><li><code>next</code> 返回一个对象<ul><li>属性 <code>value</code> 是当前 <code>yield</code> 表达式的值</li><li>属性 <code>done</code> 表示遍历是否结束</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h3><ul><li><code>next</code> 方法的运行逻辑<ul><li>遇到 <code>yield</code> 表达式，就暂停执行，并将紧跟在 <code>yield</code> 后面的表达式的值作为对象的 <code>value</code> 属性返回</li><li>下次调用 <code>yield</code> 时，再继续往下执行，直到遇到下一个 <code>yield</code> 表达式</li><li>如果没有遇到新的表达式，就一直运行到 <code>return</code>，并将 <code>return</code> 语句后面的表达式的值作为对象的 <code>value</code> 属性</li><li>如果没有<code>return</code> 语句，则返回对象的 <code>value</code> 属性值为 <code>undefined</code></li></ul></li><li><code>yield</code> 表达式后面的表达式，只有调用 <code>next</code> 方法、内部指针指向该语句时才会执行<ul><li>给 JavaScript 提供了手动<strong>惰性求值</strong>的语法功能</li></ul></li><li>不用 <code>yield</code> 的情况下，Generator 就是一个单纯的暂缓执行函数</li><li><code>yield</code> 只能用在 Generator 函数里面，其它地方会报错</li><li><code>yield</code> 如果用在另一个表达式中，必须放在括号里面</li><li><code>yield</code> 用做函数参数或放在赋值表达式右边，不用括号</li></ul><h2 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h2><blockquote><p>这节没看懂</p></blockquote><ul><li><code>yield</code> 表达式本身没有返回值，或者说总是返回 <code>undefined</code></li><li><code>next</code> 方法可以带一个参数，该参数会被当作上一个 <code>yield</code> 表达式的返回值</li></ul><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><ul><li><code>for...of</code> 循环自动遍历 Generator 函数运行时生成的 <code>Iterator</code> 对象，此时不需要调用 <code>next</code> 方法</li><li>斐波那契</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">yield</span> curr;</span><br><span class="line">    [prev, curr] = [curr, prev + curr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> fibonacci()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h2><ul><li><code>throw</code> 方法可以在函数体外抛出错误，在函数体内捕获<ul><li>前提是必须进行过一次 <code>next</code> 方法</li><li>捕获后会自动执行一次 <code>next</code> 方法，不影响下次遍历</li></ul></li><li>如果 Generator 函数内部没有部署 <code>try...catch</code> 代码块，那么错误会被外部的 <code>try...catch</code> 代码块捕获</li><li>如果都没有，那么程序将报错，直接中断执行</li></ul><h2 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h2><ul><li>返回给定的值，并终结遍历 Generator 函数</li></ul><h2 id="next-、throw-、return-的共同点"><a href="#next-、throw-、return-的共同点" class="headerlink" title="next()、throw()、return() 的共同点"></a>next()、throw()、return() 的共同点</h2><ul><li>作用都是让 Generator 函数恢复执行，使用不同的语句替换 <code>yield</code> 表达式</li><li><code>next()</code> 是将 <code>yield</code> 表达式替换成一个值</li><li><code>throw()</code> 是将 <code>yield</code> 表达式替换成一个 <code>throw</code> 语句</li><li><code>return()</code> 是将 <code>yield</code> 表达式替换成一个 <code>return</code> 语句</li></ul><h2 id="yield-表达式-1"><a href="#yield-表达式-1" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h2><ul><li>在一个 Generator 函数里面执行另一个 Generator 函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "x"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// "y"</span></span><br></pre></td></tr></table></figure><ul><li>从语法角度看，如果<code>yield</code>表达式后面跟的是一个遍历器对象，需要在<code>yield</code>表达式后面加上星号，就会执行这个遍历器</li><li>任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历</li></ul><h2 id="作为对象属性的-Generator-函数"><a href="#作为对象属性的-Generator-函数" class="headerlink" title="作为对象属性的 Generator 函数"></a>作为对象属性的 Generator 函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async函数</title>
      <link href="/2020/03/21/20-async%E5%87%BD%E6%95%B0/"/>
      <url>/2020/03/21/20-async%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><ul><li>async 使异步操作变得更加方便</li><li>Generator 的语法糖</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h2 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="headerlink" title="async 函数的实现原理"></a>async 函数的实现原理</h2><h2 id="与其他异步处理方法的比较"><a href="#与其他异步处理方法的比较" class="headerlink" title="与其他异步处理方法的比较"></a>与其他异步处理方法的比较</h2><h2 id="实例：按顺序完成异步操作"><a href="#实例：按顺序完成异步操作" class="headerlink" title="实例：按顺序完成异步操作"></a>实例：按顺序完成异步操作</h2><h2 id="顶层-await"><a href="#顶层-await" class="headerlink" title="顶层 await"></a>顶层 await</h2>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise对象</title>
      <link href="/2020/03/21/16-Promise%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/21/16-Promise%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><h2 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h2><ul><li>异步编程的一种解决方案，比传统的解决方案更合理和更强大<ul><li>传统的解决方案：回调函数和事件</li></ul></li><li>Promise 简单说就是一个容器，保存着某个未来才会结束的事件（通常是一个异步操作）的结果</li><li>从语法上说，Promise 是一个对象，可以获取异步操作的消息</li><li>特点：<ul><li>对象状态不受外界影响<ul><li>Promise 对象代表一个异步操作，有三种状态<ul><li>pending 进行中</li><li>fulfilled 已成功</li><li>rejected 已失败</li></ul></li><li>只有异步操作的结果才能改变状态</li></ul></li><li>一旦状态改变，就不会再改变，任何时候都可以得到这个结果<ul><li>状态改变只有两种可能<ul><li>pending -&gt; fulfilled</li><li>pending -&gt; rejected</li></ul></li></ul></li></ul></li><li>缺点：<ul><li>无法取消。一旦新建就会立即执行，无法中途取消</li><li>如果不设置回调函数，内部抛出的错误无法反应到外部</li><li>处于 pending 状态的时候，无法得知进度</li><li>如果事件不断地反复发生， Stream 模式是比 Promise 更好的选择</li></ul></li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol><li>创建 Promise 实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 成功 */</span>) &#123;</span><br><span class="line">      resolve(value);<span class="comment">// 将 Promise 对象的状态 pending -&gt; fulfilled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  reject(error);<span class="comment">// 将 Promise 对象的状态 pending -&gt; rejected</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>回调函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>调用 <code>resolve</code> 或 <code>reject</code> 并不会终结 Promise 的参数函数的执行</li><li>立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li>一般来说，<code>resolve</code> 或 <code>reject</code> 之后 Promise 的使命就完成了，后续操作应该放到 <code>then</code> 里<ul><li>所以可以 <code>return resolve()</code> 或 <code>return reject()</code> </li></ul></li></ul><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><ul><li><code>then</code> 方法的返回值是一个<strong>新的</strong> Promise 实例，因此可以采用链式写法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(...)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(...)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>箭头函数写法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(</span><br><span class="line">  post =&gt; getJSON(post.commentURL);</span><br><span class="line">).then(</span><br><span class="line">comments =&gt; <span class="built_in">console</span>.log(...),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><ul><li><code>Promise.prototype.catch()</code> 是 <code>.then(null, rejection)</code> 或 <code>.then(undefined, rejection)</code> 的别名，用于指定发生错误的回调函数<ul><li>一般来说，不要用 <code>then</code> 的第二个参数，直接用 <code>catch</code>，可以捕获第一个参数的执行错误</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch (<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJOSN 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>reject</code> 方法的作用等于抛出错误<ul><li>如果 Promise 状态已经变成 <code>resulved</code> 再抛出错误是无效的</li></ul></li><li>Promise 对象的错误具有”冒泡”性质，会一直向后传递，知道被捕获为止<ul><li>也就是说，错误总是会被下一个 <code>catch</code> 语句捕获</li></ul></li><li>如果没有使用 <code>carch</code> 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码</li><li>Node 有一个 <code>unhandledRejection</code> 事件（计划废除），专门监听未捕获的 <code>reject</code> 错误</li><li><code>catch</code> 返回值也是 Promise 对象，还可以接 <code>then</code> ，也可以抛出错误被下一个 <code>catch</code> 捕获</li></ul><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><ul><li>无论 Promise 最后状态如何，都会执行的操作，不接收参数</li><li>本质上是 <code>then</code> 方法的特例（<code>then</code> 中两种情况代码一样）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">  value =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>finally</code> 方法总是返回原来的值</li></ul><h2 id="Promise-prototype-all"><a href="#Promise-prototype-all" class="headerlink" title="Promise.prototype.all()"></a>Promise.prototype.all()</h2><ul><li>将多个 Promise 实例包装成一个新的 Promise 实例<ul><li>参数可以不是数组，但必须具有 Iterator 接口，且每个成员都是 Promise 实例</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><ul><li>p 的状态由 p1, p2, p3 决定<ul><li>都为 <code>fulfilled</code>，p 为 <code>fulfilled</code><ul><li>返回值组成数组，传递给 p 的回调函数</li></ul></li><li>任一 <code>rejected</code>，p 为 <code>rejected</code><ul><li>第一个被 <code>reject</code> 的实例的返回值，传递给 p 的回调函数</li><li>如果 p1, p2, p3 自己定义了 <code>catch</code>，则会执行 <code>catch</code>，状态变成 <code>catch</code> 返回的 <code>resolve</code></li><li>如果没定义 <code>catch</code> 才会调用 <code>Promise.all()</code> 的 <code>catch</code> 方法</li></ul></li></ul></li></ul><h2 id="Promise-prototype-race"><a href="#Promise-prototype-race" class="headerlink" title="Promise.prototype.race()"></a>Promise.prototype.race()</h2><ul><li>将多个 Promise 实例包装成一个新的 Promise 实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><ul><li>只要 p1, p2, p3 任一改变状态，p 就跟着改变<ul><li>率先改变的 Promise 实例的返回值，传递给 p 的回调函数</li></ul></li></ul><h2 id="Promise-prototype-allSettled"><a href="#Promise-prototype-allSettled" class="headerlink" title="Promise.prototype.allSettled()"></a>Promise.prototype.allSettled()</h2><ul><li>接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</li><li>所有参数实例都返回结果，包装实例才会结束</li><li>返回新的 Promise 实例，状态总是 <code>fulfilled</code></li><li>监听函数接收到的参数是对象数组，每个对象分别对应 <code>allSettled</code> 的参数<ul><li>对象属性 status, value, reason</li></ul></li></ul><h2 id="Promise-prototype-any"><a href="#Promise-prototype-any" class="headerlink" title="Promise.prototype.any()"></a>Promise.prototype.any()</h2><ul><li>接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例<ul><li>任一 <code>fulfilled</code> ，包装实例就 <code>fulfilled</code></li><li>全部 <code>rejectd</code> ，包装实例才 <code>rejectd</code></li></ul></li></ul><h2 id="Promise-prototype-resolve"><a href="#Promise-prototype-resolve" class="headerlink" title="Promise.prototype.resolve()"></a>Promise.prototype.resolve()</h2><ul><li>将现有对象转为 Promise 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><ul><li>参数分 4 种情况<ul><li>Promise 实例<ul><li>不做任何修改</li></ul></li><li><code>thenable</code> 对象（具有 <code>then</code> 方法的对象）<ul><li>转为 Promise 对象，立即执行 <code>then</code></li></ul></li><li>不是 <code>thenable</code> 对象（其它对象或不是对象）<ul><li>返回一个新的 Promise 对象，状态 <code>resolved</code></li></ul></li><li>不带参数<ul><li>直接返回一个 <code>resolved</code> 的Promise 对象</li></ul></li></ul></li><li>立即 <code>resolve</code> 的 Promise 对象，在本轮”事件循环”的结束时执行，不是在下一轮”事件循环”开始时</li></ul><h2 id="Promise-prototype-reject"><a href="#Promise-prototype-reject" class="headerlink" title="Promise.prototype.reject()"></a>Promise.prototype.reject()</h2><ul><li>返回一个新的 Promise 实例，状态为 <code>rejected</code></li><li>参数会原封不动作为 <code>reject</code> 理由，和 <code>resolve</code> 处理不同</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>加载图片</li><li>Generator 函数与 Promise 结合</li></ul><h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><ul><li>同步函数同步执行，异步函数异步执行</li><li>模拟 <code>try</code> 代码块</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symbol</title>
      <link href="/2020/03/18/12-Symbol/"/>
      <url>/2020/03/18/12-Symbol/</url>
      
        <content type="html"><![CDATA[<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>ES5 的对象属性名都是字符串，容易造成属性名冲突</li><li>原始数据类型 <code>Symbol</code> 表示独一无二的值</li><li>通过 <code>Symbol</code> 函数生成<ul><li>不能使用 <code>new</code> 命令</li><li>可以接受参数，作为变量的描述，用来区分<ul><li>如果参数是对象，先调用该对象的 <code>toString</code> 方法</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">typeof</span> s<span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure><ul><li><p>现在，对象的属性名可以有两种类型</p><ul><li>字符串</li><li>Symbol 类型</li></ul></li><li><p>Symbol 值不能与其他类型的值进行运算，会报错</p></li><li><p>可以转为字符串和布尔值(true)，但不能转为数值</p></li></ul><h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><ul><li>创建 Symbol 的时候，可以添加一个描述</li><li>读取描述需要将 Symbol 显式转为字符串</li><li>ES2019 提供  <code>description</code> 属性，返回 Symbol 描述</li></ul><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure><ul><li>Symbol 值作为对象属性名时，不能用点运算符，因为点运算符后面总是字符串<ul><li><strong>要放在方括号中定义</strong></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line">a.mySymbol = <span class="string">'Hello'</span>;</span><br><span class="line">a[mySymbol]<span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">'mySymbol'</span>] <span class="comment">// 'Hello'</span></span><br></pre></td></tr></table></figure><ul><li>Symbol 值作为属性名时，该属性是公开属性，不是私有属性</li></ul><h2 id="实例：消除魔术字符串"><a href="#实例：消除魔术字符串" class="headerlink" title="实例：消除魔术字符串"></a>实例：消除魔术字符串</h2><blockquote><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p></blockquote><ul><li>等于哪个值并不重要，只要确保不会跟其他属性的值冲突即可，就很适合改用 Symbol 值</li></ul><h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><ul><li><p>Symbol 作为属性名，遍历对象的时候不会出现在<code>for...in</code>、<code>for...of</code>循环中</p><ul><li>可以利用这个特性，为对象定义非私有、只希望内部使用的方法</li></ul></li><li><p>不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 返回</p></li><li><p><code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名</p><ul><li>该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值</li></ul></li><li><p><code>Reflect.ownKeys(object)</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名</p></li></ul><h2 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h2><ul><li><code>Symbol.for(&#39;string&#39;)</code> 检查是否有以 <code>string</code> 作为名称的 Symbol 值，有则返回，没有则新建，并注册到全局</li><li><code>Symbol()</code>写法没有登记机制</li><li><code>Symbol.keyFor(变量名)</code>方法返回一个已登记的 Symbol 类型值的<code>key</code></li></ul><h2 id="实例：模块的-Singleton-模式"><a href="#实例：模块的-Singleton-模式" class="headerlink" title="实例：模块的 Singleton 模式"></a>实例：模块的 Singleton 模式</h2><ul><li>Singleton 模式（单例模式）指的是调用一个类，任何时候返回到都是同一个实例</li></ul><h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><ul><li>Symbol.hasInstance<ul><li>指向一个内部方法</li><li>当其他对象使用<code>instanceof</code>运算符，会调用这个方法</li><li>比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code></li></ul></li><li>Symbol.isConcatSpreadable<ul><li>等于一个布尔值</li><li>表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开</li></ul></li><li>Symbol.species<ul><li>指向一个构造函数，创建衍生对象时使用该属性</li></ul></li><li>Symbol.match<ul><li>指向一个函数</li><li>如果该属性存在，调用它并返回方法的返回值</li></ul></li><li>Symbol.replace<ul><li>指向一个方法</li><li>当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值</li></ul></li><li>Symbol.search<ul><li>指向一个方法</li><li>当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值</li></ul></li><li>Symbol.split<ul><li>指向一个方法</li><li>当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值</li></ul></li><li>Symbol.iterator</li><li>Symbol.toPrimitive</li><li>Symbol.toStringTag</li><li>SYmbol.unscopables</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的扩展</title>
      <link href="/2020/03/18/8-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/"/>
      <url>/2020/03/18/8-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>（<span class="title">x</span> = 0, <span class="title">y</span> = 0) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数默认值是惰性求值，每次重新计算</li></ul><h3 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h3><h3 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h3><ul><li>返回没有指定默认值的参数个数</li></ul><h2 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h2><ul><li><code>...变量名</code> 不需要使用 <code>arguments</code> 对象</li><li><code>arguments</code> 是类数组</li><li><code>rest</code> 是真的数组</li></ul><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><ul><li>返回函数名</li></ul><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>函数体内的 <code>this</code> 对象，是定义时所在的对象，而不是使用时所在的对象<ul><li>箭头函数没有自己的 <code>this</code> ，引用外层的 <code>this</code></li></ul></li><li>不可以当作构造函数，不可以使用 <code>new</code> 命令</li><li>不可以使用 <code>arguments</code> 对象，可以用 <code>rest</code> 参数</li><li>不可以使用 <code>yield</code> 命令，因此不能用做 Generator 函数</li></ul><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><h3 id="什么是尾调用"><a href="#什么是尾调用" class="headerlink" title="什么是尾调用"></a>什么是尾调用</h3><ul><li>某个函数的最后一步是调用另一个函数</li></ul><h3 id="尾调用优化-1"><a href="#尾调用优化-1" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><blockquote><p>函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p></blockquote><ul><li>只有 Safari 支持</li></ul><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><ul><li>尾调用自身，就称为尾递归。</li></ul><blockquote><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p></blockquote><ul><li>斐波那契</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span> (<span class="params">n, ac1 = <span class="number">1</span>, ac2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> ac2;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci2 (n<span class="number">-1</span>, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存</li></ul><h3 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h3><ul><li>把所有用到的内部变量改写成函数的参数</li></ul><blockquote><p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。</p></blockquote><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ul><li>ES6 的尾调用优化只在严格模式下开启</li></ul><h2 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h2><ul><li>ES6 中函数最后一个参数后有逗号不会报错</li></ul><h2 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h2><ul><li><code>toString()</code>方法返回函数代码本身，以前会省略注释和空格</li></ul><h2 id="catch-命令的参数省略"><a href="#catch-命令的参数省略" class="headerlink" title="catch 命令的参数省略"></a>catch 命令的参数省略</h2><ul><li>以前 catch 命令后面必须跟参数，ES6 可以省略</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串的扩展</title>
      <link href="/2020/03/17/4-5-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/03/17/4-5-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h2 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h2><ul><li>ES6 加强了对 Unicode 的支持，允许采用 <code>\uxxxx</code> 形式表示一个字符，<code>xxxx</code> 表示字符的 Unicode 码点</li><li>限制码点在 <code>\u0000</code> ~ <code>\uFFFF</code> 之间的字符，超出范围必须用两个双字节的形式表示</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line"><span class="comment">// " 7"</span></span><br><span class="line"><span class="comment">// JavaScript 会理解成 \u20BB+7</span></span><br><span class="line"><span class="comment">// \u20BB 不可打印，输出空格</span></span><br></pre></td></tr></table></figure><ul><li>只要将码点放入大括号，就能正确解读</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span></span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure><blockquote><p>对编码仍然是一窍不通……</p></blockquote><h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><ul><li>ES6 对字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 <code>for...of</code> 循环便利</li><li>除了遍历字符串，遍历器最大的优点是可以识别大于 <code>0xFFFF</code> 的码点</li></ul><h2 id="直接输入-U-2028-和-U-2029"><a href="#直接输入-U-2028-和-U-2029" class="headerlink" title="直接输入 U+2028 和 U+2029"></a>直接输入 U+2028 和 U+2029</h2><ul><li>JavaScript 字符串允许直接输入字符，以及输入字符的转义形式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'中'</span> === <span class="string">'\u4e2d'</span></span><br></pre></td></tr></table></figure><ul><li>规定不能在字符串里直接使用，只能用转义形式<ul><li>U+005C：反斜杠</li><li>U+000D：回车</li><li>U+2028：行分隔符</li><li>U+2029：段分隔符</li><li>U+000A：换行符</li></ul></li><li>JSON 允许使用 U+2028、U+2029<ul><li><code>JSON.parse()</code> 解析这两个会报错</li><li>为了兼容 JSON，ES2019 支持直接输入这两个</li></ul></li></ul><h2 id="JSON-stringify-的改造"><a href="#JSON-stringify-的改造" class="headerlink" title="JSON.stringify() 的改造"></a>JSON.stringify() 的改造</h2><ul><li>根据标准，JSON 数据必须是 UTF-8 编码，但是现在的 <code>JSON.stringify()</code> 有可能返回不符合 UTF-8 标准的字符串</li></ul><blockquote><p>UTF-8 标准规定，<code>0xD800</code> 到 <code>0xDFFF</code> 之间的码点必须配对使用</p></blockquote><ul><li><code>JSON.stringify()</code> 可能返回 <code>0xD800</code> 到 <code>0xDFFF</code> 之间的单个码点</li><li>为了确保返回的是合法的 UTF-8 字符，如果遇到<code>0xD800</code>到<code>0xDFFF</code>之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理</li></ul><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><ul><li>增强版的字符串，用反引号（`）标识</li><li>可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入 <code>${变量}</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure><ul><li>反引号需要反斜杠转义</li><li>保留空格和缩进，可以用 <code>trim()</code> 方法消除</li><li>如果变量的值不是字符串，将按照一般的规则转为字符串<ul><li>比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法</li></ul></li></ul><h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><ul><li>模版字符串跟在一个函数名后面，该函数将被调用来处理这个模版字符串</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`hello`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert([<span class="string">'hello'</span>])</span><br></pre></td></tr></table></figure><ul><li>标签模版其实不是模版，而是函数调用的一种特殊形式<ul><li>“标签” 指的是函数，跟在后面的模版字符串是参数</li></ul></li><li>如果有参数，函数会依次受到多个参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123;a + b&#125;</span> world <span class="subst">$&#123;a + b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><ul><li>作用<ul><li>过滤 HTML 字符串，防止用户输入恶意内容</li><li>多语言转换</li><li>嵌入其他语言</li></ul></li><li>模版处理函数的第一个参数（模版字符串数组），还有一个 <code>raw</code> 属性，保存的是<strong>转义</strong>后的原字符串</li></ul><h2 id="模板字符串的限制"><a href="#模板字符串的限制" class="headerlink" title="模板字符串的限制"></a>模板字符串的限制</h2><ul><li>标签模板可以内嵌别的语言，默认将字符串转义，导致报错</li><li>ES2018 放松了对<u>标签模版</u>里面字符串转义的限制<ul><li>遇到不合法的字符串转义，返回 <code>undefined</code></li><li><code>raw</code> 属性上仍可以得到原始字符串</li></ul></li><li>不是标签模版仍然会报错</li></ul><h1 id="字符串的新增方法"><a href="#字符串的新增方法" class="headerlink" title="字符串的新增方法"></a>字符串的新增方法</h1><h2 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h2><ul><li>ES5 提供 <code>String.fromCharCode()</code> 方法从 Unicode 码点返回对应字符，不能识别大于 <code>0xFFFF</code> 的字符</li><li>ES6 提供 <code>String.fromCodePoint()</code> 可识别大于 <code>0xFFFF</code> 的字符<ul><li>多个参数会被合并成一个字符串返回</li></ul></li><li><code>fromCodePoint</code> 方法定义在 <code>String</code> 对象上</li><li><code>codePointAt</code> 方法定义在字符串的实例对象上</li></ul><h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h2><ul><li><p>替换所有变量，并对斜杠进行转义</p></li><li><p>实现</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw = <span class="function"><span class="keyword">function</span> (<span class="params">strings, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> output = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += strings.raw[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  output += strings.raw[index]</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例方法：codePointAt"><a href="#实例方法：codePointAt" class="headerlink" title="实例方法：codePointAt()"></a>实例方法：codePointAt()</h2><ul><li>JavaScript 内部，字符以 UTF-16 的格式存储，每个字符固定 2 字节</li><li>大于 <code>0xFFFF</code> 的字符需要 4 个字节存储，JavaScript 会认为它们是两个字符，字符串长度为 2</li><li>ES5 <code>charCodeAt()</code> 只能 2 个字节 2 个字节处理</li><li>ES6 <code>codePointAt()</code> 能够正确处理 4 个字节</li><li><code>codePointAt()</code> 返回的码点是十进制的，toString(16) 转为十六进制</li></ul><h2 id="实例方法：normalize"><a href="#实例方法：normalize" class="headerlink" title="实例方法：normalize()"></a>实例方法：normalize()</h2><ul><li>合成符号</li></ul><h2 id="实例方法：includes-startsWith-endsWith"><a href="#实例方法：includes-startsWith-endsWith" class="headerlink" title="实例方法：includes(), startsWith(), endsWith()"></a>实例方法：includes(), startsWith(), endsWith()</h2><ul><li>ES5 <code>indexOf</code> 可以确定一个字符串是否包含在另一个字符串中</li><li>ES6<ul><li><code>includes(&#39;subString&#39;, n)</code> 返回布尔值，表示是否找到了参数字符串</li><li><code>startsWith(&#39;subString&#39;, n)</code> 返回布尔值，表示参数字符串是否在原字符串的头部</li><li><code>endsWith(&#39;subString&#39;, n)</code> 返回布尔值，表示参数字符串是否在原字符串的尾部</li></ul></li></ul><h2 id="实例方法：repeat-n"><a href="#实例方法：repeat-n" class="headerlink" title="实例方法：repeat(n)"></a>实例方法：repeat(n)</h2><ul><li>返回一个新字符串，重复 n 次</li><li>小数取整，负数/Infinity 报错</li></ul><h2 id="实例方法：padStart-n-‘string’-padEnd-n-‘string’"><a href="#实例方法：padStart-n-‘string’-padEnd-n-‘string’" class="headerlink" title="实例方法：padStart(n, ‘string’), padEnd(n, ‘string’)"></a>实例方法：padStart(n, ‘string’), padEnd(n, ‘string’)</h2><ul><li>补全长度<ul><li>长度 n</li><li>用来补全的字符串 string</li></ul></li></ul><h2 id="实例方法：trimStart-trimEnd"><a href="#实例方法：trimStart-trimEnd" class="headerlink" title="实例方法：trimStart(), trimEnd()"></a>实例方法：trimStart(), trimEnd()</h2><ul><li>消除空格</li><li>不修改原始字符</li></ul><h2 id="实例方法：matchAll"><a href="#实例方法：matchAll" class="headerlink" title="实例方法：matchAll()"></a>实例方法：matchAll()</h2><ul><li><code>matchAll()</code>返回一个正则表达式在当前字符串的所有匹配</li><li>详见 6-正则的扩展</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量的解构赋值</title>
      <link href="/2020/03/15/3-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
      <url>/2020/03/15/3-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><ul><li>ES6 允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，被称为解构</li></ul><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><ul><li>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 嵌套的例子</span></span><br><span class="line"><span class="keyword">let</span> [head, ...detail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// head = 1, detail = [2, 3, 4]</span></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line"><span class="comment">// x = 'a', y = undefined, z = []</span></span><br></pre></td></tr></table></figure><ul><li>如果解构不成功，变量的值就等于 <code>undefined</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><ul><li>不完全解构，只匹配一部分</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// x = 1, y = 2</span></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line"><span class="comment">// a = 1, b = 2, d = 4</span></span><br></pre></td></tr></table></figure><ul><li>如果等号右边不是数组（严格的说，不是可遍历的结构，参见第 17 章 - Iterator），会报错</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转为对象后不具备 Iterator 接口</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 本身不具备 Iterator 接口</span></span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值</li></ul><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><ul><li>解构赋值允许指定默认值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line"><span class="comment">// foo = true</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>];</span><br><span class="line"><span class="comment">// x = 'a', y = 'b'</span></span><br></pre></td></tr></table></figure><ul><li>ES6 内部使用严格相等运算符判断一个位置是否有值，只有当一个数组成员严格等于 <code>undefined</code> 默认值才会生效</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line"><span class="comment">// x = 1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line"><span class="comment">// x = null</span></span><br></pre></td></tr></table></figure><ul><li>如果默认值是一个表达式，则是惰性求值，也就是只有在用到的时候才会求值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">// x = 1, 函数 f 不会执行</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1] 是只含元素 1 的数组</span></span><br><span class="line"><span class="comment">// [1][0] 表示取该数组第一位，也就是元素 1</span></span><br><span class="line"><span class="comment">// let array = [1];</span></span><br><span class="line"><span class="comment">// let x = array[0];</span></span><br></pre></td></tr></table></figure><ul><li>默认值可以引用解构赋值的其他变量，但该变量必须已经声明</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];</span><br><span class="line"><span class="comment">// x = 1, y = 1</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">// foo = 'aaa', bar = 'bbb'</span></span><br></pre></td></tr></table></figure><ul><li>数组的元素是按次序排列的，变量的取值由位置决定</li><li>对象的属性没有次序，变量必须与属性同名才能赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">// baz = undefined</span></span><br></pre></td></tr></table></figure><ul><li>对象的解构赋值可以很方便的将现有对象的方法赋值到某个变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line">log(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><ul><li>如果变量名与属性名不一致，写法如下</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;;</span><br><span class="line"><span class="comment">// baz = 'aaa'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, last = <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj</span><br><span class="line"><span class="comment">// f = 'hello', l = 'world'</span></span><br></pre></td></tr></table></figure><blockquote><p>说明对象的解构赋值是下面形式的简写（参见第 10 章 - 对象的扩展）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br></pre></td></tr></table></figure><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋值给对应变量</p><p>真正被赋值的是后者，而不是前者</p><p>前者是匹配的模式，后者才是变量</p></blockquote><ul><li>嵌套</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line"><span class="comment">// line = 1</span></span><br><span class="line"><span class="comment">// start = Object &#123;line: 1, column: 5&#125;</span></span><br><span class="line"><span class="comment">// loc = Object &#123; start: Object &#125;</span></span><br></pre></td></tr></table></figure><ul><li>对象的解构赋值可以取到继承的属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line"><span class="comment">// foo = 'bar'</span></span><br></pre></td></tr></table></figure><h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><ul><li>生效条件是对象的属性值严格等于 <code>undefined</code></li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>如果要将一个已经声明的变量用于解构赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// js 引擎会将 &#123;x&#125; 理解为一个代码块，从而发生语法错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">// 放在圆括号里即可正确执行</span></span><br></pre></td></tr></table></figure><ul><li>解构赋值允许等号左边的模式中不放任何变量名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><ul><li>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span>: first, [arr.length = <span class="number">1</span>]: last&#125; = arr;</span><br><span class="line"><span class="comment">// first = 1, last = 3</span></span><br></pre></td></tr></table></figure><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><ul><li>字符串在解构赋值时被转换成一个类似数组的对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// a = 'h', b = 'e', C = 'c', d = 'l', e = 'o'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">length</span>: len &#125; = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// len = 5</span></span><br></pre></td></tr></table></figure><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><ul><li>数值和布尔值在解构赋值时被转为对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toString</span>: s &#125; = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// s === Number.prototype.toString =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toString</span>: s &#125; = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// s === Boolean.prototype.toString =&gt; true</span></span><br></pre></td></tr></table></figure><ul><li>数组和布尔值的包装对象都有 <code>toString</code> 属性，因此变量 <code>s</code> 都能取到值</li><li>解构赋值的规则：只要等号右边的值不是对象或数组，就先将其转为对象</li><li>由于 <code>undefined</code> 和 <code>null</code> 无法转为对象，所以它们无法进行解构赋值，会报错</li></ul><p>##函数参数的解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [3, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);</span><br><span class="line"><span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;&#125;);</span><br><span class="line"><span class="comment">// [0, 0]</span></span><br><span class="line">move();</span><br><span class="line"><span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><ul><li>对于编译器来说，一个式子到底是模式还是表达式，只有在解析到（或解析不到）等号才能知道</li><li>如果模式中出现圆括号怎么处理？<ul><li>只要有可能导致解构的歧义，就不得使用圆括号</li><li>尽量不要在模式中放置圆括号</li></ul></li></ul><h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><ul><li>变量声明语句</li><li>函数参数</li><li>赋值语句的模式</li></ul><h3 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h3><ul><li>赋值语句的非模式部分</li></ul><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li>交换变量的值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><ul><li><p>从函数返回多个值</p></li><li><p>函数参数的定义</p></li><li><p>提取 JSON 数据</p></li><li><p>函数参数的默认值</p></li><li><p>遍历 Map 解构</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">con s t map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">' is '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输入模块的指定方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapCounsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>let 和 const 命令</title>
      <link href="/2020/03/15/2-let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/03/15/2-let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h1><h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>let 声明的变量值在 let 命令坐在的代码块内有效</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// var 声明的 i 在全局有效，最终所有的 i 都指向同一个 i，也就是最后一轮循环时 i 的值</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><ul><li>for 循环变量是一个父作用域，循环体是一个子作用域</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><ul><li><code>var</code> 声明会出现”变量提升”现象，即变量可以在声明之前使用，值为 <code>undefined</code></li><li><code>let</code> 改变了语法行为，声明之前使用会报错</li></ul><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><ul><li>块级作用域内存在 <code>let</code> 或 <code>const</code> 命令，它所声明的变量就”绑定(binding)”这个区域，不受外部影响</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>;<span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>暂时性死区的本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</li></ul><h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><ul><li><code>let</code> 不允许在相同作用域内重复声明同一个变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h3><p>ES5 只有全局作用域和函数作用域，可能会导致：</p><ol><li>内层变量可能会覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ol><h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><ul><li>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</li><li>ES6 明确允许在块级作用域之中声明函数，且函数声明语句的行为类似于 let，在块级作用域外不可引用</li><li>但为了兼容，浏览器在实现时，函数声明的行为可以类似于 var，即会提升到全局作用域或函数作用域的头部</li></ul><h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li><code>const</code> 声明一个只读的常量，一旦声明，常量的值就不能改变</li><li>由于不能改变，声明时就必须初始化，否则报错</li></ul><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><ul><li><code>csont</code> 实际上保证的是变量指向的那个内存地址所保存的数据不得改动<ul><li>对于简单类型（数值、字符串、布尔值）的数据，变量指向的地址保存值，等同于常量</li><li>对于符合类型（对象、数组）的数据，变量指向的地址保存指针，指针再指向实际数据，这里只能保证指针不变，但不能保证实际数据不变<ul><li>如果想将对象冻结，可以使用 <code>Object.freeze()</code> 方法</li></ul></li></ul></li></ul><h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><ul><li>ES5<ul><li>var</li><li>function</li></ul></li></ul><hr><ul><li>ES6 新增<ul><li>let</li><li>const</li><li>import</li><li>class</li></ul></li></ul><h2 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h2><ul><li>顶层对象<ul><li>浏览器：window</li><li>Node：global</li></ul></li><li>ES5 之中，顶层对象的属性和全局变量等价</li><li>ES6 规定<ul><li>var、function 声明的全局变量，依旧是顶层对象的属性</li><li>let、const、class 声明的全局变量，不属于顶层对象的属性</li></ul></li></ul><h2 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h2><ul><li>顶层对象提供全局环境（即全局作用域）</li><li>各个实现不一致<ul><li>浏览器：<code>window</code></li><li>浏览器和 Web Worker：<code>self</code></li><li>Node：<code>global</code></li></ul></li><li>为了兼容，一般使用 <code>this</code> ，但有限制<ul><li>全局环境中，<code>this</code> 会返回顶层对象。但 Node 模块和 ES6 模块中，<code>this</code> 返回当前模块</li><li>函数里面的 <code>this</code>，如果函数不是作为对象的方法运行，<code>this</code> 指向顶层对象。严格模式下 <code>undefined</code></li><li><code>new Function(&#39;return this&#39;)()</code> 返回全局对象。如果浏览器用了 CSP（内容安全策略），则该方法无法使用</li></ul></li><li>ES2020 引入 <code>globalThis</code> 作为顶层对象，指向全局环境下的 <code>this</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ECMAScript 6 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二十二章 高级技巧</title>
      <link href="/2020/03/14/%E7%AC%AC22%E7%AB%A0-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/03/14/%E7%AC%AC22%E7%AB%A0-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="第二十二章-高级技巧"><a href="#第二十二章-高级技巧" class="headerlink" title="第二十二章 高级技巧"></a>第二十二章 高级技巧</h1><h2 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h2><h3 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h3><p><code>Object.toString()</code> 方法返回一个 <code>[object NativeConstructorName]</code> 格式的字符串。每个类内部都有一个 <code>[[Class]]</code> 属性，指定了上述字符串中的构造函数名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(value);</span><br><span class="line"><span class="comment">// "[object Array]"</span></span><br></pre></td></tr></table></figure><p>开发人员定义的构造函数返回 <code>object Object</code>。</p><h3 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h3><ul><li><p>当 new 调用构造函数时，构造函数内用到的 this 对象会指向新创建的对象实例。</p></li><li><p>如果不用 new，this 会映射到全局对象 widow 上，导致属性被添加到全局。</p></li><li><p>解决：构造函数内部检查 this 对象是否正确</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(name, age, job);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h3><p>函数执行的分支只执行一次</p><ul><li>函数被调用时处理<ul><li>第一次调用时用合适函数覆盖原来的函数<ul><li>例如检查浏览器是否支持某功能，执行一次就行</li></ul></li><li>在声明时就指定适当函数<ul><li>加载时损失性能，执行时不会</li></ul></li></ul></li></ul><h3 id="函数绑定-bind"><a href="#函数绑定-bind" class="headerlink" title="函数绑定 bind()"></a>函数绑定 bind()</h3><p>创建一个函数，可以在特定的 this 环境中以指定参数调用另一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  message: <span class="string">"Event handled"</span>,</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"my-btn"</span>);</span><br><span class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, handler.handleClick);</span><br><span class="line"><span class="comment">// 由于没有保存 handler.handleClick() 的执行环境</span></span><br><span class="line"><span class="comment">// this 指向 DOM 按钮而非 handler</span></span><br><span class="line"><span class="comment">// 本来应该显示 “Event handled”，会显示 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用闭包解决：</span></span><br><span class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  handler.handleClick(event);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind() 可以将函数绑定到指定环境的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, bind(handler,handleClick, handler));</span><br></pre></td></tr></table></figure><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><ul><li>用于创建已经设置好了一个或多个参数的函数</li><li>基本方法和函数绑定一样：使用一个闭包返回一个函数</li><li>区别在于：函数被调用时，返回的函数还需要设置一些传入的参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.all(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context, finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="防篡改对象"><a href="#防篡改对象" class="headerlink" title="防篡改对象"></a>防篡改对象</h2><p>一旦把对象定义为防篡改，就无法撤销了</p><ul><li><code>Object.preventExtensions()</code> 不可扩展对象<ul><li>无法添加新属性和方法</li><li>已有成员可以修改/删除</li></ul></li><li><code>Object.seal()</code> 密封对象<ul><li>不可扩展</li><li>不能删除</li><li>可以修改</li></ul></li><li><code>Object.freeze()</code> 冻结对象<ul><li>不可扩展</li><li>密封</li><li><code>[[Writable]]</code> 设置为 false，若定义 <code>[[Set]]</code> 属性可写</li></ul></li></ul><h2 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h2><ul><li><p>定时器不是线程</p></li><li><p>Javascript 运行于单线程环境中</p></li><li><p>定时器是计划代码在未来的某个时间执行，执行时机不能保证</p></li><li><p>因为在页面的生命周期中，不同时间可能有其他代码在控制 Javascript 进程</p></li><li><p>在页面下载完后的代码运行、事件处理程序、Ajax 回调函数都必须使用同样的线程来执行</p></li><li><p>浏览器负责进行排序，指派某段代码在某个时间点运行的优先级</p></li><li><p>除了主 JavaScript 执行进程外，还有一个需要在进程下一次空闲时执行的代码队列</p></li><li><p>没有任何代码是立即执行的，但一旦进程空闲则尽快执行</p></li><li><p>定时器时间过去时，将代码插入队列末尾</p><ul><li>若队列不空，则仍需等待</li><li>若主 JavaScript 执行进程正在执行，也仍需等待</li></ul></li></ul><h3 id="重复的定时器"><a href="#重复的定时器" class="headerlink" title="重复的定时器"></a>重复的定时器</h3><p>当使用 <code>setInterval()</code> 仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中</p><ul><li>某些间隔会被跳过</li><li>多个定时器的代码执行之间的间隔可能会比预期小</li></ul><p>解决：链式 <code>setTimeout()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">  setTimeout(<span class="built_in">arguments</span>.callee, interval);</span><br><span class="line">&#125;, interval);</span><br></pre></td></tr></table></figure><h3 id="Yielding-Processes"><a href="#Yielding-Processes" class="headerlink" title="Yielding Processes"></a>Yielding Processes</h3><p>如果代码运行超过特定的时间或者特定语句数量就不会让它继续执行</p><p>展开循环前，思考：</p><ul><li>该处理是否必须同步完成？</li><li>数据是否必须按顺序完成？</li></ul><p>如果答案都为否，可以使用<strong>数组分块</strong>技术</p><ul><li>为要处理的项目创建一个队列，使用定时器取出下一个要处理的项目，再设置另一个定时器</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params">array, process, context</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> item = array.shift();</span><br><span class="line">    process.call(context, item);</span><br><span class="line">    <span class="keyword">if</span> (array.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流 throttle"></a>函数节流 throttle</h3><ul><li><p>DOM 操作比非 DOM 交互需要更多的内存和 CPU 时间</p></li><li><p>连续尝试进行过多的 DOM 相关操作可能会导致浏览器挂起，甚至崩溃。例如 onresize 调整浏览器大小</p></li><li><p>防止连续触发，使用定时器进行<strong>节流</strong></p></li><li><p>基本思想</p><ul><li>某些代码不可以在没有间断的情况连续重复执行</li><li>第一次调用函数时，创建一个定时器，在指定的时间间隔之后运行代码</li><li>第二次调用函数时，清除前一次的定时器，并设置另一个<ul><li>如果前一次的定时器已经执行，这个操作无意义</li><li>如果前一次的定时器还未执行，就是替换新定时器</li></ul></li><li>目的是只有在执行函数的请求停止了一段时间之后才执行</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> processor = &#123;</span><br><span class="line">  timeoutId: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 实际进行处理的方法</span></span><br><span class="line">  performPorcessing: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 初始处理调用的方法</span></span><br><span class="line">  process: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.timeoutId);</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      that.performProcessing();</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 尝试开始执行</span></span><br><span class="line">processor.process();</span><br></pre></td></tr></table></figure><p>简化的 <code>throttle()</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, context</span>) </span>&#123;</span><br><span class="line">  clearTimeout(method.tId);</span><br><span class="line">  method.tId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    method.call(context);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><ul><li><p>事件是 Javascript 与浏览器交互的主要途径</p></li><li><p>事件是观察者模式，一种创建松散耦合代码的技术</p></li><li><p>观察者模式有两类对象组成</p><ul><li>主体<ul><li>发布事件</li><li>不知道观察者的存在，独立运行</li></ul></li><li>观察者<ul><li>通过订阅事件来观察主体</li><li>知道主体并能注册事件的回调函数（事件处理程序）</li></ul></li></ul></li></ul><h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><ul><li>创建一个绝对定位的元素，使其可以用鼠标移动</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二十三章 离线应用与客户端存储</title>
      <link href="/2020/03/14/%E7%AC%AC23%E7%AB%A0-%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
      <url>/2020/03/14/%E7%AC%AC23%E7%AB%A0-%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="第二十三章-离线应用与客户端存储"><a href="#第二十三章-离线应用与客户端存储" class="headerlink" title="第二十三章 离线应用与客户端存储"></a>第二十三章 离线应用与客户端存储</h1><p>离线 Web 应用：设备不能上网的情况下仍然可以运行的应用</p><h2 id="离线检测"><a href="#离线检测" class="headerlink" title="离线检测"></a>离线检测</h2><ul><li><code>navigator.onLine</code> 属性</li></ul><ul><li>应用缓存</li></ul><h2 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h2><ul><li>appache 从浏览器的缓存中分出一块缓存区<ul><li>使用一个<strong>描述文件(manifest file)</strong>，列出要下载和缓存的资源</li><li>将描述文件与页面关联起来，可以在 <code>html</code> 中的 <code>manifest</code> 属性指定文件路径</li></ul></li><li>applicationCache 对象</li></ul><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h3><ul><li>要求服务器对任意 HTTP 请求发送 Set-Cookie HTTP 作为响应的一部分，其中包含会话信息</li></ul><blockquote><p>如：</p><p>HTTP/1.1 200 OK</p><p>Content-type: text / html</p><p>Set-Cookie: name = value</p><p>Other-header: other-header-value</p></blockquote><ul><li><p>限制</p><ul><li>Cookie 在性质上是绑定在特定的域名下的</li><li>当设定了一个 cookie 后，再给创建它的域名发送请求时，都会包含这个 cookie</li><li>确保 cookie 中的信息只能让批准的接受者访问，而无法被其他域访问</li></ul></li><li><p>构成</p><ul><li>名称：不区分大小写（实践最好区分），经过 URL 编码</li><li>值：URL 编码</li><li>域：有效域</li><li>路径：对于指定的路径，应该向服务器发送 cookie<ul><li>若指定 <a href="http://www.wrox.com/books/，就不会给" target="_blank" rel="noopener">http://www.wrox.com/books/，就不会给</a> <a href="http://www.wrox.com" target="_blank" rel="noopener">http://www.wrox.com</a> 发送 cookie</li></ul></li><li>失效时间：cookie 何时应该被删除的时间戳</li><li>安全标志：指定后之后 SSL 连接时才发送到服务器</li></ul></li><li><p>JS 中的 cookie</p><ul><li>BOM 的 document.cookie 属性</li></ul></li><li><p>子 cookie</p><ul><li><p>存放在单个 cookie 中的更小段的数据</p></li><li><p>使用 cookie 值来存储多个名称值对</p></li><li><blockquote><p>如 name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5</p></blockquote></li><li><p>查询字符串的格式进行格式化</p></li></ul></li></ul><blockquote><p>所有的 cookie 都会由浏览器作为请求头发送，所以在 cookie 中存储大量信息会影响到特定域的请求性能</p></blockquote><h3 id="Web-存储机制"><a href="#Web-存储机制" class="headerlink" title="Web 存储机制"></a>Web 存储机制</h3><ul><li>Web Storage 的两个主要目标<ul><li>提供一种在 cookie 之外存储会话数据的途径</li><li>提供一种存储大量可以跨会话存在的数据的机制</li></ul></li></ul><h5 id="Storage-类型"><a href="#Storage-类型" class="headerlink" title="Storage 类型"></a>Storage 类型</h5><ul><li>只能存储字符串</li><li>提供最大的存储空间</li><li><code>clear()</code></li><li><code>getItem(name)</code></li><li><code>key(index)</code></li><li><code>removeItem(name)</code></li><li><code>setItem(name, value)</code></li></ul><h5 id="sessionStorage-对象"><a href="#sessionStorage-对象" class="headerlink" title="sessionStorage 对象"></a>sessionStorage 对象</h5><ul><li>Storage 的一个实例</li><li>存储特定于某个会话的数据，只保持到浏览器关闭<ul><li>如果浏览器支持，崩溃重启可以继续使用</li></ul></li><li>可以跨越页面刷新而存在</li><li>存储在 sessionStorage 的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制</li></ul><h5 id="globalStorage-对象"><a href="#globalStorage-对象" class="headerlink" title="globalStorage 对象"></a>globalStorage 对象</h5><ul><li>不是 Storage 实例，globalStorage[“xxx.com”] 才是 Storage 的实例</li><li>跨越会话存储数据，有特定的访问限制</li><li>如果不删除，或者用户未清除浏览器缓存，存储在 globalStorage 属性中的数据会一直保留在磁盘上</li><li>合在客户端存储文档或者长期保存用户偏好设置</li></ul><h5 id="localStorage-对象"><a href="#localStorage-对象" class="headerlink" title="localStorage 对象"></a>localStorage 对象</h5><ul><li>Storage 实例，用法与 sessionStorage 相同</li><li>取代 globalStorage，不用设置规则</li><li>同域名、同协议、同端口</li><li>保留到通过 JavaScript 删除或者是用户清除浏览器缓存</li></ul><h5 id="storage-事件"><a href="#storage-事件" class="headerlink" title="storage 事件"></a>storage 事件</h5><ul><li>修改 Storage 对象会在文档上触发 storage 事件</li></ul><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><ul><li>浏览器中保存结构化数据的一种数据库</li><li>替代被废弃的 Web SQL Database API</li><li>创建一套 API，方便保存和读取 JavaScript 对象，同时还支持查询及搜索</li><li>异步</li><li>做为全局对象 windows.indexedDB，具体名称根据浏览器不同</li></ul><h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><ul><li>用对象保存数据，而不是用表来保存</li><li>一个 IndexedDB 数据库，就是一组位于相同命名空间下的对象的集合</li><li>indexDB.open() 创建/打开</li><li>返回 IDBRequest 对象<ul><li>onerror</li><li>onsuccess</li></ul></li></ul><h5 id="对象存储空间"><a href="#对象存储空间" class="headerlink" title="对象存储空间"></a>对象存储空间</h5><ul><li>可以把这里的对象存储空间(object storge)想象成表，把其中保存的对象想象成表中的记录</li><li><code>add()</code></li><li><code>put()</code></li></ul><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><ul><li>读取或修改数据都要通过事务来组织所有操作</li><li>使用事务可以直接通过已知的键检索单个对象</li></ul><h5 id="使用游标查询"><a href="#使用游标查询" class="headerlink" title="使用游标查询"></a>使用游标查询</h5><ul><li>需要检索多个对象的情况下，需要在事务内 部创建游标</li><li>与传统数据库查询不同<ul><li>游标不提前收集结果</li><li>游标指针会先指向结果中的第一项，在接到查找下一项的指令时指向下一项</li></ul></li></ul><h5 id="键范围"><a href="#键范围" class="headerlink" title="键范围"></a>键范围</h5><h5 id="设定游标方向"><a href="#设定游标方向" class="headerlink" title="设定游标方向"></a>设定游标方向</h5>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二十一章 Ajax与Comet</title>
      <link href="/2020/03/13/%E7%AC%AC21%E7%AB%A0-Ajax%E4%B8%8EComet/"/>
      <url>/2020/03/13/%E7%AC%AC21%E7%AB%A0-Ajax%E4%B8%8EComet/</url>
      
        <content type="html"><![CDATA[<p>AJAX - Asynchronous JavaScript + XML</p><p>向服务器请求额外的数据而无须卸载页面</p><p>核心是 XMLHttpRequest 对象，简称 XHR</p><p>使用 XHR 对象取得新数据，通过 DOM 将新数据插入页面</p><h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure><h3 id="XHR的用法"><a href="#XHR的用法" class="headerlink" title="XHR的用法"></a>XHR的用法</h3><ol><li><code>open(请求类型, URL, 是否异步)</code><ul><li>get / post</li><li>相对于当前页面 / 绝对路径</li><li>Boolean</li></ul></li><li><code>send(请求主体)</code><ul><li>无内容则传入 null</li></ul></li><li>收到响应后，自动填充 XHR 对象的属性<ul><li><code>responseText</code> 做为响应主体</li><li><code>responseXML</code> “text/xml” 或 “application/xml”</li><li><code>status</code> 响应的 HTTP 状态<ul><li>200 成功，responseText 就绪 </li><li>304 资源未修改，可使用缓存</li></ul></li><li><code>statusText</code> HTTP 状态的说明</li><li><code>readyState</code> 异步请求的活动阶段<ul><li>0 位初始化</li><li>1 启动</li><li>2 发送</li><li>3 接收</li><li>4 完成</li><li>值每次改变都触发 <code>readystatechange</code> 事件</li></ul></li><li>收到响应前调用 <code>abort()</code> 取消异步请求</li></ul></li></ol><h3 id="HTTP头部信息"><a href="#HTTP头部信息" class="headerlink" title="HTTP头部信息"></a>HTTP头部信息</h3><p>XHR 提供操作请求头部和响应头部信息的方法</p><p>默认情况，发送 XHR 请求的同时还会发送以下头部信息</p><ul><li>Accept：浏览器能够处理的内容类型</li><li>Accept-Charset：浏览器能够显示的字符集</li><li>Accept-Encoding：浏览器能够处理的压缩编码</li><li>Accept-Language：浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cookie：当前页面设置的任何 Cookie</li><li>Host：发出请求的页面所在的域</li><li>Referer：发出请求的页面的 URI</li><li>User-Agent：浏览器的用户代理字符串</li></ul><ul><li><p><code>setRequestHeader(头部字段名称，头部字段值)</code> </p><ul><li>设置自定义的请求头部信息</li><li>open 之后 send 之前</li></ul></li><li><p><code>getRequestHeader(头部字段名称)</code></p></li><li><p><code>getAllResponseHeaders()</code></p></li></ul><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><p>每个参数的名称和值必须使用 <code>encodeURIComponent()</code> 编码才能放到 URL 末尾，所有名-值对都由 &amp; 分隔</p><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><p><code>serialize()</code> 格式化数据</p><h2 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h2><ul><li>FormData 序列化表单</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(键, 值);</span><br></pre></td></tr></table></figure><ul><li>超时设定 <code>timeout</code>属性</li></ul><p>open 之后 send 之前设定，请求在等待响应多少毫秒之后停止</p><p>触发 timeout 事件，调用 ontimeout 事件处理程序</p><ul><li><code>overrideMimeType()</code> 方法</li></ul><p>重写 XHR 响应的 MIME 类型，send 之前调用</p><h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><ul><li>loadstart：接收到响应数据的第一个字节时触发</li><li>progress：接收响应期间不断地触发</li><li>error：请求发生错误时触发</li><li>abort：在因为调用 abort() 方法而终止连接时触发</li><li>load：在接收到完整的响应数据时触发</li><li>loaded：在通信完成或者触发 error、abort 或 load 事件后触发</li></ul><h2 id="跨资源共享-CORS"><a href="#跨资源共享-CORS" class="headerlink" title="跨资源共享 CORS"></a>跨资源共享 CORS</h2><p>基本思想：使用自定义的 HTTP 头部让浏览器与服务器进行沟通</p><p>发送：<code>Origin：http://www...</code></p><p>接收：<code>Access-Control-Allow-Origin：http://www...</code></p><ul><li><p>在 XHR 对象的 open 中传入绝对 URL 可以请求跨域，：限制</p><ul><li>不能使用 setRequestHeader() 设置自定义头部</li><li>不能发送和接收 cookie</li><li>调用 getAllResponseHeaders() 会返回空字符串</li></ul></li><li><p>Preflighted Requests 透明服务器验证机制</p><ul><li>发送<ul><li>Origin：与简单的请求相同</li><li>Access-Control-Request-Method:请求自身使用的方法</li><li>Access-Control-Request-Headers:(可选)自定义的头部信息，多个头部以逗号分隔</li></ul></li><li>接收<ul><li>Access-Control-Allow-Origin：与简单的请求相同</li><li>Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔</li><li>Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔</li><li>Access-Control-Max-Age：应该将这个 Preflight 请求缓存多长时间(以秒表示)</li></ul></li></ul></li><li><p>带凭据的请求</p><ul><li>默认跨源请求不提供凭据（cookie、HTTP 认证及客户端 SSL 证明）</li><li>将 withCredentials 属性设置为 true 可以指定某个请求应该发送凭据</li><li>响应：<code>Access-Control-Allow-Credentials: true</code></li></ul></li><li><p>跨浏览器的 CROS</p><ul><li>所有浏览器都支持简单的（非 Preflight 和不带凭据的）请求</li></ul></li></ul><h2 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h2><ul><li>图像 Ping<ul><li><code>&lt;img&gt;</code> 标签</li><li>只能发送 GET 请求</li><li>无法访问服务器的响应文本</li></ul></li><li>JSONP - JSON with padding<ul><li>包含两部分：回调函数和数据</li><li>通过 <code>&lt;script&gt;</code> 元素使用</li><li>能直接访问响应文本</li><li>从其他域中加载代码执行，不安全</li><li>很难确定 JSONP 请求是否成功</li></ul></li><li>Comet 服务器推送<ul><li>长轮询：浏览器发送请求，服务器保持连接，直到有数据发送才发送数据。浏览器收到数据后关闭连接，再重新发起新请求</li><li>HTTP 流：浏览器发送请求，服务器保持连接，周期性地向浏览器发送数据</li></ul></li><li>SSE 服务器发送事件<ul><li>围绕只读 Comet 交互推出的 API 或者模式</li></ul></li><li>Web Socket<ul><li>单独的持久连接上提供全双工、双向通信</li></ul></li><li>SSE 与 Web Socket<ul><li>Web Socket 需要服务器支持，双向通信</li><li>SSE 不需要服务器支持，一般单向，结合 XHR 可以双向</li></ul></li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>要求以 SSL 连接来访问可以通过 XHR 请求的资源</li><li>要求每一次请求都要附带经过响应算法计算得到的验证码</li></ul><p>以下措施对防范 CSRF（Cross-Saite Request Forgery）攻击不起作用</p><ul><li>要求发送 POST 而不是 GET —— 容易改变</li><li>检查来源 URL 以确定 是否可信 —— 容易伪造</li><li>基于 cookie 信息进行验证 ——容易伪造</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二十章 JSON</title>
      <link href="/2020/03/12/%E7%AC%AC20%E7%AB%A0-JSON/"/>
      <url>/2020/03/12/%E7%AC%AC20%E7%AB%A0-JSON/</url>
      
        <content type="html"><![CDATA[<p><strong>JSON 是一种数据格式，不是编程语言</strong></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li>简单值<ul><li>字符串</li><li>数组</li><li>布尔值</li><li>null</li></ul></li><li>复杂数据类型<ul><li>对象<ul><li>无序的键值对</li></ul></li><li>数组<ul><li>有序的值的列表</li><li>可以通过数值索引访问</li></ul></li></ul></li></ul><h3 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h3><p>JSON 字符串必须使用双引号，JavaScript 字符串可以单引号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello world!"</span></span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"属性"</span>: <span class="string">"值"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>属性必须加双引号</li><li>值可以是简单值/复杂类型</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">25</span>, <span class="string">"hi"</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure><p>}</p><h2 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h2><h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><ul><li><code>stringify()</code> js 对象序列化为 JSON 字符串<ul><li>函数及原型成员会被忽略</li><li>值为 undefined 的属性也会被跳过</li></ul></li><li><code>parse()</code> JSON 字符串解析为 js 值</li></ul><h3 id="序列化选项"><a href="#序列化选项" class="headerlink" title="序列化选项"></a>序列化选项</h3><ul><li><code>JSON.stringify()</code> 参数<ul><li>过滤器<ul><li>数组</li><li>函数 replacer</li></ul></li><li>选项<ul><li>是否在 JSON 字符串中保留缩进</li></ul></li></ul></li></ul><h5 id="过滤结果"><a href="#过滤结果" class="headerlink" title="过滤结果"></a>过滤结果</h5><ul><li><p>如果过滤器参数是数组，那么 stringily() 的结果中将只包含数组中列出的属性</p></li><li><p>如果是函数：该函数接收两个参数（属性名，属性值），根据属性名进行自定义序列化</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"Professional JavaScript"</span>,</span><br><span class="line">  <span class="string">"authors"</span>: [</span><br><span class="line">    <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">  ],</span><br><span class="line">  edition: <span class="number">3</span>,</span><br><span class="line">  year: <span class="number">2011</span></span><br><span class="line">&#125;;<span class="comment">// js 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(key)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"authors"</span>: <span class="keyword">return</span> value.join(<span class="string">","</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"year"</span>: <span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"edition"</span>: <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;"title":"Professional JavaScript","authors":"Nicholas C. Zakas","year":5000&#125;</span></span><br></pre></td></tr></table></figure><h5 id="字符串缩进"><a href="#字符串缩进" class="headerlink" title="字符串缩进"></a>字符串缩进</h5><ul><li>数字：空格数，最大缩进空格数 10</li><li>字符串：缩进字符，不是用空格，最长10</li></ul><h5 id="toJSON-方法"><a href="#toJSON-方法" class="headerlink" title="toJSON() 方法"></a>toJSON() 方法</h5><p>Date 对象自带，也可以自定义</p><p>做为函数过滤器的补充</p><blockquote><p> stringify() 执行顺序</p><ol><li>如果存在 toJSON() <ul><li>能取得有效值就调用</li><li>否则返回对象本身</li></ul></li><li>如果提供了过滤器（第2个参数）<ul><li>应用过滤器，传入的值是 1 返回的值</li></ul></li><li>对 2 返回的每个值进行相应的序列化</li><li>如果提供第 3 个参数，执行相应的格式化</li></ol></blockquote><h3 id="解析选项"><a href="#解析选项" class="headerlink" title="解析选项"></a>解析选项</h3><ul><li><code>JSON.parse()</code> 参数<ul><li>还原函数 reviver<ul><li>在每个键值对上调用</li><li>接收两个参数（属性即键，值）</li><li>返回 undefined 表示删除相应的键</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十七章 错误处理与调试</title>
      <link href="/2020/03/10/%E7%AC%AC17%E7%AB%A0-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
      <url>/2020/03/10/%E7%AC%AC17%E7%AB%A0-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="try-catch-语句"><a href="#try-catch-语句" class="headerlink" title="try-catch 语句"></a>try-catch 语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 可能会导致错误的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">  <span class="comment">// 在错误发生时怎么处理</span></span><br><span class="line">  <span class="built_in">console</span>.log(error.message)</span><br><span class="line">  <span class="comment">// 所有浏览器都支持 message 属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>finally 子句<ul><li>无论 try 或 catch，都会执行 finally</li><li>如果 try 或 catch 中有 return，会被忽略<ul><li>因为一定要执行 finally</li></ul></li></ul></li><li>错误类型<ul><li>Error<ul><li>基类型，其它都继承这个</li><li>主要用于自定义</li></ul></li><li>EvalError<ul><li>没有把 eval() 当成函数调用，抛出异常<ul><li>eval() 函数在第五章</li></ul></li></ul></li><li>RangeError<ul><li>数值超出响应范围</li></ul></li><li>ReferenceError<ul><li>找不到对象</li></ul></li><li>SyntaxError<ul><li>传入语法错误的 JavaScript 给 eval()</li></ul></li><li>TypeError<ul><li>变量中保存着意外的类型</li><li>访问不存在的方法</li><li>执行特定于类型的操作时，变量类型不符合要求</li></ul></li><li>URIError<ul><li>encodeURI()、decodeURI() 时 URI 格式不正确</li></ul></li></ul></li></ul><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p><code>throw</code> 操作符</p><blockquote><p>捕获错误的目的在于避免浏览器以默认方式处理它们</p><p>抛出错误的目的在于提供错误发生具体原因的消息</p></blockquote><h3 id="错误（error）事件"><a href="#错误（error）事件" class="headerlink" title="错误（error）事件"></a>错误（error）事件</h3><p>没有通过 try-catch 处理的错误会触发 window 对象的 error 事件</p><h3 id="常见的错误类型"><a href="#常见的错误类型" class="headerlink" title="常见的错误类型"></a>常见的错误类型</h3><ul><li>类型转换错误<ul><li><code>===</code>  <code>!==</code></li><li><code>if</code> <code>for</code> <code>while</code></li></ul></li><li>数据类型错误<ul><li><code>typeof</code></li><li><code>instanceof</code></li></ul></li><li>通信错误<ul><li><code>encodeURIComponent()</code></li></ul></li></ul><h2 id="调试技术"><a href="#调试技术" class="headerlink" title="调试技术"></a>调试技术</h2><ul><li><code>error(message)</code></li><li><code>info(message)</code></li><li><code>log(message)</code></li><li><code>warn(message)</code></li></ul><h3 id="抛出错误-1"><a href="#抛出错误-1" class="headerlink" title="抛出错误"></a>抛出错误</h3><ul><li><code>throw</code></li><li><code>assert(条件, 如果条件不为 true 抛出的错误)</code> 可以代替 if 语句</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十四章 表单脚本</title>
      <link href="/2020/03/07/%E7%AC%AC14%E7%AB%A0-%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC/"/>
      <url>/2020/03/07/%E7%AC%AC14%E7%AB%A0-%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="第十四章-表单脚本"><a href="#第十四章-表单脚本" class="headerlink" title="第十四章 表单脚本"></a>第十四章 表单脚本</h1><h2 id="表单的基本知识"><a href="#表单的基本知识" class="headerlink" title="表单的基本知识"></a>表单的基本知识</h2><p>HTML 中，<code>&lt;form&gt;</code> 元素</p><p>Javascript 中，<code>HTMLFormElement</code>类型，继承 <code>HTMLElement</code></p><ul><li><code>acceptCharset</code> 服务器能够处理的字符集 <code>accept-charset</code></li><li><code>action</code> 接受请求的 URL <code>action</code></li><li><code>elements</code> 表单中所有控件集合 <code>HTMLCollection</code></li><li><code>enctype</code> 请求的编码类型 <code>enctype</code></li><li><code>length</code> 表单中控件的数量</li><li><code>method</code> 要发送的HTTP请求类型 get/post <code>method</code></li><li><code>name</code> 表单名称 <code>name</code></li><li><code>reset()</code> 将所有表单域重置为默认值</li><li><code>submit()</code> 提交表单</li><li><code>target</code> 用于发送和接受响应窗口的名称 <code>target</code></li></ul><h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><ul><li><p><code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 都可以定义提交按钮，<code>type = submit</code> 即可</p></li><li><p>提交表单时，浏览器将请求发送给服务器之前触发 submit 事件，这样就有机会验证表单数据。</p></li><li><p>提交表单最大的问题是重复提交表单</p><ul><li>第一次提交后禁用按钮</li><li>利用 onsubmit 事件处理程序 取消后续的表单提交操作</li></ul></li></ul><h3 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h3><ul><li><code>&lt;input&gt;</code> 或 <code>&lt;button&gt;</code> 中 <code>type = reset</code>，单击即可重置</li></ul><h3 id="表单字段"><a href="#表单字段" class="headerlink" title="表单字段"></a>表单字段</h3><p>每个表单都有 <code>elements</code> 属性，内容是所有表单元素的集合。集合是一个有序列表，包含表单中所有字段。</p><ul><li>共有的表单字段属性<ul><li><code>disabled</code></li><li><code>form</code></li><li><code>name</code></li><li><code>readOnly</code></li><li><code>tabIndex</code></li><li><code>type</code></li><li><code>value</code></li></ul></li><li>共有的表单字段方法<ul><li><code>focus()</code></li><li><code>blur()</code></li><li><code>autofocus</code> 页面加载时自动获得焦点</li></ul></li><li>共有的表单字段事件<ul><li><code>blur</code></li><li><code>change</code></li><li><code>focus</code><ul><li><code>blur</code> 和 <code>change</code> 先后顺序在各浏览器中不同</li></ul></li></ul></li></ul><h2 id="文本框脚本"><a href="#文本框脚本" class="headerlink" title="文本框脚本"></a>文本框脚本</h2><p><code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code></p><p>处理文本框时最好不要使用 DOM 方法（<code>setAttribute</code>）</p><h3 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h3><p><code>select()</code> 方法获得焦点时选择其所有文本</p><ul><li>选择事件</li><li>取得选择的文本<ul><li><code>selectionStart</code> 数值，开头位置</li><li><code>selectionEnd</code> 数值，结尾位置</li></ul></li><li>选择部分文本<ul><li><code>setSelectionRange()</code></li></ul></li></ul><h3 id="过滤输入"><a href="#过滤输入" class="headerlink" title="过滤输入"></a>过滤输入</h3><ul><li><p>屏蔽字符</p></li><li><p>操作剪贴板</p><ul><li><p>剪贴板事件</p><ul><li><code>beforecopy</code></li><li><code>copy</code></li><li><code>beforecut</code></li><li><code>cut</code></li><li><code>beforepaste</code></li><li><code>paste</code></li></ul></li><li><p>clipboardData 对象</p><ul><li><code>getData()</code></li><li><code>setData()</code></li><li><code>clearData()</code></li></ul></li></ul></li></ul><h3 id="自动切换焦点"><a href="#自动切换焦点" class="headerlink" title="自动切换焦点"></a>自动切换焦点</h3><p><code>tabForward()</code></p><h3 id="HTML5-约束验证-API"><a href="#HTML5-约束验证-API" class="headerlink" title="HTML5 约束验证 API"></a>HTML5 约束验证 API</h3><ul><li>必填字段 <code>required</code> 属性</li><li>其它输入类型<ul><li><code>email</code></li><li><code>url</code></li></ul></li><li>数值范围<ul><li><code>min</code></li><li><code>max</code></li></ul></li><li>输入模式 <code>pattern</code></li><li>检测有效性<ul><li><code>checkValidity()</code></li><li><code>validity</code></li></ul></li><li>禁用验证 <code>novalidate</code></li></ul><h2 id="选择框脚本"><a href="#选择框脚本" class="headerlink" title="选择框脚本"></a>选择框脚本</h2><p><code>&lt;select&gt;</code>、<code>&lt;option&gt;</code></p><ul><li><code>add(newOption, relOption)</code></li><li><code>multiple</code></li><li><code>options</code> 控件中所有 <code>&lt;option&gt;</code> 元素的 <code>HTMLCollection</code>，每个元素都是  <code>HTMLOptionElement</code> 对象<ul><li><code>index</code></li><li><code>label</code></li><li><code>selected</code></li><li><code>text</code></li><li><code>value</code></li></ul></li><li><code>remove(index)</code></li><li><code>selectedIndex</code></li><li><code>size</code></li></ul><h2 id="表单序列化"><a href="#表单序列化" class="headerlink" title="表单序列化"></a>表单序列化</h2><blockquote><p> 表单提交期间，浏览器怎样将数据发送给服务器？</p><ul><li><p>对表单字段的名称和值进行 URL 编码，使用 &amp; 分隔</p></li><li><p>不发送禁用的表单字段</p></li><li><p>只发送勾选的复选框和单选按钮</p></li><li><p>不发送 type 为 reset 和 button 的按钮</p></li><li><p>多选选择框中的每个选中的值单独一个条目</p></li><li><p>在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。</p></li><li><p>&lt;select&gt; 元素的值，就是选中的 &lt;option&gt; 元素的 value 特性的值</p></li></ul></blockquote><h2 id="富文本编辑"><a href="#富文本编辑" class="headerlink" title="富文本编辑"></a>富文本编辑</h2><p>WYSIWYG（What You See Is What You Get）</p><p>在页面中嵌入一个包含空 HTML 页面的 iframe</p><p>通过设置 designMode 属性，可以编辑，编辑的对象是该页面 body 元素的 HTML 代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十六章 HTMl5 脚本编程</title>
      <link href="/2020/03/07/%E7%AC%AC16%E7%AB%A0-HTMl5%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/03/07/%E7%AC%AC16%E7%AB%A0-HTMl5%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第十六章-HTML5-脚本编程"><a href="#第十六章-HTML5-脚本编程" class="headerlink" title="第十六章 HTML5 脚本编程"></a>第十六章 HTML5 脚本编程</h1><h2 id="跨文档消息传递-XDM"><a href="#跨文档消息传递-XDM" class="headerlink" title="跨文档消息传递 XDM"></a>跨文档消息传递 XDM</h2><p>来自不同域的页面间传递消息</p><ul><li><code>postMessage(消息，域)</code> 发送【消息】给【域】中的 <code>&lt;iframe&gt;</code> 元素</li><li>接收到 XDM 消息时，会触发 window 对象的 message 事件，异步，有延迟</li><li><code>onmessage</code><ul><li><code>data</code></li><li><code>origin</code></li><li><code>source</code></li></ul></li></ul><h2 id="原生拖放"><a href="#原生拖放" class="headerlink" title="原生拖放"></a>原生拖放</h2><h3 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h3><ol><li><code>dragstart</code> 按下鼠标触发</li><li><code>drag</code> 拖动期间持续触发</li><li><code>dragend</code> 拖动停止时触发，无论放置目标是否有效</li></ol><ul><li>当被拖动到一个有效的放置目标上</li></ul><ol><li><code>dragenter</code> 拖动到放置目标上</li><li><code>dragover</code> 放置目标范围内移动持续触发</li><li><code>dragleave</code> 拖出放置目标范围 或 <code>drop</code> 放到放置目标中</li></ol><h3 id="自定义放置目标"><a href="#自定义放置目标" class="headerlink" title="自定义放置目标"></a>自定义放置目标</h3><p>元素默认不允许放置，修改为可放置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> droptarget = <span class="built_in">document</span>.getElementById(<span class="string">"droptarget"</span>);</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragover"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragenter"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="dataTransfet-对象"><a href="#dataTransfet-对象" class="headerlink" title="dataTransfet 对象"></a>dataTransfet 对象</h3><p>用于从被拖动元素向放置目标传递字符串格式的数据</p><ul><li><code>getData()</code></li><li><code>setData()</code></li></ul><p>保存在 dataTransfer 对象中的数据只能在 drop 事件中被读取</p><ul><li><code>dropEffect</code> 被拖动元素能执行的放置行为<ul><li>none</li><li>move</li><li>copy</li><li>link</li></ul></li><li><code>effectAllowed</code> 允许拖动元素的哪种 dropEffect<ul><li>uninitialized</li><li>none</li><li>copy</li><li>link</li><li>move</li><li>copyLink</li><li>copyMove</li><li>linkMove</li><li>all</li></ul></li></ul><h3 id="可拖动"><a href="#可拖动" class="headerlink" title="可拖动"></a>可拖动</h3><p>默认情况下，图像、链接、文本可拖动</p><p>其它元素可以手动设置 draggable 属性为 ture</p><h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><p><code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code> 必须 src 指向要加载的媒体</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>表示媒体的当前状态</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>触发事件，监听属性变化，可能是播放结果，也可能是操作结果</p><h2 id="历史状态管理"><a href="#历史状态管理" class="headerlink" title="历史状态管理"></a>历史状态管理</h2><p>history 对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十三章 事件</title>
      <link href="/2020/03/05/%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E4%BB%B6/"/>
      <url>/2020/03/05/%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="第十三章-事件"><a href="#第十三章-事件" class="headerlink" title="第十三章 事件"></a>第十三章 事件</h1><p>js 和 html 之间的交互是通过<strong>事件</strong>实现的，事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。<br>可以使用<strong>侦听器</strong>来预定事件，以便事件发生时执行相应的代码。<br>这种在传统软件工程中被称为<strong>观察员模式</strong>的模型，支持 js 和 html+css 之间的松散耦合。</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p><strong>事件流</strong>描述的是从页面中接收事件的顺序</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>按照 DOM 树逐级向上，在每一级节点上都会发生，直到 document</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>顺序与事件冒泡相反</p><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><p>“DOM2 级事件”规定的事件流包括三个阶段：</p><ul><li>事件捕获阶段<ul><li>Document 到 目标元素的上一级</li></ul></li><li>处于目标阶段<ul><li>事件在目标元素上发生，事件处理被看成冒泡的一部分</li></ul></li><li>事件冒泡阶段<ul><li>目标元素 到 Document<blockquote><p>DOM2 规定捕获阶段不设计目标，但浏览器实现时都会出发事件对象上的事件</p></blockquote></li></ul></li></ul><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><ul><li><strong>事件</strong>就是某种动作，如 click、load、mouseovre</li><li><strong>事件处理程序（事件侦听器）</strong>就是响应事件的函数，以 on 开头，onclick、onload 等</li></ul><h3 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span><span class="params">()</span> </span>&#123;……&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果用户在页面解析事件处理程序之前点击元素，会引发错误</li><li>扩展作用域链在不同浏览器中会导致不同结果</li><li>HTML 与 JavaScript 代码紧密耦合</li></ul><h3 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h3><p>将一个函数赋值给事件处理程序属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;……&#125;</span><br></pre></td></tr></table></figure><ul><li>代码运行之前不会指定事件处理程序，可能导致点击无效</li><li>事件处理程序是在元素的作用域中运行的，this 引用当前元素</li><li>null 即删除</li></ul><h3 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h3><ul><li><p><code>addEventListener(a, b, c)</code></p></li><li><p><code>removeEventListener(a, b, c)</code></p><ul><li>a 要处理的事件名</li><li>b 作为事件处理程序的函数</li><li>c 一个布尔值<ul><li>true 捕获阶段调用事件处理程序</li><li>false 冒泡阶段调用事件处理程序 ☑️<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>事件处理程序是在元素的作用域中运行的，this 引用当前元素</p></li><li><p>存在多个事件处理程序会按照添加顺序触发</p></li><li><p>addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除</p></li><li><p>addEventListener() 添加的匿名函数无法移除</p></li></ul><h3 id="IE-事件处理程序"><a href="#IE-事件处理程序" class="headerlink" title="IE 事件处理程序"></a>IE 事件处理程序</h3><ul><li><p><code>attachEvent(a, b)</code></p></li><li><p><code>detachEvent(a, b)</code></p><ul><li>a 事件处理程序名称</li><li>b 事件处理程序函数</li></ul></li><li><p>只支持冒泡</p></li><li><p>事件处理程序的作用域是全局</p></li><li><p>存在多个事件处理程序会按照添加顺序相反的顺序触发</p></li></ul><h3 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h3><p>关注冒泡阶段</p><ul><li><code>addHandler(a, b, c)</code></li><li><code>EventUtil(a, b, c)</code><ul><li>a 要操作的元素</li><li>b 事件名称</li><li>c 事件处理程序</li></ul></li></ul><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与时间有关的信息</p><h3 id="DOM-中的事件对象"><a href="#DOM-中的事件对象" class="headerlink" title="DOM 中的事件对象"></a>DOM 中的事件对象</h3><p>兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中</p><ul><li><code>event.preventDefault()</code> 阻止特定事件的默认行为，如链接到默认行为是导航到 href</li><li><code>event.stopPropagation()</code> 停止事件在 DOM 层次中的传播（捕获或冒泡）</li><li><code>event.eventPhase</code> 确定事件当前正位于事件流的哪个阶段<ul><li>捕获 1</li><li>处于目标 2</li><li>冒泡 3</li></ul></li><li>事件处理器执行期间 event 对象才会存在，执行完就销毁</li></ul><h3 id="IE-中的事件对象"><a href="#IE-中的事件对象" class="headerlink" title="IE 中的事件对象"></a>IE 中的事件对象</h3><h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><p>不一定与用户操作有关</p><ul><li><code>load</code> 当页面完全加载后在 window 上触发，当图像加载完毕时在<img>元素上面触发</li><li><code>unload</code> 当页面完全卸载后在 window 上触发（页面切换时）</li><li><code>resize</code> 浏览器窗口调整大小时 window 上触发，通过 js 或 body 元素中 onresize 指定事件处理程序</li><li><code>scroll</code> window 对象上发生，表示页面中相应元素的变化</li></ul><h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><p>获得或失去焦点时触发</p><ul><li><code>document.hasFocus()</code></li><li><code>document.activeElement</code></li></ul><hr><ul><li><code>blur</code> 元素失去焦点时触发，不冒泡</li><li><code>focus</code> 获得焦点时触发，不冒泡</li><li><code>focusin</code> 获得焦点时，冒泡</li><li><code>focusout</code> 失去焦点时，冒泡</li></ul><h3 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h3><ul><li><code>click</code> 单击或回车</li><li><code>dblclick</code> 双击</li><li><code>mousedown</code> 按下任意鼠标按钮</li><li><code>mouseup</code> 释放鼠标按钮</li><li><code>mouseenter</code> 光标从外部首次移动到元素范围之内，不冒泡，移动到后代元素上不会触发</li><li><code>mouseleave</code> 元素上的光标移动到元素范围之外，不冒泡，移动到后代元素不触发</li><li><code>mousemove</code> 光标在元素内部移动时重复触发</li><li><code>mouseout</code> 鼠标位于一个元素上方，移入另一个元素时触发。另一个元素可能是原来元素的外部或子元素</li><li><code>mouseover</code> 光标位于一个元素外部，首次移入另一个元素边界之内</li></ul><hr><ul><li>客户区坐标位置<ul><li><code>event.clientX</code></li><li><code>event.clientY</code></li></ul></li><li>页面坐标位置<ul><li><code>event.pageX</code></li><li><code>event.pageY</code></li></ul></li><li>屏幕坐标位置<ul><li><code>event.screenX</code></li><li><code>event.screenY</code></li></ul></li><li>修改键<ul><li>click + 键盘 -&gt; 属性（Boolean）<ul><li>Shift <code>shiftKey</code></li><li>Ctrl <code>ctrlKey</code></li><li>Alt <code>altKey</code></li><li>Meta(Windows/Cmd) <code>metaKey</code></li></ul></li></ul></li><li>相关元素<ul><li>针对 <code>moseover</code>、<code>mouseout</code><ul><li><code>relatedTarget</code> 属性</li></ul></li></ul></li><li>鼠标按钮<ul><li>针对 <code>mousedown</code>、<code>mouseup</code><ul><li><code>button</code> 属性<ul><li>0 主鼠标</li><li>1 滚轮</li><li>2 次鼠标</li></ul></li></ul></li></ul></li><li>鼠标滚轮事件<ul><li><code>mousewheel</code><ul><li>冒泡</li><li><code>wheelDelta</code> 属性</li></ul></li></ul></li></ul><h3 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h3><ul><li><code>keydown</code> 任意键</li><li><code>keypress</code> 字符键</li><li><code>keyup</code> 释放案件</li></ul><hr><ul><li><code>event.keyCode</code> 键码，ASCII 小写字母相同</li><li><code>event.charCode</code> 字符编码，针对 keypress</li></ul><h3 id="变动事件"><a href="#变动事件" class="headerlink" title="变动事件"></a>变动事件</h3><ul><li>删除节点</li><li>插入节点</li></ul><h3 id="HTML5-事件"><a href="#HTML5-事件" class="headerlink" title="HTML5 事件"></a>HTML5 事件</h3><ul><li><code>contextmenu</code> 冒泡</li><li><code>beforeunload</code></li><li><code>DOMContentLoaded</code></li><li><code>readystatechange</code><ul><li>uninitialized</li><li>loading</li><li>loaded</li><li>interactive</li><li>complete</li></ul></li><li><code>pageshow</code> <code>pagehide</code></li><li><code>hashchange</code></li></ul><h3 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h3><p>智能手机和平板电脑</p><h3 id="触摸与手势"><a href="#触摸与手势" class="headerlink" title="触摸与手势"></a>触摸与手势</h3><h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><p>添加到页面上 的事件处理程序数量将直接关系到页面的整体运行性能</p><ul><li>函数对象占用内存</li><li>指定事件处理程序导致的 DOM 访问</li></ul><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>利用事件冒泡，只指定一个事件处理程序</p><h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><p>将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的 JavaScript 代码之间就 会建立一个连接。连接越多，页面执行起来就越慢。</p><h2 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h2><p>js 触发事件</p><h3 id="DOM-中的事件模拟"><a href="#DOM-中的事件模拟" class="headerlink" title="DOM 中的事件模拟"></a>DOM 中的事件模拟</h3><ul><li><p><code>document.createEvent()</code></p><ul><li>UIEvents</li><li>MouseEvents</li><li>MutationsEvents</li><li>HTMLEvents</li></ul></li><li><p>模拟鼠标</p></li><li><p>模拟键盘</p></li><li><p>模拟其他</p></li></ul><h3 id="IE-中"><a href="#IE-中" class="headerlink" title="IE 中"></a>IE 中</h3>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十章 DOM &amp; 第十一章 DOM 扩展 &amp; 第十二章 DOM2 和 DOM3</title>
      <link href="/2020/03/04/%E7%AC%AC10-12%E7%AB%A0-DOM%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/03/04/%E7%AC%AC10-12%E7%AB%A0-DOM%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a>第十章 DOM</h1><ul><li>针对 HTML 和 XML 文档的一个 API</li></ul><h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><ul><li><strong>文档元素</strong>是最外层元素，每个文档只有一个文档元素，HTML 中是 <code>html</code></li></ul><h3 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h3><ul><li>js 所有节点类型都继承自 Node 类型</li><li><code>nodeType</code> 值为 node 的类型常量（12种）<ul><li>元素节点 Node.ELEMENT_NODE(1)</li><li>文本节点 Node.TEXT_NODE(3)</li></ul></li></ul><h5 id="nodeName-和-nodeValue-属性"><a href="#nodeName-和-nodeValue-属性" class="headerlink" title="nodeName 和 nodeValue 属性"></a>nodeName 和 nodeValue 属性</h5><ul><li><code>nodeName</code> 元素标签名</li><li><code>nodeValue</code> 元素的值</li></ul><h5 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h5><p><img src="/.com//%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB.png" alt="节点关系.png"></p><ul><li><code>hashChildNodes()</code> </li><li><code>ownerDocument</code> 指向文档节点（最外层节点）</li></ul><h5 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h5><ul><li><code>appendChild(newNode)</code> childNodes 列表末尾添加一个节点<ul><li>如果 newNode 已经存在 DOM 树中，会移动位置，而不是新建</li></ul></li><li><code>insertBefore(NewNode, Node)</code> 将 NewNode 插入到 Node 前面的位置</li><li><code>replaceChild(NewNode, Node)</code></li><li><code>removeChild(Node)</code><br>以上方法通过父节点调用</li></ul><hr><p>以下方法所有节点都有</p><ul><li><code>cloneNode(Boolean)</code><ul><li>true 深复制，整个子节点树</li><li>false 浅复制，节点本身</li><li>返回的节点属于文档，但没有父节点</li></ul></li><li><code>normalize()</code> 处理文档节点</li></ul><h3 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h3><p>浏览器中 document 对象是 <code>HTMLDocument</code>（继承自 Document 类型）的一个实例，是 window 对象的一个属性</p><ul><li>nodeType = 9</li><li>nodeName = “#document”</li><li>nodeValue = null</li><li>parentNode = null</li><li>ownerDocument = null</li><li>子节点可能是一个 DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction 或 Comment</li></ul><h5 id="文档的子节点"><a href="#文档的子节点" class="headerlink" title="文档的子节点"></a>文档的子节点</h5><ul><li><code>document.documentElement</code> 始终指向 HTML 页面中的 <code>html</code> 元素</li><li><code>document.body</code> 指向 <code>body</code> 元素</li><li><code>document.doctype</code> </li></ul><h5 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h5><p>浏览器专供属性，存在 HTTP 头部</p><ul><li><code>document.title</code></li><li><code>document.URL</code></li><li><code>document.domain</code></li><li><code>document.referrer</code></li></ul><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><ul><li><code>document.getElementById()</code> 多个元素相同 id 则返回第一个</li><li><code>document.getElementsByTagName()</code> 返回 NodeList，HTML 文档中返回 <code>HTMLCollection</code> 对象</li><li><code>document.getElementsByName()</code> 返回 <code>HTMLCollection</code> 对象</li></ul><h5 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h5><ul><li><code>document.anchors</code></li><li><code>document.forms</code></li><li><code>document.images</code></li><li><code>document.links</code> 带 href 特性的 a 元素</li></ul><h5 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h5><ul><li><code>document.write()</code></li><li><code>document.writeln()</code></li><li><code>document.open()</code> 打开网页输出流</li><li><code>document.close()</code> 关闭网页输出流</li></ul><h3 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h3><ul><li>nodeType = 1</li><li>nodeName = 元素的标签名</li><li>nodeValue = null</li><li>parentNode 可能是 Document 或 Element</li><li>子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference</li></ul><p><code>nodeName</code> 和 <code>tagName</code> 属性都是标签名</p><h5 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h5><p>HTMLElement 继承 Element 并添加了一些属性</p><ul><li><code>id</code></li><li><code>title</code></li><li><code>lang</code></li><li><code>dir</code></li><li><code>className</code></li></ul><h5 id="操作特性"><a href="#操作特性" class="headerlink" title="操作特性"></a>操作特性</h5><ul><li><code>getAttribute(‘class’)</code></li><li><code>setAttribute(‘class’, &#39;ft&#39;)</code></li><li><code>removeAttribute(&#39;class&#39;)</code></li></ul><h5 id="attributes-属性"><a href="#attributes-属性" class="headerlink" title="attributes 属性"></a>attributes 属性</h5><p><code>attributes</code> 属性中包含一个 <code>NamedNodeMap</code> 对象，元素每个特性都由一个 Attr 节点表示，节点保存在 <code>NamedNodeMap</code> 对象中<br>对象方法</p><ul><li><code>getNamedItem(name)</code></li><li><code>removeNamedItem(name)</code></li><li><code>setNamedItem(node)</code></li><li><code>item(pos)</code></li></ul><p>节点属性</p><ul><li><code>nodeName</code></li><li><code>nodeValue</code></li></ul><h5 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h5><ul><li><code>document.createElement(标签名)</code><br>创建完成后需要调用前面介绍的方法将其添加到文档树中</li></ul><h3 id="Text-类型（开始和结束标签中的文本）"><a href="#Text-类型（开始和结束标签中的文本）" class="headerlink" title="Text 类型（开始和结束标签中的文本）"></a>Text 类型（开始和结束标签中的文本）</h3><ul><li>nodeType = 3</li><li>nodeName = #text</li><li>nodeValue 节点所包含的文本</li><li>parentNode 是 Element</li><li>没有子节点</li></ul><hr><ul><li><code>document.createTextNode()</code> 创建文本节点</li><li><code>normalize()</code> 相邻的文本节点之间不存在空格，可以将所有相邻的文本节点拼接起来</li><li><code>splitText()</code> 分割文本节点</li></ul><h3 id="Comment-类型"><a href="#Comment-类型" class="headerlink" title="Comment 类型"></a>Comment 类型</h3><ul><li>nodeType = 8</li><li>nodeName = #comment</li><li>nodeValue = 注释的内容</li><li>parentNode 可能是 Document 或 Element</li><li>没有子节点</li></ul><h3 id="CDATASection-类型"><a href="#CDATASection-类型" class="headerlink" title="CDATASection 类型"></a>CDATASection 类型</h3><ul><li>针对 XML 文档，表示 CDATA 区域</li><li>浏览器会解析为 Comment 或 Element</li></ul><h3 id="DocumentType-类型"><a href="#DocumentType-类型" class="headerlink" title="DocumentType 类型"></a>DocumentType 类型</h3><p>包含 doctype 有关的信息</p><h3 id="DocumentFragment-类型"><a href="#DocumentFragment-类型" class="headerlink" title="DocumentFragment 类型"></a>DocumentFragment 类型</h3><h3 id="Attr-类型"><a href="#Attr-类型" class="headerlink" title="Attr 类型"></a>Attr 类型</h3><p>元素的特性，不是 DOM 文档树的一部分</p><h2 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h2><h3 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h3><p>DOM 操作 script 标签</p><h3 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h3><p>DOM 操作 link 标签 和 style 标签</p><h3 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h3><p>DOM 操作 table 标签</p><h3 id="使用-NodeList"><a href="#使用-NodeList" class="headerlink" title="使用 NodeList"></a>使用 NodeList</h3><ul><li><code>NodeList</code></li><li><code>NamedNodeMap</code></li><li><code>HTMLCollection</code><br>每当文档结构发生变化，它们都会更新，保存最新的信息</li></ul><blockquote><p>理解 DOM 的关键，就是理解 DOM 对性能的影响。DOM 操作往往是 JavaScript 程序中开销最大的 部分，而因访问 NodeList 导致的问题为最多。NodeList 对象都是“动态的”，这就意味着每次访问 NodeList 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作。</p></blockquote><h1 id="第十一章-DOM-扩展"><a href="#第十一章-DOM-扩展" class="headerlink" title="第十一章 DOM 扩展"></a>第十一章 DOM 扩展</h1><h2 id="选择符-API"><a href="#选择符-API" class="headerlink" title="选择符 API"></a>选择符 API</h2><ul><li>参数为 CSS 选择符<ul><li><code>querySelector()</code> 返回元素</li><li><code>querySelectorAll()</code> 返回 NodeList 快照</li></ul></li></ul><h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><ul><li><code>childElementCount</code> 不包括文本节点和注释</li><li><code>firstElementChild</code></li><li><code>lastElementChild</code></li><li><code>previousElementSibling</code></li><li><code>nextElementSibling</code></li></ul><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="与类相关的扩充"><a href="#与类相关的扩充" class="headerlink" title="与类相关的扩充"></a>与类相关的扩充</h3><ul><li><code>getElementsByClassName()</code></li><li><code>classList</code> DOMTokenList 的实例</li></ul><h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><ul><li><code>activeElement</code> 当前获得焦点的元素</li><li><code>hasFocus()</code> 文档是否获得焦点（用户是否正在与页面交互）</li></ul><h3 id="HTMLDocument-的变化"><a href="#HTMLDocument-的变化" class="headerlink" title="HTMLDocument 的变化"></a>HTMLDocument 的变化</h3><ul><li><code>readyState</code> 属性<ul><li>loading</li><li>complete</li></ul></li><li><code>compatMode</code> 兼容模式<ul><li>CSS1Compat 标准模式</li><li>BackCompat 混杂模式</li></ul></li><li><code>head</code> 引用 head 标签元素</li></ul><h3 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h3><ul><li><code>charset</code> 默认 ”UTF-16“</li><li><code>defaultCharset</code> 根据默认浏览器及操作系统设置</li></ul><h3 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h3><ul><li>添加前缀 data-</li><li><code>dataset</code> 属性访问自定义属性的值<ul><li>值是 DOMStringMap 的一个实例</li><li>也就是一个名值对的映射</li></ul></li></ul><h3 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h3><ul><li><code>innerHTML</code> 属性</li><li><code>outerHTML</code> 属性</li><li><code>insertAdjacentHTML()</code> 方法<ul><li>params1 插入位置<ul><li>beforebegin</li><li>afterbegin</li><li>beforeend</li><li>afterend</li></ul></li><li>params2 HTML 文本</li></ul></li><li>内存与性能问题</li></ul><h3 id="scrollIntoView-方法"><a href="#scrollIntoView-方法" class="headerlink" title="scrollIntoView() 方法"></a>scrollIntoView() 方法</h3><p>让当前的元素滚动到浏览器窗口的可视区域内</p><h1 id="第十二章-DOM2-和-DOM3"><a href="#第十二章-DOM2-和-DOM3" class="headerlink" title="第十二章 DOM2 和 DOM3"></a>第十二章 DOM2 和 DOM3</h1><p>DOM1 主要定义的是 HTML 和 XML 文档的底层结构，DOM2 和 DOM3 分为许多模块，分表描述 DOM 的某个非常具体的子集，目的在于扩展 DOM API</p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>定义样式</p><ul><li><code>&lt;link/&gt;</code> 外部样式表</li><li><code>&lt;style/&gt;</code> 嵌入式样式</li><li><code>style 特性</code> 针对特定元素的样式</li></ul><h3 id="访问元素的样式"><a href="#访问元素的样式" class="headerlink" title="访问元素的样式"></a>访问元素的样式</h3><ul><li>元素的 style 特性是 <code>CSSStyleDeclaration</code> 的实例</li><li>CSS 属性的短线转为驼峰才能通过 js 访问</li><li>float 是保留字所以 转为 cssFloat</li></ul><h3 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h3><p>CSSStyleSheet 类型表示的是样式表，继承自 StyleSheet，后者可以作为一个基础接口来定义非 CSS 样式表</p><h3 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h3><ul><li><p>偏移量<br><img src="/.com//%E5%81%8F%E7%A7%BB%E9%87%8F.png" alt="偏移量.png"></p></li><li><p>客户区大小<br><img src="/.com//%E5%AE%A2%E6%88%B7%E5%8C%BA%E5%A4%A7%E5%B0%8F.png" alt="客户区大小.png"></p></li></ul><p>所有偏移量、客户区大小都是只读的，每次访问要重新计算。避免重复访问，有需要可以保存下来。</p><ul><li><p>滚动大小<br><img src="/.com//%E6%BB%9A%E5%8A%A8%E5%A4%A7%E5%B0%8F.png" alt="滚动大小.png"></p></li><li><p>确定元素大小<br><code>getBoundingClientRect()</code> 返回 DOMRect 对象，包含四个值<br><img src="/.com//%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F.png" alt="确定元素大小.png"></p></li></ul><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul><li>NodeIterator</li><li>TreeWalker</li></ul><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><ul><li>范围是选择 DOM 结构中特定部分，然后再执行相应操作的一种手段。</li><li>使用范围选区可以在删除文档中某些部分的同时，保持文档结构的格式良好，或者复制文档中的相应部分。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八章 BOM</title>
      <link href="/2020/03/02/%E7%AC%AC8%E7%AB%A0-BOM/"/>
      <url>/2020/03/02/%E7%AC%AC8%E7%AB%A0-BOM/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-BOM"><a href="#第八章-BOM" class="headerlink" title="第八章 BOM"></a>第八章 BOM</h1><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><ul><li>BOM 的核心对象是 window，表示浏览器的一个实例<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3></li><li>Window 作为 Global 对象，所有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法</li><li>全局变量不能通过 delete 删除，直接在 window 对上定义的属性可以</li></ul><h3 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h3><ul><li><code>window.screenLeft</code></li><li><code>window.screenTop</code></li><li><code>window.screenX</code></li><li><code>window.screenY</code></li><li><code>window.moveTo(x, y)</code></li><li><code>window.moveBy(a, b)</code></li></ul><h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><ul><li><code>window.innerWidth</code></li><li><code>window.innerHeight</code></li><li><code>window.outerWidth</code></li><li><code>window.outerHeight</code></li><li><code>window.resizeTo(w, h)</code></li><li><code>window.resizeBy(w, h)</code></li></ul><h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><ul><li><code>window.open(URL, target, String, Boolean)</code></li></ul><h3 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h3><ul><li><code>setTimeout(function, ms)</code><ul><li>ms 后把当前任务添加到任务队列，如果此时任务队列是空的才会立即执行<ul><li>所以不一定 ms 后就会执行 function</li></ul></li><li>返回一个数值 ID</li></ul></li><li><code>clearTimeout(timeoutID)</code></li><li><code>setInterVal(function, ms)</code></li><li><code>clearInterval(timeoutID)</code></li></ul><h3 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h3><p>样式由操作系统或浏览器决定<br>显示这些对话框的时候代码会停止执行</p><ul><li><code>alert()</code></li><li><code>confirm()</code></li><li><code>prompt()</code></li><li><code>find()</code></li><li><code>print()</code></li></ul><h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><ul><li>既是 window 对象的属性，也是 document 对象的属性</li><li>window.LOcation 和 document.location 引用的是同一个对象</li></ul><h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><ul><li><p><code>location.assign(url)</code></p></li><li><p><code>window.location = &quot;url&quot;</code></p></li><li><p><code>location.href = &quot;url&quot;</code><br>修改 location 其它属性页面都会重新加载，浏览器的历史记录会生产一条新记录</p></li><li><p><code>replace(url)</code> 不会产生新记录</p></li><li><p><code>reload()</code> </p><ul><li>无参数，可能是用缓存</li><li>参数 true，强制从服务器重新加载</li><li>调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。最好将 reload()放在代码的最后一行</li></ul></li></ul><h2 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h2><h2 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h2><ul><li><code>history.go()</code><ul><li>number 前进或后退页面</li><li>string 跳转到历史记录中包含string最近的位置</li></ul></li><li><code>history.back()</code> 后退</li><li><code>history.forward()</code> 前进</li><li><code>history.length</code> 历史记录数量</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十五章 使用 Canvas 绘图</title>
      <link href="/2020/03/02/%E7%AC%AC15%E7%AB%A0-%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%9B%BE/"/>
      <url>/2020/03/02/%E7%AC%AC15%E7%AB%A0-%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol><li>设置 width 和 height 属性，制定绘图区域<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"drawing"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span>A drawing of something.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>取得绘图上下文<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定浏览器支持 &lt;canvas&gt; 元素</span></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>导出绘制的图像<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123;</span><br><span class="line">    <span class="comment">//取得图像的数据 URI</span></span><br><span class="line">    <span class="keyword">var</span> imgURI = drawing.toDataURL(<span class="string">"imge/png"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示图像</span></span><br><span class="line">    <span class="keyword">var</span> image = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">    image.src = imgURI;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2D上下文"><a href="#2D上下文" class="headerlink" title="2D上下文"></a>2D上下文</h2><ul><li>坐标开始于左上角，原点坐标 (0, 0)</li><li>x 越大靠右，y 越大靠下</li><li>width 和 height 表示水平和垂直两个方向上可用的像素数</li></ul><h3 id="填充和描边"><a href="#填充和描边" class="headerlink" title="填充和描边"></a>填充和描边</h3><ul><li><code>fillStyle</code> 填充（字符串、渐变对象或模式对象）</li><li><code>strokeStyle</code> 描边（字符串、渐变对象或模式对象）</li><li><code>lineWidth</code> 线条宽度（整数）</li><li><code>lineCap</code> 线条末端形状（“butt”、“round”、“square”）</li><li><code>lineJoin</code> 线条相交形状（“round”、“bevel”、“miter”）</li></ul><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><ul><li><code>fillRect(x, y, w, h)</code></li><li><code>strokeRect(x, y, w, h)</code></li><li><code>clearRect(x, y, w, h)</code><ul><li>x: x 坐标</li><li>y: y 坐标</li><li>w: 矩形宽度</li><li>h: 矩形高度</li></ul></li></ul><h3 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h3><ol><li>调用<code>beginPath()</code>表示开始绘制新路径</li><li>绘制路径<ul><li><code>arc(x, y, radius, startAngle, endAngle, counterclockwise)</code> </li><li><code>arcTo(x1, y1, x2, y2, radius)</code> </li><li><code>bezierCurveTo(c1x, c1y, c2x, c2y, x, y)</code></li><li><code>lineTo(x, y)</code></li><li><code>moveTo(x, y)</code></li><li><code>quadraticCurveTo(cx, cy, x, y)</code></li><li><code>rect(x, y, width, height)</code></li></ul></li><li>绘制到画布<ul><li><code>closePath()</code></li><li><code>fill()</code></li><li><code>stroke()</code></li><li><code>clip()</code></li></ul></li></ol><ul><li><code>isPointInpath(x, y)</code> 点(x, y)是否在路径上</li></ul><h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><ul><li><code>fillText(string, x, y, (可选)font-size)</code></li><li><code>strokeText(string, x, y, (可选)font-size)</code></li></ul><hr><ul><li><code>font</code> 文本样式、大小、字体</li><li><code>textAlign</code> 文本对齐方式</li><li><code>textBaseline</code> 文本基线</li></ul><hr><ul><li><code>measureText()</code> 确定文本大小</li></ul><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><ul><li><code>rotate(angle)</code> 绕原点旋转图像</li><li><code>scale(scaleX, scaleY)</code> 缩放图像</li><li><code>translate(x, y)</code> 将坐标原点移动到 (x, y)</li><li><code>transform(m1_1, m1_2, m2_1, m2_2, dx, dy)</code> 修改变换矩阵</li><li><code>setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)</code> 将变换矩阵重置为默认状态再调用 transform()</li></ul><hr><ul><li><code>save()</code> 保存上下文状态</li><li><code>restore()</code> 读取保存的状态</li></ul><h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><ul><li><code>drawImage()</code><ul><li>要绘制的图像</li><li>源图像的 x 坐标</li><li>源图像的 y 坐标</li><li>源图像的宽度</li><li>源图像的高度</li><li>目标图像的 x 坐标</li><li>目标图像的 y 坐标</li><li>目标图像的宽度</li><li>目标图像的高度</li></ul></li></ul><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><ul><li><code>shadowColor</code></li><li><code>shadowOffsetXr</code></li><li><code>shadowOffsetY</code></li><li><code>shadowBlur</code></li></ul><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><ol><li><code>cg = createLinearGradient()</code> 创建新的渐变，返回 CanvasGradient 对象</li><li><code>cg.addColorStop()</code> 制定色标</li><li><code>fillStyle = cg</code>/<code>strokeStyle = cg</code> 绘制</li></ol><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li>重复的图像</li><li><code>createPattern()</code></li></ul><h3 id="使用图像数据"><a href="#使用图像数据" class="headerlink" title="使用图像数据"></a>使用图像数据</h3><ul><li><code>getImageData()</code></li></ul><h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><ul><li><code>globalAlpha</code> 透明度</li><li><code>globalCompositionOperation</code><ul><li>source-over(默认值):后绘制的图形位于先绘制的图形上方</li><li>……</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 函数表达式</title>
      <link href="/2020/03/01/%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/03/01/%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>定义函数的方式</p><ol><li>函数声明<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionName(); <span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数声明提升</span></span><br><span class="line"><span class="comment">// 执行代码前会读取函数声明，意味着可以把函数声明放在调用后面</span></span><br></pre></td></tr></table></figure></li><li>函数表达式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionName(); <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有函数声明提升</span></span><br><span class="line"><span class="comment">// 使用前必须先赋值</span></span><br></pre></td></tr></table></figure><blockquote><p>function 关键字后面没有标识符，所以叫<strong>匿名函数</strong>，也叫<strong>拉姆达函数</strong>。</p></blockquote></li></ol><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        reutrn <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line">alert(anotherFactorial(<span class="number">4</span>)); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为调用 anotherFactorial(num) 时，函数内部会执行 factorial(num-1)，而此时 factorial 已经被置为 null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为 arguments.callee 即可，如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>闭包</strong>是指(有权访问[另一个函数作用域中的变量]的)函数。<br>创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">        <span class="comment">// 这个匿名函数的作用域链中包含 createComparisonFunction() 的作用域，所以这两行代码可以访问外部函数中的变量 propertyName</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当函数执行完毕后，局部活动对象会被销毁，内存仅保留全局作用域。但是闭包有所不同。<br>在另一个函数内部定义的函数会将包含它的函数（即外部函数）的活动对象添加到它的作用域链中。<br>因此，createComparisonFunction() 函数内部定义的匿名函数的作用域链中，实际上会包含外部函数 createComparisonFunction() 的活动对象。<br><img src="/.com//%E9%97%AD%E5%8C%85.png" alt="闭包.png"><br>在匿名函数从 createComparisonFunction() 中被返回后，它的作用域链被初始化为 包含 createComparisonFunction() 函数的活动对象和全局变量对象。<br>这样，匿名函数就可以访问在 createComparisonFunction() 中定义的所有变量。<br>同时，createComparisonFunction() 的活动对象由于被匿名函数的作用域链引用，在函数执行完毕之后不会被销毁。</p></blockquote><p>由于闭包会携带外部函数的作用域，因此会比其他函数占更多的内存。所以要慎重使用闭包。</p><h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><ul><li>闭包只能取得包含函数中每个变量的最新值</li><li>因为每个函数作用域链中都保存着外部函数的活动对象，是共享的，最后更新的内容会被引用。</li></ul><h3 id="关于-this-对象"><a href="#关于-this-对象" class="headerlink" title="关于 this 对象"></a>关于 this 对象</h3><ul><li>匿名函数的执行环境具有全局性，this 通常指向 window。用 call 或 apply 改变制定环境时会指向其他对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">" "</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(object.getNameFunc()());  <span class="comment">// "The Window My Object"</span></span><br><span class="line">alert(object.getName());  <span class="comment">// "My Object"</span></span><br></pre></td></tr></table></figure><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3></li><li>闭包会引用包含函数的整个活动对象，可以活动对象中的变量赋值 null 解除引用，保证内存正常回收。</li></ul><h2 id="模仿块级作用域（）私有作用域"><a href="#模仿块级作用域（）私有作用域" class="headerlink" title="模仿块级作用域（）私有作用域"></a>模仿块级作用域（）私有作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 定义并立即调用了一个匿名函数</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理解过程</span></span><br><span class="line"><span class="comment">// 定义一个函数并立即调用</span></span><br><span class="line"><span class="keyword">var</span> someFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;;</span><br><span class="line">someFunction();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用函数的值直接取代函数名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;(); <span class="comment">// 报错，函数声明后不能跟圆括号</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;)(); <span class="comment">// 正确，函数表达式可以跟圆括号</span></span><br></pre></td></tr></table></figure><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><ul><li><p>严格来说，js 中没有私有成员的概念，所有的对象属性都是公有的</p><blockquote><p>个人理解：oop 语言中私有成员不能被子类继承，而 js 中所有对象属性都能被继承，因此都是公有的</p></blockquote></li><li><p>但有私有变量的概念，任何在函数中定义的变量都可以认为是私有变量，因为不能在函数的外部访问这些变量</p></li><li><p>私有变量包括</p><ul><li>函数的参数</li><li>局部变量</li><li>在函数内部定义的其他函数</li></ul></li></ul><h6 id="特权方法：有权访问私有变量和私有函数的公有方法"><a href="#特权方法：有权访问私有变量和私有函数的公有方法" class="headerlink" title="特权方法：有权访问私有变量和私有函数的公有方法"></a>特权方法：有权访问私有变量和私有函数的公有方法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在构造函数中定义特权方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fasle;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数（没有var，全局变量）</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公有/特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><ul><li>模块模式：为单例创建私有变量和特权方法<ul><li>单例：只有一个实例的对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = &#123;</span><br><span class="line">    name: value,</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回单例的公共接口</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicProperty: <span class="literal">true</span>,</span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">     <span class="comment">//私有变量和私有函数</span></span><br><span class="line">     <span class="keyword">var</span> privateVariable = <span class="number">10</span>; </span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//创建对象</span></span><br><span class="line">     <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">     <span class="comment">//添加特权/公有属性和方法</span></span><br><span class="line">     object.publicProperty = <span class="literal">true</span>; </span><br><span class="line">     object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">         privateVariable++; </span><br><span class="line">         <span class="keyword">return</span> privateFunction(); </span><br><span class="line">         &#125;; </span><br><span class="line">     <span class="comment">//返回这个对象</span></span><br><span class="line">     <span class="keyword">return</span> object; </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 面向对象程序设计</title>
      <link href="/2020/02/28/%E7%AC%AC6%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2020/02/28/%E7%AC%AC6%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li>面向对象语言的标志是都有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。</li><li>而 ECMAScript 中没有类的概念，因此它的对象和基于类的语言中的对象有所不同。</li><li>ECMAscript 对象定义：<u>无序属性的集合，其属性可以包含基本值、对象或函数。</u></li><li>每个对象都是基于一个引用类型创建的。可以是原生类型，也可以是开发人员定义的类型。</li></ul><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><h5 id="属性数据"><a href="#属性数据" class="headerlink" title="属性数据"></a>属性数据</h5><ul><li><code>[[Configurable]]</code>:表示能否通过 delete 删除属性从而定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li><li><code>[[Enumerable]]</code>:表示能否通过 for-in 循环返回属性。</li><li><code>[[Writable]]</code>:表示能否修改属性的值。</li><li><code>[[Value]]</code>:包含设个属性的数据值。<blockquote><p><code>Object.defineProperty(属性所在对象，属性的名字，描述符对象)</code>：修改属性默认的特性</p></blockquote></li></ul><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><ul><li><code>[[Configurable]]</code>:表示能否通过 delete 删除属性从而定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li><li><code>[[Enumerable]]</code>:表示能否通过 for-in 循环返回属性。</li><li><code>[[Get]]</code>:在读取属性时调用的函数，默认值 <code>undefined</code>。</li><li><code>[[Set]]</code>:在写入属性时调用的函数，默认值 <code>undefined</code>。<blockquote><p>访问器属性不能直接定义，必须使用<code>Object.defineProperty()</code>来定义。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">     _year: <span class="number">2004</span>,</span><br><span class="line">     edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123; </span><br><span class="line">     <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="keyword">set</span>: function(newValue) &#123; </span><br><span class="line">     <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123; </span><br><span class="line">         <span class="keyword">this</span>._year = newValue; </span><br><span class="line">         <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>; </span><br><span class="line">alert(book.edition); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><ul><li><code>Object.defineProperties(对象，要添加和修改属性)</code> 通过描述赋一次定义多个属性<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3></li><li><code>Object.getOwnPropertyDescriptor(属性所在的对象，要读取其描述符的属性名称)</code>返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。</li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul><li>抽象了创建具体对象的过程<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3></li><li>定义在 Global 对象（浏览器即 window 对象）中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（this 就指向了这个新对象）</li><li>执行构造函数中的代码</li><li>返回新对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor == Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h5><ul><li>构造函数与其他函数唯一的区别是调用方式不同<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">person.sayName();</span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"><span class="built_in">window</span>.sayName();</span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">o.sayName();</span><br></pre></td></tr></table></figure></li></ul><h5 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h5><ul><li><p>每个方法都要在每个实例上重新创建一遍</p></li><li><p>不同实例上的同名函数是不相等的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> <span class="keyword">this</span>.age = age; </span><br><span class="line"> <span class="keyword">this</span>.job = job; </span><br><span class="line"> <span class="keyword">this</span>.sayName = sayName; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> alert(<span class="keyword">this</span>.name); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果需要很多方法，就需要定义很多全局函数</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3></li><li><p>每个函数都有 prototype（原型）属性</p><ul><li>是一个指针，指向一个对象<ul><li>对象包含所有实例共享的属性和方法</li><li>换句话说，prototype 就是通过调用构造函数而创建的对象实例的原型对象</li></ul></li></ul></li><li><p>好处</p><ul><li>让所有对象实例共享它所包含的属性和方法</li><li>不必在构造函数中定义对象实例的信息，而且将这些信息直接添加到原型对象中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Grey"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Doctor"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h5></li></ul></li><li><p>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象</p></li><li><p>默认情况下，所有原型对象会自动获得一个 constructor(构造函数) 属性，这个属性包含一个指向 prototype 属性所在函数（也就是构造函数）的指针</p></li><li><p><code>Person.prototype.constructor</code> 指向 <code>Person</code><br><img src="/.com//%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p></li><li><p>每个实例有一个<code>[[Prototype]]</code>（<code>__proto__</code>）属性，指向构造函数的原型对象</p></li><li><p><code>isPrototypeOf()</code>确定原型关系</p><ul><li><code>Person.prototype.isPrototypeOf(person)</code></li></ul></li><li><p><code>Object.getPrototypeOf()</code> 返回[[Prototype]] 的指针</p><ul><li><code>Object.getPrototypeOf(person) == Person.prototype</code></li></ul></li><li><p>在实例中修改属性值，会屏蔽原型中的同名属性</p><ul><li><code>delete person.name</code> 删除实例中的 name 属性，<code>console.log(person.name)</code> 将输出原型中的 name 属性 <code>Person.prototype.name</code></li></ul></li><li><p><code>hasOwnProperty()</code> 检测一个属性是否在实例中，false 来自原型</p></li></ul><h5 id="原型与-in-操作符"><a href="#原型与-in-操作符" class="headerlink" title="原型与 in 操作符"></a>原型与 in 操作符</h5><ul><li>单独使用<ul><li>属性 in 实例</li><li>无论属性在实例还是在原型，都返回 true</li></ul></li><li>for-in<ul><li>返回可枚举的（enumerated）属性</li><li>无论属性在实例还是在原型<blockquote><p><code>Object.keys(对象)</code> 返回所有可枚举属性名<br><code>Object.getOwnPropertyNames(对象)</code> 返回所有属性名</p></blockquote></li></ul></li></ul><h5 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Grey"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Doctor"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>字面量形式创建原型<ul><li><code>Person.prototype.constructor</code> 不再指向 Person</li><li>（前面说）每创建一个函数，就会同时创建它的 prototype 对象，这个对象自动获得 constructor 属性</li><li>这里完全重写了默认的 prototype 对象，constructor 属性指向 Object 构造函数<h5 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h5></li></ul></li><li>实例中的指针仅指向原型，而不指向构造函数</li><li>重写原型对象切断了现有原型与之前任何一件存在的对象实例直接的联系；对象实例引用的原型是重写之前的</li></ul><h5 id="原型模式的缺点"><a href="#原型模式的缺点" class="headerlink" title="原型模式的缺点"></a>原型模式的缺点</h5><p>如果原型包含引用类型值的属性，由于原型中的值是所有实例对象共享的，在一个实例对象中修改引用类型，会体现在别的实例对象中</p><h3 id="组合使用构造函数模型和原型模式"><a href="#组合使用构造函数模型和原型模式" class="headerlink" title="组合使用构造函数模型和原型模式"></a>组合使用构造函数模型和原型模式</h3><ul><li>构造函数模型用于定义实例属性</li><li>原型模式用于定义方法和共享属性</li></ul><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><ul><li><p>在构造函数中检查是否存在某个方法，再决定是否需要初始化原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3></li><li><p>不能用 instanceof</p></li><li><p>不推荐</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寄生构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3></li><li><p>稳妥对象</p><ul><li>没有公共属性，方法也不引用 this</li></ul></li><li><p>安全的环境中禁止使用 this 和 new</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只有 sayName() 能访问数据成员</p></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>面向对象语言中<ul><li>接口继承<ul><li>只继承方法签名</li></ul></li><li>实现继承<ul><li>继承实际的方法</li></ul></li></ul></li><li>ECMAScript 中函数没有签名，无法实现接口继承，故只支持实现继承<ul><li>依靠原型链<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3></li></ul></li><li>利用原型让一个引用类型继承另一个引用类型的属性和方法<blockquote><p>构造函数 A 和原型 A 都有一个指向原型对象 A 的指针，而原型对象 A 有一个指向构造函数 A 的指针。<br>让原型对象 A 等于另一个类型的实例 B。<br>此时原型对象 A（也就是实例 B）将包含一个指向原型对象 B 的指针，原型对象 B 中包含一个指向构造函数 B 的指针。<br>假如原型 B 又是另一个类型的实例 C，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。<br>这就是所谓原型链的基本概念。</p></blockquote></li></ul><h5 id="默认的原型"><a href="#默认的原型" class="headerlink" title="默认的原型"></a>默认的原型</h5><p>所有引用类型默认继承 Object，在原型链最后都是 Object 原型对象，包含一个指针指向 Object 构造函数。</p><h5 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h5><ul><li><code>实例 instanceof 构造函数</code> 实例的原型链中出现过构造函数就返回 true</li><li><code>原型对象.isPrototypeOf(实例)</code> 实例的原型链中出现过原型对象就返回 true</li></ul><h5 id="对象字面量创建原型方法会重写原型链"><a href="#对象字面量创建原型方法会重写原型链" class="headerlink" title="对象字面量创建原型方法会重写原型链"></a>对象字面量创建原型方法会重写原型链</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 导致上一行代码无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    getSubValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">    &#125;,</span><br><span class="line">    someOtherMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="原型链的缺点"><a href="#原型链的缺点" class="headerlink" title="原型链的缺点"></a>原型链的缺点</h5><ul><li>不能给超类型的构造函数传递参数<h3 id="借用构造函数（伪造对象-经典继承）"><a href="#借用构造函数（伪造对象-经典继承）" class="headerlink" title="借用构造函数（伪造对象/经典继承）"></a>借用构造函数（伪造对象/经典继承）</h3></li><li>在子类型构造函数的内部调用超类型构造函数（利用 call 或 apply）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承了 SuperType</span></span><br><span class="line">    SUperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以给超类型的构造函数传递参数<h3 id="组合继承（伪经典继承）"><a href="#组合继承（伪经典继承）" class="headerlink" title="组合继承（伪经典继承）"></a>组合继承（伪经典继承）</h3></li><li>最常用</li><li>组合原型链和借用构造函数</li><li>原型链实现对原型属性和方法的继承</li><li>借用构造函数实现对实例属性的继承</li><li>缺点<ul><li>调用两次超类型构造函数<ul><li>创建子类型原型</li><li>子类型构造函数内部</li></ul></li></ul></li></ul><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><ul><li><code>Object.create(作为新对象原型的对象， 作为新对象定义额外属性的对象)</code> 返回一个新对象</li></ul><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><ul><li>创建一个仅用于封装继承过程的函数，该<br>函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3></li><li>通过借用构造函数来继承属性</li><li>通过原型链的混成形式来继承方法</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 引用类型</title>
      <link href="/2020/02/22/%E7%AC%AC5%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/02/22/%E7%AC%AC5%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>引用类型</strong>是一种数据结构，用于将数据和功能组织在一起。</li><li>引用类型的值（对象）是引用类型的一个实例。</li><li><u>引用类型与类看起来相似，但并不相同。</u></li><li>ECMAScript 从技术上讲是一门面向对象的语言，但不具备传统的面向对象语言所支持的类和接口等基本结构。</li><li>引用类型也被称为<strong>对象定义</strong>，描述一类对象所具有的属性和方法。</li><li>ECMAScript 提供类很多原生引用类型（例如 Object）</li></ul><h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>大多数对象都是 Object 类型的实例</p><h6 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h6><ul><li>new 操作符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure></li><li>对象字面量<ul><li>对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义只包含默认属性和方法的对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><blockquote><p>通过对象字面量定义对象时，实际上不会调用 Object 构造函数<br>疑问：对象字面量是怎么定义对象的？</p></blockquote></li></ul></li></ul><h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>和其他语言的区别：每一项可以保存任何类型的数据，互相之间不影响</p><h6 id="创建实例-1"><a href="#创建实例-1" class="headerlink" title="创建实例"></a>创建实例</h6><ul><li>new<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>); <span class="comment">// length = 20</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Grey"</span>); <span class="comment">// length = 1</span></span><br></pre></td></tr></table></figure></li><li>省略 new<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// length = 3</span></span><br></pre></td></tr></table></figure></li><li>数组字面量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [];</span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br></pre></td></tr></table></figure><blockquote><p>数组字面量表示法时不会调用 Array 构造函数</p></blockquote></li></ul><hr><ul><li>length 可修改，会移除超出的项</li><li>当把一个值放在超出当前数组大小的位置上时，会重新计算长度，长度值为最后一项的索引 + 1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="comment">// ["red", "blue", "green"]</span></span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// ["red", "blue"]</span></span><br><span class="line">colors.length = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// ["red", "blue", empty]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// ["red", "blue", empty, "green"] length = 4</span></span><br></pre></td></tr></table></figure><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><code>value instanceof Array</code> 假定只有一个全局执行环境，如果从一个框架向另一个框架传入数组，就具有不同的构造函数<br><code>Array.isArray()</code><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3></li><li><code>Array.toString()</code></li><li><code>Array.toLocaleString()</code></li><li><code>Array.valueOf()</code><h3 id="栈-队列方法"><a href="#栈-队列方法" class="headerlink" title="栈/队列方法"></a>栈/队列方法</h3></li><li><code>Array.push</code> 末尾添加</li><li><code>Array.pop</code> 取最后一项并移除</li><li><code>Array.shift</code> 取第一项并移除</li><li><code>Array.unshift</code> 头部添加<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3></li><li><code>Array.reverse()</code> 反转顺序</li><li><code>Array.sort()</code> 先转 toString()，字符串升序<ul><li>sort 接收比较函数<ul><li>params1 -&gt; params2 ===&gt; -1</li><li>params2 -&gt; params1 ===&gt; 1<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3></li></ul></li></ul></li><li><code>Array.concat</code></li><li><code>Array.slice(a, b)</code> [a, b)<ul><li>负数则从末尾开始数</li></ul></li><li><code>Array.splice(a, b, ...c)</code><ul><li>a 位置</li><li>b 要删除的项数</li><li>c 插入的内容（若干）</li><li>return 被删除的内容</li></ul></li></ul><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>查找数组内容，<code>===</code>，返回下标</p><ul><li><code>Array.indexOf()</code></li><li><code>Array.lastIndexOf()</code><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3></li><li>两个参数<ul><li>要在每一项上运行的函数<ul><li>三个参数<ul><li>数组项的值</li><li>该项再数组中的位置</li><li>数组对象本身</li></ul></li></ul></li><li>（可选的）运行该函数的作用域对象<ul><li>影响this的值</li></ul></li></ul></li><li><code>Array.every()</code> 每一项都返回 true，则返回 true</li><li><code>Array.some()</code> 任一项返回 true，则返回 true</li><li><code>Array.filter()</code> 返回该函数返回 true 的项组成的数组</li><li><code>Array.map()</code> 返回每次函数调用的结果组成的数组</li><li><code>Array.forEach()</code> 没有返回值 </li></ul><p>以上方法都不回修改数组中包含的值</p><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><ul><li><p><code>Array.reduce()</code></p></li><li><p><code>Array.reduceRight()</code></p></li><li><p>两个参数</p><ul><li>每一项上调用的函数<ul><li>四个参数<ul><li>前一个值</li><li>当前值</li><li>项的索引</li><li>数组对象</li></ul></li></ul></li><li>（可选的）作为归并基础的初始值</li></ul></li><li><p>返回值作为第一个参数传给下一项</p></li><li><p>第一次迭代发生在第二项上，第一个参数是数组的第一项，第二个参数是数组的第二项</p></li></ul><h2 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h2><ul><li><code>Date.parse()</code> <ul><li>params: 表示日期字符串，格式因地区而异</li><li>return: 毫秒</li></ul></li><li><code>Date.UTC()</code><ul><li>params: 年份、月份（0开始）、天数、小时、分钟、秒、毫秒</li><li>return: 毫秒</li></ul></li><li><code>Date.now()</code><h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3></li><li><code>Date.toLocaleString()</code> 根据当地时区</li><li><code>Date.toString()</code> 带有时区信息</li><li><code>Date.valueOf()</code> 毫秒<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3></li><li><code>Date.toDateString()</code></li><li><code>Date.toTimeString()</code></li><li><code>Date.toLocaleDateString()</code></li><li><code>Date.toLocaleTimeString()</code></li><li><code>Date.toUTCString()</code></li><li><code>Date.toLocaleString()</code></li></ul><p>因浏览器而异</p><h2 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</span><br></pre></td></tr></table></figure><ul><li>pattern<ul><li>( [ { \ ^ $ | ) ? * + . ] } 需要转义</li></ul></li><li>flags<ul><li>g 全局，默认匹配第一个停止</li><li>i 不区分大小写</li><li>m 多行模式<h3 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h3></li></ul></li><li><code>global</code> </li><li><code>ignoreCase</code> </li><li><code>lastIndex</code> </li><li><code>multiline</code> </li><li><code>source</code> </li></ul><h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><ul><li><code>exec</code> </li><li><code>test</code> </li><li><code>toString</code> </li><li><code>toLocaleString</code> </li><li><code>valueOf</code> </li></ul><h3 id="构造函数属性"><a href="#构造函数属性" class="headerlink" title="构造函数属性"></a>构造函数属性</h3><p>其他语言中被看成是<strong>静态属性</strong></p><table><thead><tr><th>长属性名</th><th>短属性名</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>$_</td><td>最近一次要匹配的字符串</td></tr><tr><td>lastMatch</td><td>$&amp;</td><td>最近一次的匹配项</td></tr><tr><td>lastParen</td><td>$+</td><td>最近一次匹配的捕获组</td></tr><tr><td>leftContext</td><td>$`</td><td>input 字符串中 lastMatch 之前的文本</td></tr><tr><td>multiline</td><td>$*</td><td>布尔值，是否所有表达式都使用多行模式</td></tr><tr><td>rightContext</td><td>$’</td><td>input 字符串中 lastMatch 之后的文本</td></tr></tbody></table><h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><ul><li><p>每个函数都是 Function 类型的实例，具有属性和方法。</p></li><li><p>函数名是一个只想函数对象的指针，不会与某个函数绑定。</p><h5 id="创建实例-2"><a href="#创建实例-2" class="headerlink" title="创建实例"></a>创建实例</h5></li><li><p>函数声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>区别：<br>解析器会先读取函数声明，在执行任何代码之前可用（函数声明提升）<br>函数表达式要等解析器执行到它所在的代码行才会被解释执行</p></blockquote></li><li><p>Function 构造函数（不推荐）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>);</span><br></pre></td></tr></table></figure><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>声明两个同名函数，后面的函数覆盖前面的，结合 “函数是对象，函数名是指针” 很好理解。</p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3></li><li><p>函数名本身是变量，可以作为值来使用</p></li><li><p>可以作为参数，也可以作为返回值</p></li></ul><h3 id="函数的内部属性"><a href="#函数的内部属性" class="headerlink" title="函数的内部属性"></a>函数的内部属性</h3><ul><li><code>arguments</code> 类数组对象<ul><li><code>callee</code> 属性，该属性是一个指针，指向拥有这个 arguments 对象的函数</li></ul></li><li><code>this</code> 引用的是执行函数的环境对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sindow.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">// "red"</span></span><br><span class="line"></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();   <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure></li><li><code>caller</code> 调用当前函数的函数的引用，全局中调用当前函数则 null<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(inner.caller);</span><br><span class="line">    <span class="comment">// inner.callr 指向 outer()</span></span><br><span class="line">    <span class="comment">// 等价于 arguments.callee.caller</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3></li><li><code>length</code> 函数希望接收的命名参数的个数</li><li><code>prototype</code><ul><li>对引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，toString() 和 valueOf() 等方法都是保存在 prototype 名下，只是通过各自对象的实例访问。</li><li>不可枚举，for-in 无法发现。</li></ul></li></ul><p>每个函数都包含两个非继承而来的方法，都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。</p><ul><li><p><code>apply</code> </p><ul><li>两个参数<ul><li>在其中运行函数的作用域</li><li>参数数组</li></ul></li></ul></li><li><p><code>call</code> </p><ul><li>1 + n 个参数<ul><li>在其中运行函数的作用域</li><li>一个一个地传入参数</li></ul></li></ul></li><li><p><code>bind</code> 创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值</p></li></ul><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript 提供 3 个特殊的引用类型：<code>Boolean</code>、<code>Number</code>、<code>String</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"smoe.txt"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>基本类型不是对象，理论上不应该有方法。<br>当第二行代码访问 s1 时，访问过程处于一种读取模式，从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台自动完成：<br>(1) 创建 String 类型的一个实例<br>(2) 在实例上调用指定的方法<br>(3) 销毁这个实例</p></blockquote><ul><li>引用类型与基本包装类型的主要区别是对象的生存期<ul><li>引用类型的实例在执行流离开当前作用域之前一直保存在内存中</li><li>基本包装类型只存在于一行代码的执行瞬间</li></ul></li><li>可以显示的创建基本包装类型的对象，但会分不清自己在处理基本类型还是引用类型的值</li><li>new 调用基本包装类型的构造函数，和转型函数是不一样的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value); <span class="comment">// 转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number); <span class="comment">// "number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);     <span class="comment">// “object"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>布尔表达式中，所有的对象都会转为 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>产生误解，建议不要使用</p><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><ul><li><code>toString(n)</code> n 进制</li><li><code>toFixed(n)</code> 四舍五入 n 位小数</li><li><code>toExponential(n)</code> n 位数表示一个数字</li></ul><h4 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h4><ul><li><code>charAt</code></li><li><code>charCodeAt</code></li><li><code>方括号表示法[]下标读取字符</code></li></ul><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><ul><li><code>concat</code> 拼接字符串，常用<code>+</code></li><li><code>slice</code></li><li><code>substr</code></li><li><code>substring</code></li></ul><h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><ul><li><code>indexOf</code></li><li><code>lastIndexOf</code></li></ul><h4 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim() 方法"></a>trim() 方法</h4><p>创建一个字符串的副本，删除前置以及后缀的所有空格，然后返回结果</p><h4 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h4><ul><li><code>toLowerCase</code></li><li><code>toLocaleLowerCase</code></li><li><code>toUpperCase</code></li><li><code>toLocaleUpperCase</code></li></ul><h4 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h4><ul><li><code>match</code><ul><li>params:正则表达式或 RegExp 对象</li><li>本质调用 RegExp 的 exec</li></ul></li><li><code>search</code><ul><li>params:正则表达式或 RegExp 对象</li><li>return: 下标，找不到 -1</li></ul></li><li><code>replace</code> <ul><li>两个参数，用第二个参数替换第一个</li><li>第一个参数可以是正则</li><li>第二个参数可以是函数</li></ul></li><li><code>split</code> 基于一个制定的分隔符，将一个字符串分割成多个子字符串</li></ul><h4 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare() 方法"></a>localeCompare() 方法</h4><p>比较两个字符串，各地区实现不同</p><h4 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode() 方法"></a>fromCharCode() 方法</h4><p>接收一个或多个字符编码，然后转换成一个字符串</p><h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>ECMA-262对<strong>单体内置对象</strong>的定义：<u>由 ECMAScript 实现提供的，不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。</u></p><p>前面已经介绍了大多数内置对象，如 Object、Array、String</p><h3 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h3><ul><li>不属于任何其他对象的属性和方法，最终都是 Global 对象的属性和方法</li><li>事实上，没有全局变量或全局函数。所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。如<ul><li>isNan()、isFinite()、parseint()</li><li>encodeURI() 用于整个 URI<br>encodeURIEomponent() 用于 URI 中的一段<br>decodeURI()<br>decodeURIEomponent()</li><li>eval() 像一个完整的 ECMAScript 解析器<ul><li>params: 要执行的 ECMAScript 字符串</li></ul></li><li>Global 对象属性<ul><li>undefined、NaN、Infinity 等</li><li>Object、Function 等</li></ul></li><li>window 对象<ul><li>Web 浏览器中，Global 对象是 window 对象的一部分</li></ul></li></ul></li></ul><h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><ul><li>Math 对象的属性<ul><li>Math.E</li><li>Math.LN10</li><li>Math.LN2</li><li>Math.LOG2E</li><li>Math.LOG10</li><li>Math.PI</li><li>Math.SQRT1_2</li><li>Math.SQRT2</li></ul></li><li>min()、max()</li><li>舍入方法<ul><li>Math.ceil() 向上舍入</li><li>Math.floor() 向下舍入</li><li>Math.round() 四舍五入</li></ul></li><li>random() [0, 1) 随机数</li><li>其他方法<ul><li>Math.abs(num)</li><li>Math.exp(num)</li><li>Math.log(num)</li><li>Math.pow(num, power)</li><li>Math.sqrt(num)</li><li>Math.acos(x)</li><li>……</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 变量、作用域和内存问题</title>
      <link href="/2020/02/17/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/17/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><ul><li>基本数据类型（5）按值访问，可以操作保存在变量中的实际的值。占据固定大小的空间，被保存在栈内存中。</li><li>引用类型（1）的值是保存在内存中的对象，保存在堆内存中。JS 不能直接操作对象的内存空间：复制保存对象的某个变量时，操作对象的引用；为对象添加属性时，操作的是实际的对象。</li></ul><h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><ul><li>基本类型：创建新值</li><li>引用类型：创建新值，值是指针，实际与旧值引用同一个对象</li></ul><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript 中所有函数的参数都是按值传递的。</p><ul><li>基本类型：被传递的值会被复制给一个局部变量。</li><li>引用类型：被传递的值的<strong>地址</strong>复制给一个局部变量。因此这个局部变量的变化会反应在函数的外部。<blockquote><p>若在函数体内对这个局部变量进行重新赋值，那么保存的地址就改变了，指向的内存也不再是被传入的对象。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//“Nicholas”</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = <span class="string">"Greg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//“Nicholas”</span></span><br></pre></td></tr></table></figure><p>在内部重写 obj 时，变量引用的就是一个局部对象了。局部对象在函数执行完毕后立即被销毁。</p><h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><ul><li>基本类型：<code>typeof</code></li><li>引用类型：<code>instanceof</code></li><li>根据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result = variable instanceof constructor</span></span><br><span class="line"><span class="comment">// 根据原型链来识别</span></span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>);</span><br></pre></td></tr></table></figure>所有引用类型的值都是 Object 的实例。<code>Obj instanceof Object</code> 始终返回 true，检测基本类型始终 false，因为基本类型不是对象。</li></ul><h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><ul><li>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</li><li>每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的所有变量和函数都保存在这个对象中。</li><li><strong>全局执行环境</strong>：根据宿主环境。WEB 浏览器中是 window 对象。</li><li><strong>执行环境</strong>，函数的环境，保存在栈中。</li><li>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，<u>保证对执行环境有权访问的所有变量和函数的有序访问。</u><blockquote><p>作用域链的前端，始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>作为变量对象。活动对象在最开始时只包含一个变量（即arguments对象，全局环境中不存在）。下一个变量对象来自包含（外部）环境……一直到全局执行环境。<br>标识符解析是沿着作用域链一级一级地搜索标识符的过程。<br>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境重的变量和函数。</p></blockquote></li></ul><h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><ul><li>try-catch 语句的 catch 块</li><li>with 语句<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</span><br><span class="line">    <span class="keyword">with</span> (location) &#123;</span><br><span class="line">        <span class="keyword">var</span> url = href + qs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>with 语句接收 location 对象，因此其变量对象中包含了 location 对象的所有属性和方法，而这个变量被添加到了作用域链的前端。<blockquote><p>疑问：<br>作用域链：全局执行环境-&gt;buildUrl()-&gt;with(location)<br>with 中定义的变量 url 为什么能够在外部环境 buildUrl 中访问？url是被定义在全局执行环境中的 location 变量对象中吗？</p><hr><p>因为没有块级作用域，变量声明会被添加到当前的执行环境（这里是buildUrl（））中</p></blockquote></li></ul><h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(color);</span><br></pre></td></tr></table></figure><p>js 中，if 语句中的变量声明会将变量添加到当前的执行环境（这里是全局环境）<br>如果没有用 var 声明，会直接被添加到全局环境。</p><blockquote><p>let 似乎解决了这个问题，本书没有讲到，看完 es6 再来补。</p></blockquote><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><ul><li>当变量进入环境，标记为“进入环境”。<ul><li>逻辑上讲，永远不能释放进入环境的变量所占用的内存。</li></ul></li><li>当变量离开环境时，则标记“离开环境”。</li><li>可以使用任何方式来标记变量。如：<ul><li>翻转某个特殊的位</li><li>“进入环境”变量列表及“离开环境”变量列表<blockquote><p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后再被加上标记的变量将被视为准备删除的变量。最后完成内存清除工作，销毁值并回收内存空间。</p></blockquote></li></ul></li></ul><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>跟踪记录每个值被引用的次数，赋值给变量则该值+1，若变量取得另一个值，则该值-1。</p><blockquote><p>垃圾收集器下次运行时，释放计数 0 的值占用的内存。</p></blockquote><blockquote><p>循环引用会导致引用次数永远不为 0<br>BOM 和 DOM 中的对象是使用 C++ 以 COM（Component Object Model，组件对象模型）对象的形式实现的，COM 对象的垃圾收集机制就是引用计数策略。<br>解决：手动断开循环引用（赋值为null）</p></blockquote><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>垃圾收集器是周期运行的，如果为变量分配的内存数量很大，那么回收工作量也相当大，确定时间间隔很重要。</p><h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>使用具备垃圾收集机制的语言编写程序，一般不必操心内存管理。但 js 比较特殊，因为分配给 Web 浏览器的可用内存通常比桌面应用少。<br>尽量少用内存页面会有更好的性能。一旦数据不再有用，赋值 null 来<strong>解除引用</strong>。适用于大多数全局变量和全局对象的属性，局部变量会在离开执行环境时自动解除。<br>解除引用不是自动回收内存，是让值脱离环境，垃圾收集器下次运行的时候将其回收。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 基本概念</title>
      <link href="/2020/02/15/%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/02/15/%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>ECMAScript 标示符采用驼峰大小写格式</p><h3 id="严格模式-strict-mode"><a href="#严格模式-strict-mode" class="headerlink" title="严格模式 strict mode"></a>严格模式 strict mode</h3><p>在顶部添加代码 <code>&quot;use strict&quot;;</code><br>编译指示(pragma)，用于告诉支持的 JavaScript 引擎切换到严格模式。<br>函数体中包含指定函数在严格模式下执行。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>松散类型：可以用来保存任何类型的数据。每个变量仅仅用于保存值的占位符。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>5 基本数据类型 - <code>Undefined、Null、Boolean、Number、String</code><br>1 复杂数据类型 - <code>Object</code><br><code>Oobject</code> 本质上是由一组无序的名值对组成的<br>ECMAScript 不支持任何创建自定义类型的机制</p><p><code>typeof</code> 操作符，返回值（均为字符串）<br>未定义：<code>&quot;undefined&quot;</code><br>布尔值：<code>&quot;boolean&quot;</code><br>字符串：<code>&quot;string&quot;</code><br>数值：<code>&quot;number&quot;</code><br>对象或<code>null</code>：<code>&quot;object&quot;</code><br>函数：<code>&quot;function&quot;</code><br>特殊值 <code>null</code> 被认为是一个空的对象引用，因此返回 <code>&quot;object&quot;</code>。<br>safari 5 和 Chrome 7 及之前版本 <code>typeof 正则表达式</code> 会返回 <code>&quot;function&quot;</code>，而其他浏览器返回<code>&quot;object&quot;</code></p><blockquote><p>从技术角度讲，函数在 ECMAScript 中是对象，而不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 <code>typeof</code> 操作符区分函数和其他对象是有必要的。</p></blockquote><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><p><code>Undefined</code> 类型只有一个值，即 <code>undefined</code></p><blockquote><p>变量已声明但未初始化（message）：该变量的值为 <code>undefined</code>,<code>typeof</code> 返回<code>&quot;undefined&quot;</code><br>若变量未声明（age）：只可以执行<code>typeof</code> 操作符，返回<code>&quot;undefined&quot;</code>，其他操作产生错误。</p><p> <img src="/.com//%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="变量初始化"></p></blockquote><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h3><p><code>Null</code> 类型只有一个值，即 <code>null</code>，表示一个空对象指针，因此 <code>typeof null</code> 返回 <code>&quot;object&quot;</code>。<br>如果定义的变量准备用于保存对象，那么最好初始化为 <code>null</code>，可以直接判断是否已经保存了一个对象的引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>) &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，<code>undefined</code> 派生自 <code>null</code>，因此：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>); </span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。调用 <code>转型函数 Boolean()</code> 获得对应 Boolean 值。</p><table><thead><tr><th>数据类型</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>任何非空字符串</td><td>“”（空字符串）</td></tr><tr><td>Number</td><td>任何非零数字值（包括无穷大）</td><td>0 和 NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>N/A</td><td>undefined</td></tr><tr><td>N/A：not applicable 的缩写，不适用</td><td></td><td></td></tr></tbody></table><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>使用 <a href="https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin" target="_blank" rel="noopener">IEEE754</a> 格式来表示整数和浮点数值（双精度数值）。<br>为了支持各种数值类型，ECMA-262定义了不同的数值字面量格式。</p><ul><li>十进制</li><li>八进制（0）</li><li>十六进制（0x）<br>在进行算数计算时，都会转为十进制数值。<h5 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h5>浮点数值需要的内存空间是整数值的两倍。<br>6 个 0 以上，e表示法：3.125e7、3e-17<br>浮点数值最高精度 17 位小数，但在算数计算时精度远不如整数。<img src="/.com//%E7%B2%BE%E5%BA%A6.png" alt="精度"><br>（IEEE745 数值的浮点计算通病，不是 ECMAScript 独有）</li></ul><h5 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h5><p><code>Number.MIN_VALUE</code> 5e-324<br><code>Number.MAX_VALUE</code> 1.7976931348623157e+308<br><code>Number.POSITIVE_INFINITY</code> 或 <code>Infinity</code> 正无穷<br><code>Number.NEGATIVE_INFINITY</code> 或 <code>-Infinity</code> 负无穷<br><code>isFinite()</code>有穷返回 <code>true</code></p><h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><ul><li>任何涉及 NaN 的操作都会返回 NaN</li><li>NaN 与任何值都不相等，包括自己本身</li><li><code>isNaN()</code> 函数判断变量是否<strong>可以转为数值</strong></li></ul><blockquote><p>isNaN(object):<br>首先调用对象的 valueOf() 方法，检查该方法的返回值是否可以转换为数值<br>如果不能，基于这个返回值再调用 toString() 方法，再测试返回值。</p></blockquote><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><p><code>Number()</code> 任何类型<br><code>parseInt()</code> 字符串<br><code>parseFloat()</code> 字符串</p><blockquote><p>parseInt 和 parseFloat 从第一个符合条件的字符开始转换，开始后若碰到不符合的字符，抛弃之后的字符。</p></blockquote><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><ul><li>Unicode 字符组成的字符序列。</li><li>ECMAScript 中双引号/单引号没有区别。</li></ul><h5 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h5><p>字符字面量，即转义字符，被作为一个字符来解析。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>不可改变<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">"Java"</span>;</span><br><span class="line">lang = lang + <span class="string">"Script"</span>;</span><br><span class="line"><span class="comment">// 首先创建一个能容纳 10 个字符的新字符串，然后填充 “Java” 和 “Script”，最后销毁原来的字符串。（不在原字符串上修改）</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="转为字符串"><a href="#转为字符串" class="headerlink" title="转为字符串"></a>转为字符串</h5><ul><li><p><code>toString()</code> 几乎每个值都有这个方法，<code>null</code> 和 <code>undefined</code> 值没有。</p><ul><li>通常不需要参数。</li><li>调用数值的 <code>toString()</code> 方法时可以传递进制基数作为参数。</li></ul></li><li><p>不知道是不是 <code>null</code> 或 <code>undefined</code> 的时候可以使用转型函数 <code>String()</code></p><ul><li>如果值有 <code>toString()</code> 方法，调用</li><li>如果值是 <code>null</code>，返回 <code>&quot;null&quot;</code></li><li>如果值是 <code>undefined</code>，返回 <code>&quot;undefined&quot;</code></li></ul></li><li><p><code>obj + &quot;&quot;</code> 和字符串加在一起</p></li></ul><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><ul><li>对象是一组数据和功能的集合。<blockquote><p>在 ECMAScript 中，<code>Object</code> 类型所具有的任何属性和方法也同样存在于更具体的对象中。<br><code>Object</code> 的每个实例都具有下列属性和方法。</p></blockquote></li><li><code>Constructor</code> 构造函数</li><li><code>hasOwnProperty(propertyName)</code> 检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。参数（propertyName）为字符串</li><li><code>isProtorypeOf(object)</code> 检查传入的对象是否是另一个对象的原型</li><li><code>propertyIsEnumerable(propertyName)</code> 检查给定的属性是否能够使用 for-in 语句。参数（propertyName）为字符串</li><li><code>toLocaleString()</code> 根据本地规范进行格式化</li><li><code>toString()</code> </li><li><code>valueOf()</code> 通常自动调用</li></ul><blockquote><p>从技术角度讲，ECMA-262 中对象的行为不一定适用于 JS 中的其他对象。如 BOM 和 DOM 中的对象属于宿主对象，宿主对象可能会也可能不会继承 Object。</p></blockquote><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符应用于对象时，通常会调用对象的 <code>valueOf()</code> 和（或）<code>toString()</code> 方法。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>枚举对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性没有顺序，所以先后顺序因浏览器而异。</p><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>类似 go to 不建议使用</p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>简化多次编写同一个对象的工作<br>大量使用 with 会导致性能下降，不建议使用</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>比较值时使用全等 <code>===</code></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>未指定返回值的函数返回 <code>undefined</code></p><blockquote><p>函数要么始终返回一个值，要么永远都不要返回值。</p></blockquote><h3 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h3><ul><li>函数体内通过 arguments 对象来访问参数数组。</li><li>ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。<blockquote><p>详看第四章 —— 传递参数</p></blockquote></li></ul><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>不存在函数签名的特性，ECMAScript 函数不能重载<br>定义两个名字相同的函数，会被后面定义的函数覆盖</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 在 HTML 中使用 JavaScript</title>
      <link href="/2020/02/09/%E7%AC%AC2%E7%AB%A0-%E5%9C%A8%20HTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20JavaScript/"/>
      <url>/2020/02/09/%E7%AC%AC2%E7%AB%A0-%E5%9C%A8%20HTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20JavaScript/</url>
      
        <content type="html"><![CDATA[<h2 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a><code>script</code>元素</h2><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li><p>src 可选。包含要执行代码的外部文件。</p><blockquote><p>如果有 src，标签内嵌入的 JavaScript 代码会被忽略<br>可以包含来自外部域的 JavaScript 文件。这点与 <code>img</code> 相同</p></blockquote></li><li><p>async 可选。立即下载脚本，但不妨碍页面中其他操作。只对外部脚本文件有效。<strong>不能保证按顺序执行。不要修改 DOM 会在load 事件前执行，可能会在 <code>DOMContentLoaded</code> 事件触发之前或之后执行。</strong></p></li><li><p>defer 可选。延迟到文档完全被解析和显示之后（<code>/html</code>标签后）执行。<strong>只对外部脚本文件有效。</strong>（嵌入脚本的 defer 属性会被忽略）<strong>延迟脚本不一定会按照顺序执行，也不一定会在 <code>DOMContentLoaded</code> 事件触发前执行，因此最好只有一个延迟脚本。</strong></p><blockquote><p>只要不存在 defer 和 async 属性，浏览器都会按照 <code>scrip</code> 元素在页面中出现的先后顺序进行解析</p></blockquote></li></ul><ul><li>type 可选。language（已废弃）的替代属性；脚本语言的内容类型（MIME 类型）。默认值 text/javascript<blockquote><p>不推荐 text/javascript 和 text/ecmascript<br>服务器在传送 JavaScript 文件时使用的 MIME 类型通常是 application/x-javascript<br>非 IE 浏览器中可以使用 application/javascript 和 application/ecmascript</p></blockquote></li><li>charset 可选。表示通过 src 属性指定代码的字符集。大多数浏览器忽略</li></ul><h3 id="标签的位置"><a href="#标签的位置" class="headerlink" title="标签的位置"></a>标签的位置</h3><p>放在 <code>head</code> 中必须先把 js 代码下载、解析和执行完成后才能开始呈现页面内容，此时页面空白。<br>把 js 引用放在 <code>body</code> 中，空白时间会缩短。<br>或者设置 defer 属性，立即下载，延迟（<code>/html</code>标签后）执行。</p><h2 id="外部文件的优点"><a href="#外部文件的优点" class="headerlink" title="外部文件的优点"></a>外部文件的优点</h2><ul><li>可维护性：集中精力编辑 js 代码</li><li>可缓存：如果两个页面使用同一个文件，只需下载一次</li><li>适应未来</li></ul><h2 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h2><p><code>!DOCTYPE html</code></p><h2 id="noscript元素"><a href="#noscript元素" class="headerlink" title="noscript元素"></a><code>noscript</code>元素</h2><ul><li>浏览器不支持脚本</li><li>浏览器支持脚本，但脚本被禁用<br>符合上述条件，元素内容会被显示。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 JavaScript 简介</title>
      <link href="/2020/01/16/%E7%AC%AC1%E7%AB%A0-JavaScript%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/01/16/%E7%AC%AC1%E7%AB%A0-JavaScript%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>ECMA-262——定义一种名为 ECMAScript 的新脚本语言的标准<br>浏览器开发商将 ECMAScript 作为各自 JavaScript 实现的基础</p><blockquote><p>JavaScript 包括：</p><ul><li>核心： ECMAScript</li><li>文档对象模型： DOM</li><li>浏览器对象模型： BOM</li></ul></blockquote><h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><ul><li>没有输入和输出定义</li><li>ECMA-262 定义了 ECMAScript 基础，在此基础上可以构建更完善的脚本语言</li><li>宿主环境提供基本的 ECMAScript 实现，也提供该语言的拓展，以便语言和环境之间对接交互</li></ul><p>ECMA-262 标准规定了</p><ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>对象<br>ECMAScript 就是对实现该标准规定的各个方面内容的语言的描述<br>JavaScript 实现了 ECMAScript<br>Adobe ActionScript 也实现了 ECMAScript<h6 id="什么是-ECMAScript-兼容"><a href="#什么是-ECMAScript-兼容" class="headerlink" title="什么是 ECMAScript 兼容"></a>什么是 ECMAScript 兼容</h6><blockquote><p>要想成为 ECMAScript 的实现，必须做到：</p><ul><li>支持 ECMA-262 描述的所有“类型、值、对象、属性、函数以及程序语法和语义”</li><li>支持 Unicode 字符标准</li><li>可以进行拓展：<ul><li>添加 ECMA-262 没有描述的“更多类型、值、对象、属性和函数”。主要指新对象和对象的新属性</li><li>支持 ECMA-262 没有定义的“程序和正则表达式语法”。即可以修改和拓展内置的正则表达式语法</li></ul></li></ul><p>为开发人员基于 ECMAScript 开发一门新语言提供了广阔的空间和极大的灵活性</p></blockquote></li></ul><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM（Document Object Model）是针对 XML 但经过拓展用于 HTML 的 API（Application Programming Interface）</p><ul><li>W3C 制定了 DOM 标准</li><li>DOM 不止针对 JavaScript，很多别的语言也实现了 DOM</li><li>DOM 包括 DOM 核心和 DOM HTML<ul><li>DOM 核心规定如何映射基于 XML 的文档结构</li><li>DOM HTML 模块则在 DOM 核心 的基础上添加了针对 HTML 的对象和方法</li></ul></li></ul><p>除了 DOM 核心和 DOMHTML 接口之外，另外几种语言发布了只针对自己的 DOM 标准。以下语言都是基于 XML 的，每种语言的 DOM 标准都添加了与特定语言相关的新方法和新接口：</p><ul><li>SVG(Scalable Vector Graphic)</li><li>MathML（Mathematical Markup Language）</li><li>SMIL（Synchronized Multimedia Integration Language）<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3>开发人员使用 BOM（Browser Object Model）控制浏览器显示的页面以外的部分<br>BOM 作为 JavaScript 实现的一部分却没有相关的标准。H5 致力于把很多 BOM 功能写入正式规范。<br>根本上讲，BOM 只处理浏览器窗口和框架；但习惯上把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
