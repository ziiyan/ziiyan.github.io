<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第十四章 表单脚本 &amp; 第十五章 使用 Canvas 绘图 &amp; 第十六章 HTMl5 脚本编程</title>
      <link href="/2020/03/07/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%9B%BE-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-HTMl5%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/03/07/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%9B%BE-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-HTMl5%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第十四章-表单脚本"><a href="#第十四章-表单脚本" class="headerlink" title="第十四章 表单脚本"></a>第十四章 表单脚本</h1><h2 id="表单的基本知识"><a href="#表单的基本知识" class="headerlink" title="表单的基本知识"></a>表单的基本知识</h2><p>HTML 中，<code>&lt;form&gt;</code> 元素</p><p>Javascript 中，<code>HTMLFormElement</code>类型，继承 <code>HTMLElement</code></p><ul><li><code>acceptCharset</code> 服务器能够处理的字符集 <code>accept-charset</code></li><li><code>action</code> 接受请求的 URL <code>action</code></li><li><code>elements</code> 表单中所有控件集合 <code>HTMLCollection</code></li><li><code>enctype</code> 请求的编码类型 <code>enctype</code></li><li><code>length</code> 表单中控件的数量</li><li><code>method</code> 要发送的HTTP请求类型 get/post <code>method</code></li><li><code>name</code> 表单名称 <code>name</code></li><li><code>reset()</code> 将所有表单域重置为默认值</li><li><code>submit()</code> 提交表单</li><li><code>target</code> 用于发送和接受响应窗口的名称 <code>target</code></li></ul><h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><ul><li><p><code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 都可以定义提交按钮，<code>type = submit</code> 即可</p></li><li><p>提交表单时，浏览器将请求发送给服务器之前触发 submit 事件，这样就有机会验证表单数据。</p></li><li><p>提交表单最大的问题是重复提交表单</p><ul><li>第一次提交后禁用按钮</li><li>利用 onsubmit 事件处理程序 取消后续的表单提交操作</li></ul></li></ul><h3 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h3><ul><li><code>&lt;input&gt;</code> 或 <code>&lt;button&gt;</code> 中 <code>type = reset</code>，单击即可重置</li></ul><h3 id="表单字段"><a href="#表单字段" class="headerlink" title="表单字段"></a>表单字段</h3><p>每个表单都有 <code>elements</code> 属性，内容是所有表单元素的集合。集合是一个有序列表，包含表单中所有字段。</p><ul><li>共有的表单字段属性<ul><li><code>disabled</code></li><li><code>form</code></li><li><code>name</code></li><li><code>readOnly</code></li><li><code>tabIndex</code></li><li><code>type</code></li><li><code>value</code></li></ul></li><li>共有的表单字段方法<ul><li><code>focus()</code></li><li><code>blur()</code></li><li><code>autofocus</code> 页面加载时自动获得焦点</li></ul></li><li>共有的表单字段事件<ul><li><code>blur</code></li><li><code>change</code></li><li><code>focus</code><ul><li><code>blur</code> 和 <code>change</code> 先后顺序在各浏览器中不同</li></ul></li></ul></li></ul><h2 id="文本框脚本"><a href="#文本框脚本" class="headerlink" title="文本框脚本"></a>文本框脚本</h2><p><code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code></p><p>处理文本框时最好不要使用 DOM 方法（<code>setAttribute</code>）</p><h3 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h3><p><code>select()</code> 方法获得焦点时选择其所有文本</p><ul><li>选择事件</li><li>取得选择的文本<ul><li><code>selectionStart</code> 数值，开头位置</li><li><code>selectionEnd</code> 数值，结尾位置</li></ul></li><li>选择部分文本<ul><li><code>setSelectionRange()</code></li></ul></li></ul><h3 id="过滤输入"><a href="#过滤输入" class="headerlink" title="过滤输入"></a>过滤输入</h3><ul><li><p>屏蔽字符</p></li><li><p>操作剪贴板</p><ul><li><p>剪贴板事件</p><ul><li><code>beforecopy</code></li><li><code>copy</code></li><li><code>beforecut</code></li><li><code>cut</code></li><li><code>beforepaste</code></li><li><code>paste</code></li></ul></li><li><p>clipboardData 对象</p><ul><li><code>getData()</code></li><li><code>setData()</code></li><li><code>clearData()</code></li></ul></li></ul></li></ul><h3 id="自动切换焦点"><a href="#自动切换焦点" class="headerlink" title="自动切换焦点"></a>自动切换焦点</h3><p><code>tabForward()</code></p><h3 id="HTML5-约束验证-API"><a href="#HTML5-约束验证-API" class="headerlink" title="HTML5 约束验证 API"></a>HTML5 约束验证 API</h3><ul><li>必填字段 <code>required</code> 属性</li><li>其它输入类型<ul><li><code>email</code></li><li><code>url</code></li></ul></li><li>数值范围<ul><li><code>min</code></li><li><code>max</code></li></ul></li><li>输入模式 <code>pattern</code></li><li>检测有效性<ul><li><code>checkValidity()</code></li><li><code>validity</code></li></ul></li><li>禁用验证 <code>novalidate</code></li></ul><h2 id="选择框脚本"><a href="#选择框脚本" class="headerlink" title="选择框脚本"></a>选择框脚本</h2><p><code>&lt;select&gt;</code>、<code>&lt;option&gt;</code></p><ul><li><code>add(newOption, relOption)</code></li><li><code>multiple</code></li><li><code>options</code> 控件中所有 <code>&lt;option&gt;</code> 元素的 <code>HTMLCollection</code>，每个元素都是  <code>HTMLOptionElement</code> 对象<ul><li><code>index</code></li><li><code>label</code></li><li><code>selected</code></li><li><code>text</code></li><li><code>value</code></li></ul></li><li><code>remove(index)</code></li><li><code>selectedIndex</code></li><li><code>size</code></li></ul><h2 id="表单序列化"><a href="#表单序列化" class="headerlink" title="表单序列化"></a>表单序列化</h2><blockquote><p> 表单提交期间，浏览器怎样将数据发送给服务器？</p><ul><li><p>对表单字段的名称和值进行 URL 编码，使用 &amp; 分隔</p></li><li><p>不发送禁用的表单字段</p></li><li><p>只发送勾选的复选框和单选按钮</p></li><li><p>不发送 type 为 reset 和 button 的按钮</p></li><li><p>多选选择框中的每个选中的值单独一个条目</p></li><li><p>在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。</p></li><li><p>&lt;select&gt; 元素的值，就是选中的 &lt;option&gt; 元素的 value 特性的值</p></li></ul></blockquote><h2 id="富文本编辑"><a href="#富文本编辑" class="headerlink" title="富文本编辑"></a>富文本编辑</h2><p>WYSIWYG（What You See Is What You Get）</p><p>在页面中嵌入一个包含空 HTML 页面的 iframe</p><p>通过设置 designMode 属性，可以编辑，编辑的对象是该页面 body 元素的 HTML 代码</p><h1 id="第十五章-使用-Canvas-绘图"><a href="#第十五章-使用-Canvas-绘图" class="headerlink" title="第十五章 使用 Canvas 绘图"></a>第十五章 使用 Canvas 绘图</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ol><li>设置 width 和 height 属性，制定绘图区域<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"drawing"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"200"</span>&gt;</span>A drawing of something.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>取得绘图上下文<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//确定浏览器支持 &lt;canvas&gt; 元素</span></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>导出绘制的图像<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (drawing.getContext) &#123;</span><br><span class="line">    <span class="comment">//取得图像的数据 URI</span></span><br><span class="line">    <span class="keyword">var</span> imgURI = drawing.toDataURL(<span class="string">"imge/png"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示图像</span></span><br><span class="line">    <span class="keyword">var</span> image = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">    image.src = imgURI;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2D上下文"><a href="#2D上下文" class="headerlink" title="2D上下文"></a>2D上下文</h2><ul><li>坐标开始于左上角，原点坐标 (0, 0)</li><li>x 越大靠右，y 越大靠下</li><li>width 和 height 表示水平和垂直两个方向上可用的像素数</li></ul><h3 id="填充和描边"><a href="#填充和描边" class="headerlink" title="填充和描边"></a>填充和描边</h3><ul><li><code>fillStyle</code> 填充（字符串、渐变对象或模式对象）</li><li><code>strokeStyle</code> 描边（字符串、渐变对象或模式对象）</li><li><code>lineWidth</code> 线条宽度（整数）</li><li><code>lineCap</code> 线条末端形状（“butt”、“round”、“square”）</li><li><code>lineJoin</code> 线条相交形状（“round”、“bevel”、“miter”）</li></ul><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><ul><li><code>fillRect(x, y, w, h)</code></li><li><code>strokeRect(x, y, w, h)</code></li><li><code>clearRect(x, y, w, h)</code><ul><li>x: x 坐标</li><li>y: y 坐标</li><li>w: 矩形宽度</li><li>h: 矩形高度</li></ul></li></ul><h3 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h3><ol><li>调用<code>beginPath()</code>表示开始绘制新路径</li><li>绘制路径<ul><li><code>arc(x, y, radius, startAngle, endAngle, counterclockwise)</code> </li><li><code>arcTo(x1, y1, x2, y2, radius)</code> </li><li><code>bezierCurveTo(c1x, c1y, c2x, c2y, x, y)</code></li><li><code>lineTo(x, y)</code></li><li><code>moveTo(x, y)</code></li><li><code>quadraticCurveTo(cx, cy, x, y)</code></li><li><code>rect(x, y, width, height)</code></li></ul></li><li>绘制到画布<ul><li><code>closePath()</code></li><li><code>fill()</code></li><li><code>stroke()</code></li><li><code>clip()</code></li></ul></li></ol><ul><li><code>isPointInpath(x, y)</code> 点(x, y)是否在路径上</li></ul><h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><ul><li><code>fillText(string, x, y, (可选)font-size)</code></li><li><code>strokeText(string, x, y, (可选)font-size)</code></li></ul><hr><ul><li><code>font</code> 文本样式、大小、字体</li><li><code>textAlign</code> 文本对齐方式</li><li><code>textBaseline</code> 文本基线</li></ul><hr><ul><li><code>measureText()</code> 确定文本大小</li></ul><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><ul><li><code>rotate(angle)</code> 绕原点旋转图像</li><li><code>scale(scaleX, scaleY)</code> 缩放图像</li><li><code>translate(x, y)</code> 将坐标原点移动到 (x, y)</li><li><code>transform(m1_1, m1_2, m2_1, m2_2, dx, dy)</code> 修改变换矩阵</li><li><code>setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)</code> 将变换矩阵重置为默认状态再调用 transform()</li></ul><hr><ul><li><code>save()</code> 保存上下文状态</li><li><code>restore()</code> 读取保存的状态</li></ul><h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><ul><li><code>drawImage()</code><ul><li>要绘制的图像</li><li>源图像的 x 坐标</li><li>源图像的 y 坐标</li><li>源图像的宽度</li><li>源图像的高度</li><li>目标图像的 x 坐标</li><li>目标图像的 y 坐标</li><li>目标图像的宽度</li><li>目标图像的高度</li></ul></li></ul><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><ul><li><code>shadowColor</code></li><li><code>shadowOffsetXr</code></li><li><code>shadowOffsetY</code></li><li><code>shadowBlur</code></li></ul><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><ol><li><code>cg = createLinearGradient()</code> 创建新的渐变，返回 CanvasGradient 对象</li><li><code>cg.addColorStop()</code> 制定色标</li><li><code>fillStyle = cg</code>/<code>strokeStyle = cg</code> 绘制</li></ol><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li>重复的图像</li><li><code>createPattern()</code></li></ul><h3 id="使用图像数据"><a href="#使用图像数据" class="headerlink" title="使用图像数据"></a>使用图像数据</h3><ul><li><code>getImageData()</code></li></ul><h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><ul><li><code>globalAlpha</code> 透明度</li><li><code>globalCompositionOperation</code><ul><li>source-over(默认值):后绘制的图形位于先绘制的图形上方</li><li>……</li></ul></li></ul><h1 id="第十六章-HTML5-脚本编程"><a href="#第十六章-HTML5-脚本编程" class="headerlink" title="第十六章 HTML5 脚本编程"></a>第十六章 HTML5 脚本编程</h1><h2 id="跨文档消息传递-XDM"><a href="#跨文档消息传递-XDM" class="headerlink" title="跨文档消息传递 XDM"></a>跨文档消息传递 XDM</h2><p>来自不同域的页面间传递消息</p><ul><li><code>postMessage(消息，域)</code> 发送【消息】给【域】中的 <code>&lt;iframe&gt;</code> 元素</li><li>接收到 XDM 消息时，会触发 window 对象的 message 事件，异步，有延迟</li><li><code>onmessage</code><ul><li><code>data</code></li><li><code>origin</code></li><li><code>source</code></li></ul></li></ul><h2 id="原生拖放"><a href="#原生拖放" class="headerlink" title="原生拖放"></a>原生拖放</h2><h3 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h3><ol><li><code>dragstart</code> 按下鼠标触发</li><li><code>drag</code> 拖动期间持续触发</li><li><code>dragend</code> 拖动停止时触发，无论放置目标是否有效</li></ol><ul><li>当被拖动到一个有效的放置目标上</li></ul><ol><li><code>dragenter</code> 拖动到放置目标上</li><li><code>dragover</code> 放置目标范围内移动持续触发</li><li><code>dragleave</code> 拖出放置目标范围 或 <code>drop</code> 放到放置目标中</li></ol><h3 id="自定义放置目标"><a href="#自定义放置目标" class="headerlink" title="自定义放置目标"></a>自定义放置目标</h3><p>元素默认不允许放置，修改为可放置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> droptarget = <span class="built_in">document</span>.getElementById(<span class="string">"droptarget"</span>);</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragover"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(droptarget, <span class="string">"dragenter"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  EventUtil.preventDefault(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="dataTransfet-对象"><a href="#dataTransfet-对象" class="headerlink" title="dataTransfet 对象"></a>dataTransfet 对象</h3><p>用于从被拖动元素向放置目标传递字符串格式的数据</p><ul><li><code>getData()</code></li><li><code>setData()</code></li></ul><p>保存在 dataTransfer 对象中的数据只能在 drop 事件中被读取</p><ul><li><code>dropEffect</code> 被拖动元素能执行的放置行为<ul><li>none</li><li>move</li><li>copy</li><li>link</li></ul></li><li><code>effectAllowed</code> 允许拖动元素的哪种 dropEffect<ul><li>uninitialized</li><li>none</li><li>copy</li><li>link</li><li>move</li><li>copyLink</li><li>copyMove</li><li>linkMove</li><li>all</li></ul></li></ul><h3 id="可拖动"><a href="#可拖动" class="headerlink" title="可拖动"></a>可拖动</h3><p>默认情况下，图像、链接、文本可拖动</p><p>其它元素可以手动设置 draggable 属性为 ture</p><h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><p><code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code> 必须 src 指向要加载的媒体</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>表示媒体的当前状态</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>触发事件，监听属性变化，可能是播放结果，也可能是操作结果</p><h2 id="历史状态管理"><a href="#历史状态管理" class="headerlink" title="历史状态管理"></a>历史状态管理</h2><p>history 对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十三章 事件</title>
      <link href="/2020/03/05/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E4%BA%8B%E4%BB%B6/"/>
      <url>/2020/03/05/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="第十三章-事件"><a href="#第十三章-事件" class="headerlink" title="第十三章 事件"></a>第十三章 事件</h1><p>js 和 html 之间的交互是通过<strong>事件</strong>实现的，事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。<br>可以使用<strong>侦听器</strong>来预定事件，以便事件发生时执行相应的代码。<br>这种在传统软件工程中被称为<strong>观察员模式</strong>的模型，支持 js 和 html+css 之间的松散耦合。</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p><strong>事件流</strong>描述的是从页面中接收事件的顺序</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>按照 DOM 树逐级向上，在每一级节点上都会发生，直到 document</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>顺序与事件冒泡相反</p><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><p>“DOM2 级事件”规定的事件流包括三个阶段：</p><ul><li>事件捕获阶段<ul><li>Document 到 目标元素的上一级</li></ul></li><li>处于目标阶段<ul><li>事件在目标元素上发生，事件处理被看成冒泡的一部分</li></ul></li><li>事件冒泡阶段<ul><li>目标元素 到 Document<blockquote><p>DOM2 规定捕获阶段不设计目标，但浏览器实现时都会出发事件对象上的事件</p></blockquote></li></ul></li></ul><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><ul><li><strong>事件</strong>就是某种动作，如 click、load、mouseovre</li><li><strong>事件处理程序（事件侦听器）</strong>就是响应事件的函数，以 on 开头，onclick、onload 等</li></ul><h3 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span><span class="params">()</span> </span>&#123;……&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果用户在页面解析事件处理程序之前点击元素，会引发错误</li><li>扩展作用域链在不同浏览器中会导致不同结果</li><li>HTML 与 JavaScript 代码紧密耦合</li></ul><h3 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h3><p>将一个函数赋值给事件处理程序属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;……&#125;</span><br></pre></td></tr></table></figure><ul><li>代码运行之前不会指定事件处理程序，可能导致点击无效</li><li>事件处理程序是在元素的作用域中运行的，this 引用当前元素</li><li>null 即删除</li></ul><h3 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h3><ul><li><p><code>addEventListener(a, b, c)</code></p></li><li><p><code>removeEventListener(a, b, c)</code></p><ul><li>a 要处理的事件名</li><li>b 作为事件处理程序的函数</li><li>c 一个布尔值<ul><li>true 捕获阶段调用事件处理程序</li><li>false 冒泡阶段调用事件处理程序 ☑️<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>事件处理程序是在元素的作用域中运行的，this 引用当前元素</p></li><li><p>存在多个事件处理程序会按照添加顺序触发</p></li><li><p>addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除</p></li><li><p>addEventListener() 添加的匿名函数无法移除</p></li></ul><h3 id="IE-事件处理程序"><a href="#IE-事件处理程序" class="headerlink" title="IE 事件处理程序"></a>IE 事件处理程序</h3><ul><li><p><code>attachEvent(a, b)</code></p></li><li><p><code>detachEvent(a, b)</code></p><ul><li>a 事件处理程序名称</li><li>b 事件处理程序函数</li></ul></li><li><p>只支持冒泡</p></li><li><p>事件处理程序的作用域是全局</p></li><li><p>存在多个事件处理程序会按照添加顺序相反的顺序触发</p></li></ul><h3 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h3><p>关注冒泡阶段</p><ul><li><code>addHandler(a, b, c)</code></li><li><code>EventUtil(a, b, c)</code><ul><li>a 要操作的元素</li><li>b 事件名称</li><li>c 事件处理程序</li></ul></li></ul><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与时间有关的信息</p><h3 id="DOM-中的事件对象"><a href="#DOM-中的事件对象" class="headerlink" title="DOM 中的事件对象"></a>DOM 中的事件对象</h3><p>兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中</p><ul><li><code>event.preventDefault()</code> 阻止特定事件的默认行为，如链接到默认行为是导航到 href</li><li><code>event.stopPropagation()</code> 停止事件在 DOM 层次中的传播（捕获或冒泡）</li><li><code>event.eventPhase</code> 确定事件当前正位于事件流的哪个阶段<ul><li>捕获 1</li><li>处于目标 2</li><li>冒泡 3</li></ul></li><li>事件处理器执行期间 event 对象才会存在，执行完就销毁</li></ul><h3 id="IE-中的事件对象"><a href="#IE-中的事件对象" class="headerlink" title="IE 中的事件对象"></a>IE 中的事件对象</h3><h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><p>不一定与用户操作有关</p><ul><li><code>load</code> 当页面完全加载后在 window 上触发，当图像加载完毕时在<img>元素上面触发</li><li><code>unload</code> 当页面完全卸载后在 window 上触发（页面切换时）</li><li><code>resize</code> 浏览器窗口调整大小时 window 上触发，通过 js 或 body 元素中 onresize 指定事件处理程序</li><li><code>scroll</code> window 对象上发生，表示页面中相应元素的变化</li></ul><h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><p>获得或失去焦点时触发</p><ul><li><code>document.hasFocus()</code></li><li><code>document.activeElement</code></li></ul><hr><ul><li><code>blur</code> 元素失去焦点时触发，不冒泡</li><li><code>focus</code> 获得焦点时触发，不冒泡</li><li><code>focusin</code> 获得焦点时，冒泡</li><li><code>focusout</code> 失去焦点时，冒泡</li></ul><h3 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h3><ul><li><code>click</code> 单击或回车</li><li><code>dblclick</code> 双击</li><li><code>mousedown</code> 按下任意鼠标按钮</li><li><code>mouseup</code> 释放鼠标按钮</li><li><code>mouseenter</code> 光标从外部首次移动到元素范围之内，不冒泡，移动到后代元素上不会触发</li><li><code>mouseleave</code> 元素上的光标移动到元素范围之外，不冒泡，移动到后代元素不触发</li><li><code>mousemove</code> 光标在元素内部移动时重复触发</li><li><code>mouseout</code> 鼠标位于一个元素上方，移入另一个元素时触发。另一个元素可能是原来元素的外部或子元素</li><li><code>mouseover</code> 光标位于一个元素外部，首次移入另一个元素边界之内</li></ul><hr><ul><li>客户区坐标位置<ul><li><code>event.clientX</code></li><li><code>event.clientY</code></li></ul></li><li>页面坐标位置<ul><li><code>event.pageX</code></li><li><code>event.pageY</code></li></ul></li><li>屏幕坐标位置<ul><li><code>event.screenX</code></li><li><code>event.screenY</code></li></ul></li><li>修改键<ul><li>click + 键盘 -&gt; 属性（Boolean）<ul><li>Shift <code>shiftKey</code></li><li>Ctrl <code>ctrlKey</code></li><li>Alt <code>altKey</code></li><li>Meta(Windows/Cmd) <code>metaKey</code></li></ul></li></ul></li><li>相关元素<ul><li>针对 <code>moseover</code>、<code>mouseout</code><ul><li><code>relatedTarget</code> 属性</li></ul></li></ul></li><li>鼠标按钮<ul><li>针对 <code>mousedown</code>、<code>mouseup</code><ul><li><code>button</code> 属性<ul><li>0 主鼠标</li><li>1 滚轮</li><li>2 次鼠标</li></ul></li></ul></li></ul></li><li>鼠标滚轮事件<ul><li><code>mousewheel</code><ul><li>冒泡</li><li><code>wheelDelta</code> 属性</li></ul></li></ul></li></ul><h3 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h3><ul><li><code>keydown</code> 任意键</li><li><code>keypress</code> 字符键</li><li><code>keyup</code> 释放案件</li></ul><hr><ul><li><code>event.keyCode</code> 键码，ASCII 小写字母相同</li><li><code>event.charCode</code> 字符编码，针对 keypress</li></ul><h3 id="变动事件"><a href="#变动事件" class="headerlink" title="变动事件"></a>变动事件</h3><ul><li>删除节点</li><li>插入节点</li></ul><h3 id="HTML5-事件"><a href="#HTML5-事件" class="headerlink" title="HTML5 事件"></a>HTML5 事件</h3><ul><li><code>contextmenu</code> 冒泡</li><li><code>beforeunload</code></li><li><code>DOMContentLoaded</code></li><li><code>readystatechange</code><ul><li>uninitialized</li><li>loading</li><li>loaded</li><li>interactive</li><li>complete</li></ul></li><li><code>pageshow</code> <code>pagehide</code></li><li><code>hashchange</code></li></ul><h3 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h3><p>智能手机和平板电脑</p><h3 id="触摸与手势"><a href="#触摸与手势" class="headerlink" title="触摸与手势"></a>触摸与手势</h3><h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><p>添加到页面上 的事件处理程序数量将直接关系到页面的整体运行性能</p><ul><li>函数对象占用内存</li><li>指定事件处理程序导致的 DOM 访问</li></ul><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>利用事件冒泡，只指定一个事件处理程序</p><h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><p>将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的 JavaScript 代码之间就 会建立一个连接。连接越多，页面执行起来就越慢。</p><h2 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h2><p>js 触发事件</p><h3 id="DOM-中的事件模拟"><a href="#DOM-中的事件模拟" class="headerlink" title="DOM 中的事件模拟"></a>DOM 中的事件模拟</h3><ul><li><p><code>document.createEvent()</code></p><ul><li>UIEvents</li><li>MouseEvents</li><li>MutationsEvents</li><li>HTMLEvents</li></ul></li><li><p>模拟鼠标</p></li><li><p>模拟键盘</p></li><li><p>模拟其他</p></li></ul><h3 id="IE-中"><a href="#IE-中" class="headerlink" title="IE 中"></a>IE 中</h3>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十章 DOM &amp; 第十一章 DOM 扩展 &amp; 第十二章 DOM2 和 DOM3</title>
      <link href="/2020/03/04/%E7%AC%AC%E5%8D%81%E7%AB%A0-DOM-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-DOM%E6%89%A9%E5%B1%95-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-DOM2%E5%92%8CDOM3/"/>
      <url>/2020/03/04/%E7%AC%AC%E5%8D%81%E7%AB%A0-DOM-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-DOM%E6%89%A9%E5%B1%95-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-DOM2%E5%92%8CDOM3/</url>
      
        <content type="html"><![CDATA[<h1 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a>第十章 DOM</h1><ul><li>针对 HTML 和 XML 文档的一个 API</li></ul><h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><ul><li><strong>文档元素</strong>是最外层元素，每个文档只有一个文档元素，HTML 中是 <code>html</code></li></ul><h3 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h3><ul><li>js 所有节点类型都继承自 Node 类型</li><li><code>nodeType</code> 值为 node 的类型常量（12种）<ul><li>元素节点 Node.ELEMENT_NODE(1)</li><li>文本节点 Node.TEXT_NODE(3)</li></ul></li></ul><h5 id="nodeName-和-nodeValue-属性"><a href="#nodeName-和-nodeValue-属性" class="headerlink" title="nodeName 和 nodeValue 属性"></a>nodeName 和 nodeValue 属性</h5><ul><li><code>nodeName</code> 元素标签名</li><li><code>nodeValue</code> 元素的值</li></ul><h5 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h5><p><img src="/.com//%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB.png" alt="节点关系.png"></p><ul><li><code>hashChildNodes()</code> </li><li><code>ownerDocument</code> 指向文档节点（最外层节点）</li></ul><h5 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h5><ul><li><code>appendChild(newNode)</code> childNodes 列表末尾添加一个节点<ul><li>如果 newNode 已经存在 DOM 树中，会移动位置，而不是新建</li></ul></li><li><code>insertBefore(NewNode, Node)</code> 将 NewNode 插入到 Node 前面的位置</li><li><code>replaceChild(NewNode, Node)</code></li><li><code>removeChild(Node)</code><br>以上方法通过父节点调用</li></ul><hr><p>以下方法所有节点都有</p><ul><li><code>cloneNode(Boolean)</code><ul><li>true 深复制，整个子节点树</li><li>false 浅复制，节点本身</li><li>返回的节点属于文档，但没有父节点</li></ul></li><li><code>normalize()</code> 处理文档节点</li></ul><h3 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h3><p>浏览器中 document 对象是 <code>HTMLDocument</code>（继承自 Document 类型）的一个实例，是 window 对象的一个属性</p><ul><li>nodeType = 9</li><li>nodeName = “#document”</li><li>nodeValue = null</li><li>parentNode = null</li><li>ownerDocument = null</li><li>子节点可能是一个 DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction 或 Comment</li></ul><h5 id="文档的子节点"><a href="#文档的子节点" class="headerlink" title="文档的子节点"></a>文档的子节点</h5><ul><li><code>document.documentElement</code> 始终指向 HTML 页面中的 <code>html</code> 元素</li><li><code>document.body</code> 指向 <code>body</code> 元素</li><li><code>document.doctype</code> </li></ul><h5 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h5><p>浏览器专供属性，存在 HTTP 头部</p><ul><li><code>document.title</code></li><li><code>document.URL</code></li><li><code>document.domain</code></li><li><code>document.referrer</code></li></ul><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><ul><li><code>document.getElementById()</code> 多个元素相同 id 则返回第一个</li><li><code>document.getElementsByTagName()</code> 返回 NodeList，HTML 文档中返回 <code>HTMLCollection</code> 对象</li><li><code>document.getElementsByName()</code> 返回 <code>HTMLCollection</code> 对象</li></ul><h5 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h5><ul><li><code>document.anchors</code></li><li><code>document.forms</code></li><li><code>document.images</code></li><li><code>document.links</code> 带 href 特性的 a 元素</li></ul><h5 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h5><ul><li><code>document.write()</code></li><li><code>document.writeln()</code></li><li><code>document.open()</code> 打开网页输出流</li><li><code>document.close()</code> 关闭网页输出流</li></ul><h3 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h3><ul><li>nodeType = 1</li><li>nodeName = 元素的标签名</li><li>nodeValue = null</li><li>parentNode 可能是 Document 或 Element</li><li>子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference</li></ul><p><code>nodeName</code> 和 <code>tagName</code> 属性都是标签名</p><h5 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h5><p>HTMLElement 继承 Element 并添加了一些属性</p><ul><li><code>id</code></li><li><code>title</code></li><li><code>lang</code></li><li><code>dir</code></li><li><code>className</code></li></ul><h5 id="操作特性"><a href="#操作特性" class="headerlink" title="操作特性"></a>操作特性</h5><ul><li><code>getAttribute(‘class’)</code></li><li><code>setAttribute(‘class’, &#39;ft&#39;)</code></li><li><code>removeAttribute(&#39;class&#39;)</code></li></ul><h5 id="attributes-属性"><a href="#attributes-属性" class="headerlink" title="attributes 属性"></a>attributes 属性</h5><p><code>attributes</code> 属性中包含一个 <code>NamedNodeMap</code> 对象，元素每个特性都由一个 Attr 节点表示，节点保存在 <code>NamedNodeMap</code> 对象中<br>对象方法</p><ul><li><code>getNamedItem(name)</code></li><li><code>removeNamedItem(name)</code></li><li><code>setNamedItem(node)</code></li><li><code>item(pos)</code></li></ul><p>节点属性</p><ul><li><code>nodeName</code></li><li><code>nodeValue</code></li></ul><h5 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h5><ul><li><code>document.createElement(标签名)</code><br>创建完成后需要调用前面介绍的方法将其添加到文档树中</li></ul><h3 id="Text-类型（开始和结束标签中的文本）"><a href="#Text-类型（开始和结束标签中的文本）" class="headerlink" title="Text 类型（开始和结束标签中的文本）"></a>Text 类型（开始和结束标签中的文本）</h3><ul><li>nodeType = 3</li><li>nodeName = #text</li><li>nodeValue 节点所包含的文本</li><li>parentNode 是 Element</li><li>没有子节点</li></ul><hr><ul><li><code>document.createTextNode()</code> 创建文本节点</li><li><code>normalize()</code> 相邻的文本节点之间不存在空格，可以将所有相邻的文本节点拼接起来</li><li><code>splitText()</code> 分割文本节点</li></ul><h3 id="Comment-类型"><a href="#Comment-类型" class="headerlink" title="Comment 类型"></a>Comment 类型</h3><ul><li>nodeType = 8</li><li>nodeName = #comment</li><li>nodeValue = 注释的内容</li><li>parentNode 可能是 Document 或 Element</li><li>没有子节点</li></ul><h3 id="CDATASection-类型"><a href="#CDATASection-类型" class="headerlink" title="CDATASection 类型"></a>CDATASection 类型</h3><ul><li>针对 XML 文档，表示 CDATA 区域</li><li>浏览器会解析为 Comment 或 Element</li></ul><h3 id="DocumentType-类型"><a href="#DocumentType-类型" class="headerlink" title="DocumentType 类型"></a>DocumentType 类型</h3><p>包含 doctype 有关的信息</p><h3 id="DocumentFragment-类型"><a href="#DocumentFragment-类型" class="headerlink" title="DocumentFragment 类型"></a>DocumentFragment 类型</h3><h3 id="Attr-类型"><a href="#Attr-类型" class="headerlink" title="Attr 类型"></a>Attr 类型</h3><p>元素的特性，不是 DOM 文档树的一部分</p><h2 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h2><h3 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h3><p>DOM 操作 script 标签</p><h3 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h3><p>DOM 操作 link 标签 和 style 标签</p><h3 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h3><p>DOM 操作 table 标签</p><h3 id="使用-NodeList"><a href="#使用-NodeList" class="headerlink" title="使用 NodeList"></a>使用 NodeList</h3><ul><li><code>NodeList</code></li><li><code>NamedNodeMap</code></li><li><code>HTMLCollection</code><br>每当文档结构发生变化，它们都会更新，保存最新的信息</li></ul><blockquote><p>理解 DOM 的关键，就是理解 DOM 对性能的影响。DOM 操作往往是 JavaScript 程序中开销最大的 部分，而因访问 NodeList 导致的问题为最多。NodeList 对象都是“动态的”，这就意味着每次访问 NodeList 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作。</p></blockquote><h1 id="第十一章-DOM-扩展"><a href="#第十一章-DOM-扩展" class="headerlink" title="第十一章 DOM 扩展"></a>第十一章 DOM 扩展</h1><h2 id="选择符-API"><a href="#选择符-API" class="headerlink" title="选择符 API"></a>选择符 API</h2><ul><li>参数为 CSS 选择符<ul><li><code>querySelector()</code> 返回元素</li><li><code>querySelectorAll()</code> 返回 NodeList 快照</li></ul></li></ul><h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><ul><li><code>childElementCount</code> 不包括文本节点和注释</li><li><code>firstElementChild</code></li><li><code>lastElementChild</code></li><li><code>previousElementSibling</code></li><li><code>nextElementSibling</code></li></ul><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="与类相关的扩充"><a href="#与类相关的扩充" class="headerlink" title="与类相关的扩充"></a>与类相关的扩充</h3><ul><li><code>getElementsByClassName()</code></li><li><code>classList</code> DOMTokenList 的实例</li></ul><h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><ul><li><code>activeElement</code> 当前获得焦点的元素</li><li><code>hasFocus()</code> 文档是否获得焦点（用户是否正在与页面交互）</li></ul><h3 id="HTMLDocument-的变化"><a href="#HTMLDocument-的变化" class="headerlink" title="HTMLDocument 的变化"></a>HTMLDocument 的变化</h3><ul><li><code>readyState</code> 属性<ul><li>loading</li><li>complete</li></ul></li><li><code>compatMode</code> 兼容模式<ul><li>CSS1Compat 标准模式</li><li>BackCompat 混杂模式</li></ul></li><li><code>head</code> 引用 head 标签元素</li></ul><h3 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h3><ul><li><code>charset</code> 默认 ”UTF-16“</li><li><code>defaultCharset</code> 根据默认浏览器及操作系统设置</li></ul><h3 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h3><ul><li>添加前缀 data-</li><li><code>dataset</code> 属性访问自定义属性的值<ul><li>值是 DOMStringMap 的一个实例</li><li>也就是一个名值对的映射</li></ul></li></ul><h3 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h3><ul><li><code>innerHTML</code> 属性</li><li><code>outerHTML</code> 属性</li><li><code>insertAdjacentHTML()</code> 方法<ul><li>params1 插入位置<ul><li>beforebegin</li><li>afterbegin</li><li>beforeend</li><li>afterend</li></ul></li><li>params2 HTML 文本</li></ul></li><li>内存与性能问题</li></ul><h3 id="scrollIntoView-方法"><a href="#scrollIntoView-方法" class="headerlink" title="scrollIntoView() 方法"></a>scrollIntoView() 方法</h3><p>让当前的元素滚动到浏览器窗口的可视区域内</p><h1 id="第十二章-DOM2-和-DOM3"><a href="#第十二章-DOM2-和-DOM3" class="headerlink" title="第十二章 DOM2 和 DOM3"></a>第十二章 DOM2 和 DOM3</h1><p>DOM1 主要定义的是 HTML 和 XML 文档的底层结构，DOM2 和 DOM3 分为许多模块，分表描述 DOM 的某个非常具体的子集，目的在于扩展 DOM API</p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>定义样式</p><ul><li><code>&lt;link/&gt;</code> 外部样式表</li><li><code>&lt;style/&gt;</code> 嵌入式样式</li><li><code>style 特性</code> 针对特定元素的样式</li></ul><h3 id="访问元素的样式"><a href="#访问元素的样式" class="headerlink" title="访问元素的样式"></a>访问元素的样式</h3><ul><li>元素的 style 特性是 <code>CSSStyleDeclaration</code> 的实例</li><li>CSS 属性的短线转为驼峰才能通过 js 访问</li><li>float 是保留字所以 转为 cssFloat</li></ul><h3 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h3><p>CSSStyleSheet 类型表示的是样式表，继承自 StyleSheet，后者可以作为一个基础接口来定义非 CSS 样式表</p><h3 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h3><ul><li><p>偏移量<br><img src="/.com//%E5%81%8F%E7%A7%BB%E9%87%8F.png" alt="偏移量.png"></p></li><li><p>客户区大小<br><img src="/.com//%E5%AE%A2%E6%88%B7%E5%8C%BA%E5%A4%A7%E5%B0%8F.png" alt="客户区大小.png"></p></li></ul><p>所有偏移量、客户区大小都是只读的，每次访问要重新计算。避免重复访问，有需要可以保存下来。</p><ul><li><p>滚动大小<br><img src="/.com//%E6%BB%9A%E5%8A%A8%E5%A4%A7%E5%B0%8F.png" alt="滚动大小.png"></p></li><li><p>确定元素大小<br><code>getBoundingClientRect()</code> 返回 DOMRect 对象，包含四个值<br><img src="/.com//%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F.png" alt="确定元素大小.png"></p></li></ul><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul><li>NodeIterator</li><li>TreeWalker</li></ul><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><ul><li>范围是选择 DOM 结构中特定部分，然后再执行相应操作的一种手段。</li><li>使用范围选区可以在删除文档中某些部分的同时，保持文档结构的格式良好，或者复制文档中的相应部分。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八章 BOM &amp; 第九章 客户端检测</title>
      <link href="/2020/03/02/%E7%AC%AC%E5%85%AB%E7%AB%A0-BOM-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/"/>
      <url>/2020/03/02/%E7%AC%AC%E5%85%AB%E7%AB%A0-BOM-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章-BOM"><a href="#第八章-BOM" class="headerlink" title="第八章 BOM"></a>第八章 BOM</h1><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><ul><li>BOM 的核心对象是 window，表示浏览器的一个实例<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3></li><li>Window 作为 Global 对象，所有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法</li><li>全局变量不能通过 delete 删除，直接在 window 对上定义的属性可以</li></ul><h3 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h3><ul><li><code>window.screenLeft</code></li><li><code>window.screenTop</code></li><li><code>window.screenX</code></li><li><code>window.screenY</code></li><li><code>window.moveTo(x, y)</code></li><li><code>window.moveBy(a, b)</code></li></ul><h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><ul><li><code>window.innerWidth</code></li><li><code>window.innerHeight</code></li><li><code>window.outerWidth</code></li><li><code>window.outerHeight</code></li><li><code>window.resizeTo(w, h)</code></li><li><code>window.resizeBy(w, h)</code></li></ul><h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><ul><li><code>window.open(URL, target, String, Boolean)</code></li></ul><h3 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h3><ul><li><code>setTimeout(function, ms)</code><ul><li>ms 后把当前任务添加到任务队列，如果此时任务队列是空的才会立即执行<ul><li>所以不一定 ms 后就会执行 function</li></ul></li><li>返回一个数值 ID</li></ul></li><li><code>clearTimeout(timeoutID)</code></li><li><code>setInterVal(function, ms)</code></li><li><code>clearInterval(timeoutID)</code></li></ul><h3 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h3><p>样式由操作系统或浏览器决定<br>显示这些对话框的时候代码会停止执行</p><ul><li><code>alert()</code></li><li><code>confirm()</code></li><li><code>prompt()</code></li><li><code>find()</code></li><li><code>print()</code></li></ul><h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><ul><li>既是 window 对象的属性，也是 document 对象的属性</li><li>window.LOcation 和 document.location 引用的是同一个对象</li></ul><h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><ul><li><p><code>location.assign(url)</code></p></li><li><p><code>window.location = &quot;url&quot;</code></p></li><li><p><code>location.href = &quot;url&quot;</code><br>修改 location 其它属性页面都会重新加载，浏览器的历史记录会生产一条新记录</p></li><li><p><code>replace(url)</code> 不会产生新记录</p></li><li><p><code>reload()</code> </p><ul><li>无参数，可能是用缓存</li><li>参数 true，强制从服务器重新加载</li><li>调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。最好将 reload()放在代码的最后一行</li></ul></li></ul><h2 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h2><h2 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h2><ul><li><code>history.go()</code><ul><li>number 前进或后退页面</li><li>string 跳转到历史记录中包含string最近的位置</li></ul></li><li><code>history.back()</code> 后退</li><li><code>history.forward()</code> 前进</li><li><code>history.length</code> 历史记录数量</li></ul><h1 id="第九章-客户端检测"><a href="#第九章-客户端检测" class="headerlink" title="第九章 客户端检测"></a>第九章 客户端检测</h1><p>先设计最通用的方案，再使用客户端检测</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 函数表达式</title>
      <link href="/2020/03/01/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/03/01/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>定义函数的方式</p><ol><li>函数声明<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionName(); <span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数声明提升</span></span><br><span class="line"><span class="comment">// 执行代码前会读取函数声明，意味着可以把函数声明放在调用后面</span></span><br></pre></td></tr></table></figure></li><li>函数表达式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionName(); <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有函数声明提升</span></span><br><span class="line"><span class="comment">// 使用前必须先赋值</span></span><br></pre></td></tr></table></figure><blockquote><p>function 关键字后面没有标识符，所以叫<strong>匿名函数</strong>，也叫<strong>拉姆达函数</strong>。</p></blockquote></li></ol><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        reutrn <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line">alert(anotherFactorial(<span class="number">4</span>)); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为调用 anotherFactorial(num) 时，函数内部会执行 factorial(num-1)，而此时 factorial 已经被置为 null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为 arguments.callee 即可，如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>闭包</strong>是指(有权访问[另一个函数作用域中的变量]的)函数。<br>创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">        <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">        <span class="comment">// 这个匿名函数的作用域链中包含 createComparisonFunction() 的作用域，所以这两行代码可以访问外部函数中的变量 propertyName</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当函数执行完毕后，局部活动对象会被销毁，内存仅保留全局作用域。但是闭包有所不同。<br>在另一个函数内部定义的函数会将包含它的函数（即外部函数）的活动对象添加到它的作用域链中。<br>因此，createComparisonFunction() 函数内部定义的匿名函数的作用域链中，实际上会包含外部函数 createComparisonFunction() 的活动对象。<br><img src="/.com//%E9%97%AD%E5%8C%85.png" alt="闭包.png"><br>在匿名函数从 createComparisonFunction() 中被返回后，它的作用域链被初始化为 包含 createComparisonFunction() 函数的活动对象和全局变量对象。<br>这样，匿名函数就可以访问在 createComparisonFunction() 中定义的所有变量。<br>同时，createComparisonFunction() 的活动对象由于被匿名函数的作用域链引用，在函数执行完毕之后不会被销毁。</p></blockquote><p>由于闭包会携带外部函数的作用域，因此会比其他函数占更多的内存。所以要慎重使用闭包。</p><h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><ul><li>闭包只能取得包含函数中每个变量的最新值</li><li>因为每个函数作用域链中都保存着外部函数的活动对象，是共享的，最后更新的内容会被引用。</li></ul><h3 id="关于-this-对象"><a href="#关于-this-对象" class="headerlink" title="关于 this 对象"></a>关于 this 对象</h3><ul><li>匿名函数的执行环境具有全局性，this 通常指向 window。用 call 或 apply 改变制定环境时会指向其他对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">" "</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(object.getNameFunc()());  <span class="comment">// "The Window My Object"</span></span><br><span class="line">alert(object.getName());  <span class="comment">// "My Object"</span></span><br></pre></td></tr></table></figure><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3></li><li>闭包会引用包含函数的整个活动对象，可以活动对象中的变量赋值 null 解除引用，保证内存正常回收。</li></ul><h2 id="模仿块级作用域（）私有作用域"><a href="#模仿块级作用域（）私有作用域" class="headerlink" title="模仿块级作用域（）私有作用域"></a>模仿块级作用域（）私有作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 定义并立即调用了一个匿名函数</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 理解过程</span></span><br><span class="line"><span class="comment">// 定义一个函数并立即调用</span></span><br><span class="line"><span class="keyword">var</span> someFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;;</span><br><span class="line">someFunction();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用函数的值直接取代函数名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;(); <span class="comment">// 报错，函数声明后不能跟圆括号</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;)(); <span class="comment">// 正确，函数表达式可以跟圆括号</span></span><br></pre></td></tr></table></figure><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><ul><li><p>严格来说，js 中没有私有成员的概念，所有的对象属性都是公有的</p><blockquote><p>个人理解：oop 语言中私有成员不能被子类继承，而 js 中所有对象属性都能被继承，因此都是公有的</p></blockquote></li><li><p>但有私有变量的概念，任何在函数中定义的变量都可以认为是私有变量，因为不能在函数的外部访问这些变量</p></li><li><p>私有变量包括</p><ul><li>函数的参数</li><li>局部变量</li><li>在函数内部定义的其他函数</li></ul></li></ul><h6 id="特权方法：有权访问私有变量和私有函数的公有方法"><a href="#特权方法：有权访问私有变量和私有函数的公有方法" class="headerlink" title="特权方法：有权访问私有变量和私有函数的公有方法"></a>特权方法：有权访问私有变量和私有函数的公有方法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在构造函数中定义特权方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fasle;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数（没有var，全局变量）</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公有/特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><ul><li>模块模式：为单例创建私有变量和特权方法<ul><li>单例：只有一个实例的对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = &#123;</span><br><span class="line">    name: value,</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回单例的公共接口</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicProperty: <span class="literal">true</span>,</span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">     <span class="comment">//私有变量和私有函数</span></span><br><span class="line">     <span class="keyword">var</span> privateVariable = <span class="number">10</span>; </span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//创建对象</span></span><br><span class="line">     <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">     <span class="comment">//添加特权/公有属性和方法</span></span><br><span class="line">     object.publicProperty = <span class="literal">true</span>; </span><br><span class="line">     object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">         privateVariable++; </span><br><span class="line">         <span class="keyword">return</span> privateFunction(); </span><br><span class="line">         &#125;; </span><br><span class="line">     <span class="comment">//返回这个对象</span></span><br><span class="line">     <span class="keyword">return</span> object; </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 面向对象程序设计</title>
      <link href="/2020/02/28/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2020/02/28/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li>面向对象语言的标志是都有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。</li><li>而 ECMAScript 中没有类的概念，因此它的对象和基于类的语言中的对象有所不同。</li><li>ECMAscript 对象定义：<u>无序属性的集合，其属性可以包含基本值、对象或函数。</u></li><li>每个对象都是基于一个引用类型创建的。可以是原生类型，也可以是开发人员定义的类型。</li></ul><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><h5 id="属性数据"><a href="#属性数据" class="headerlink" title="属性数据"></a>属性数据</h5><ul><li><code>[[Configurable]]</code>:表示能否通过 delete 删除属性从而定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li><li><code>[[Enumerable]]</code>:表示能否通过 for-in 循环返回属性。</li><li><code>[[Writable]]</code>:表示能否修改属性的值。</li><li><code>[[Value]]</code>:包含设个属性的数据值。<blockquote><p><code>Object.defineProperty(属性所在对象，属性的名字，描述符对象)</code>：修改属性默认的特性</p></blockquote></li></ul><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><ul><li><code>[[Configurable]]</code>:表示能否通过 delete 删除属性从而定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li><li><code>[[Enumerable]]</code>:表示能否通过 for-in 循环返回属性。</li><li><code>[[Get]]</code>:在读取属性时调用的函数，默认值 <code>undefined</code>。</li><li><code>[[Set]]</code>:在写入属性时调用的函数，默认值 <code>undefined</code>。<blockquote><p>访问器属性不能直接定义，必须使用<code>Object.defineProperty()</code>来定义。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">     _year: <span class="number">2004</span>,</span><br><span class="line">     edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123; </span><br><span class="line">     <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="keyword">set</span>: function(newValue) &#123; </span><br><span class="line">     <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123; </span><br><span class="line">         <span class="keyword">this</span>._year = newValue; </span><br><span class="line">         <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>; </span><br><span class="line">alert(book.edition); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><ul><li><code>Object.defineProperties(对象，要添加和修改属性)</code> 通过描述赋一次定义多个属性<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3></li><li><code>Object.getOwnPropertyDescriptor(属性所在的对象，要读取其描述符的属性名称)</code>返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。</li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul><li>抽象了创建具体对象的过程<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3></li><li>定义在 Global 对象（浏览器即 window 对象）中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（this 就指向了这个新对象）</li><li>执行构造函数中的代码</li><li>返回新对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor == Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h5><ul><li>构造函数与其他函数唯一的区别是调用方式不同<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">person.sayName();</span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"><span class="built_in">window</span>.sayName();</span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">o.sayName();</span><br></pre></td></tr></table></figure></li></ul><h5 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h5><ul><li><p>每个方法都要在每个实例上重新创建一遍</p></li><li><p>不同实例上的同名函数是不相等的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> <span class="keyword">this</span>.age = age; </span><br><span class="line"> <span class="keyword">this</span>.job = job; </span><br><span class="line"> <span class="keyword">this</span>.sayName = sayName; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> alert(<span class="keyword">this</span>.name); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果需要很多方法，就需要定义很多全局函数</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3></li><li><p>每个函数都有 prototype（原型）属性</p><ul><li>是一个指针，指向一个对象<ul><li>对象包含所有实例共享的属性和方法</li><li>换句话说，prototype 就是通过调用构造函数而创建的对象实例的原型对象</li></ul></li></ul></li><li><p>好处</p><ul><li>让所有对象实例共享它所包含的属性和方法</li><li>不必在构造函数中定义对象实例的信息，而且将这些信息直接添加到原型对象中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Grey"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Doctor"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h5></li></ul></li><li><p>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象</p></li><li><p>默认情况下，所有原型对象会自动获得一个 constructor(构造函数) 属性，这个属性包含一个指向 prototype 属性所在函数（也就是构造函数）的指针</p></li><li><p><code>Person.prototype.constructor</code> 指向 <code>Person</code><br><img src="/.com//%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p></li><li><p>每个实例有一个<code>[[Prototype]]</code>（<code>__proto__</code>）属性，指向构造函数的原型对象</p></li><li><p><code>isPrototypeOf()</code>确定原型关系</p><ul><li><code>Person.prototype.isPrototypeOf(person)</code></li></ul></li><li><p><code>Object.getPrototypeOf()</code> 返回[[Prototype]] 的指针</p><ul><li><code>Object.getPrototypeOf(person) == Person.prototype</code></li></ul></li><li><p>在实例中修改属性值，会屏蔽原型中的同名属性</p><ul><li><code>delete person.name</code> 删除实例中的 name 属性，<code>console.log(person.name)</code> 将输出原型中的 name 属性 <code>Person.prototype.name</code></li></ul></li><li><p><code>hasOwnProperty()</code> 检测一个属性是否在实例中，false 来自原型</p></li></ul><h5 id="原型与-in-操作符"><a href="#原型与-in-操作符" class="headerlink" title="原型与 in 操作符"></a>原型与 in 操作符</h5><ul><li>单独使用<ul><li>属性 in 实例</li><li>无论属性在实例还是在原型，都返回 true</li></ul></li><li>for-in<ul><li>返回可枚举的（enumerated）属性</li><li>无论属性在实例还是在原型<blockquote><p><code>Object.keys(对象)</code> 返回所有可枚举属性名<br><code>Object.getOwnPropertyNames(对象)</code> 返回所有属性名</p></blockquote></li></ul></li></ul><h5 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Grey"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Doctor"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>字面量形式创建原型<ul><li><code>Person.prototype.constructor</code> 不再指向 Person</li><li>（前面说）每创建一个函数，就会同时创建它的 prototype 对象，这个对象自动获得 constructor 属性</li><li>这里完全重写了默认的 prototype 对象，constructor 属性指向 Object 构造函数<h5 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h5></li></ul></li><li>实例中的指针仅指向原型，而不指向构造函数</li><li>重写原型对象切断了现有原型与之前任何一件存在的对象实例直接的联系；对象实例引用的原型是重写之前的</li></ul><h5 id="原型模式的缺点"><a href="#原型模式的缺点" class="headerlink" title="原型模式的缺点"></a>原型模式的缺点</h5><p>如果原型包含引用类型值的属性，由于原型中的值是所有实例对象共享的，在一个实例对象中修改引用类型，会体现在别的实例对象中</p><h3 id="组合使用构造函数模型和原型模式"><a href="#组合使用构造函数模型和原型模式" class="headerlink" title="组合使用构造函数模型和原型模式"></a>组合使用构造函数模型和原型模式</h3><ul><li>构造函数模型用于定义实例属性</li><li>原型模式用于定义方法和共享属性</li></ul><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><ul><li><p>在构造函数中检查是否存在某个方法，再决定是否需要初始化原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3></li><li><p>不能用 instanceof</p></li><li><p>不推荐</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寄生构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3></li><li><p>稳妥对象</p><ul><li>没有公共属性，方法也不引用 this</li></ul></li><li><p>安全的环境中禁止使用 this 和 new</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只有 sayName() 能访问数据成员</p></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>面向对象语言中<ul><li>接口继承<ul><li>只继承方法签名</li></ul></li><li>实现继承<ul><li>继承实际的方法</li></ul></li></ul></li><li>ECMAScript 中函数没有签名，无法实现接口继承，故只支持实现继承<ul><li>依靠原型链<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3></li></ul></li><li>利用原型让一个引用类型继承另一个引用类型的属性和方法<blockquote><p>构造函数 A 和原型 A 都有一个指向原型对象 A 的指针，而原型对象 A 有一个指向构造函数 A 的指针。<br>让原型对象 A 等于另一个类型的实例 B。<br>此时原型对象 A（也就是实例 B）将包含一个指向原型对象 B 的指针，原型对象 B 中包含一个指向构造函数 B 的指针。<br>假如原型 B 又是另一个类型的实例 C，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。<br>这就是所谓原型链的基本概念。</p></blockquote></li></ul><h5 id="默认的原型"><a href="#默认的原型" class="headerlink" title="默认的原型"></a>默认的原型</h5><p>所有引用类型默认继承 Object，在原型链最后都是 Object 原型对象，包含一个指针指向 Object 构造函数。</p><h5 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h5><ul><li><code>实例 instanceof 构造函数</code> 实例的原型链中出现过构造函数就返回 true</li><li><code>原型对象.isPrototypeOf(实例)</code> 实例的原型链中出现过原型对象就返回 true</li></ul><h5 id="对象字面量创建原型方法会重写原型链"><a href="#对象字面量创建原型方法会重写原型链" class="headerlink" title="对象字面量创建原型方法会重写原型链"></a>对象字面量创建原型方法会重写原型链</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 导致上一行代码无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    getSubValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">    &#125;,</span><br><span class="line">    someOtherMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="原型链的缺点"><a href="#原型链的缺点" class="headerlink" title="原型链的缺点"></a>原型链的缺点</h5><ul><li>不能给超类型的构造函数传递参数<h3 id="借用构造函数（伪造对象-经典继承）"><a href="#借用构造函数（伪造对象-经典继承）" class="headerlink" title="借用构造函数（伪造对象/经典继承）"></a>借用构造函数（伪造对象/经典继承）</h3></li><li>在子类型构造函数的内部调用超类型构造函数（利用 call 或 apply）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承了 SuperType</span></span><br><span class="line">    SUperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以给超类型的构造函数传递参数<h3 id="组合继承（伪经典继承）"><a href="#组合继承（伪经典继承）" class="headerlink" title="组合继承（伪经典继承）"></a>组合继承（伪经典继承）</h3></li><li>最常用</li><li>组合原型链和借用构造函数</li><li>原型链实现对原型属性和方法的继承</li><li>借用构造函数实现对实例属性的继承</li><li>缺点<ul><li>调用两次超类型构造函数<ul><li>创建子类型原型</li><li>子类型构造函数内部</li></ul></li></ul></li></ul><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><ul><li><code>Object.create(作为新对象原型的对象， 作为新对象定义额外属性的对象)</code> 返回一个新对象</li></ul><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><ul><li>创建一个仅用于封装继承过程的函数，该<br>函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3></li><li>通过借用构造函数来继承属性</li><li>通过原型链的混成形式来继承方法</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 引用类型</title>
      <link href="/2020/02/22/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/02/22/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>引用类型</strong>是一种数据结构，用于将数据和功能组织在一起。</li><li>引用类型的值（对象）是引用类型的一个实例。</li><li><u>引用类型与类看起来相似，但并不相同。</u></li><li>ECMAScript 从技术上讲是一门面向对象的语言，但不具备传统的面向对象语言所支持的类和接口等基本结构。</li><li>引用类型也被称为<strong>对象定义</strong>，描述一类对象所具有的属性和方法。</li><li>ECMAScript 提供类很多原生引用类型（例如 Object）</li></ul><h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>大多数对象都是 Object 类型的实例</p><h6 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h6><ul><li>new 操作符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure></li><li>对象字面量<ul><li>对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义只包含默认属性和方法的对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><blockquote><p>通过对象字面量定义对象时，实际上不会调用 Object 构造函数<br>疑问：对象字面量是怎么定义对象的？</p></blockquote></li></ul></li></ul><h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>和其他语言的区别：每一项可以保存任何类型的数据，互相之间不影响</p><h6 id="创建实例-1"><a href="#创建实例-1" class="headerlink" title="创建实例"></a>创建实例</h6><ul><li>new<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>); <span class="comment">// length = 20</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Grey"</span>); <span class="comment">// length = 1</span></span><br></pre></td></tr></table></figure></li><li>省略 new<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// length = 3</span></span><br></pre></td></tr></table></figure></li><li>数组字面量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [];</span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br></pre></td></tr></table></figure><blockquote><p>数组字面量表示法时不会调用 Array 构造函数</p></blockquote></li></ul><hr><ul><li>length 可修改，会移除超出的项</li><li>当把一个值放在超出当前数组大小的位置上时，会重新计算长度，长度值为最后一项的索引 + 1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="comment">// ["red", "blue", "green"]</span></span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// ["red", "blue"]</span></span><br><span class="line">colors.length = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// ["red", "blue", empty]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// ["red", "blue", empty, "green"] length = 4</span></span><br></pre></td></tr></table></figure><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><code>value instanceof Array</code> 假定只有一个全局执行环境，如果从一个框架向另一个框架传入数组，就具有不同的构造函数<br><code>Array.isArray()</code><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3></li><li><code>Array.toString()</code></li><li><code>Array.toLocaleString()</code></li><li><code>Array.valueOf()</code><h3 id="栈-队列方法"><a href="#栈-队列方法" class="headerlink" title="栈/队列方法"></a>栈/队列方法</h3></li><li><code>Array.push</code> 末尾添加</li><li><code>Array.pop</code> 取最后一项并移除</li><li><code>Array.shift</code> 取第一项并移除</li><li><code>Array.unshift</code> 头部添加<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3></li><li><code>Array.reverse()</code> 反转顺序</li><li><code>Array.sort()</code> 先转 toString()，字符串升序<ul><li>sort 接收比较函数<ul><li>params1 -&gt; params2 ===&gt; -1</li><li>params2 -&gt; params1 ===&gt; 1<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3></li></ul></li></ul></li><li><code>Array.concat</code></li><li><code>Array.slice(a, b)</code> [a, b)<ul><li>负数则从末尾开始数</li></ul></li><li><code>Array.splice(a, b, ...c)</code><ul><li>a 位置</li><li>b 要删除的项数</li><li>c 插入的内容（若干）</li><li>return 被删除的内容</li></ul></li></ul><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>查找数组内容，<code>===</code>，返回下标</p><ul><li><code>Array.indexOf()</code></li><li><code>Array.lastIndexOf()</code><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3></li><li>两个参数<ul><li>要在每一项上运行的函数<ul><li>三个参数<ul><li>数组项的值</li><li>该项再数组中的位置</li><li>数组对象本身</li></ul></li></ul></li><li>（可选的）运行该函数的作用域对象<ul><li>影响this的值</li></ul></li></ul></li><li><code>Array.every()</code> 每一项都返回 true，则返回 true</li><li><code>Array.some()</code> 任一项返回 true，则返回 true</li><li><code>Array.filter()</code> 返回该函数返回 true 的项组成的数组</li><li><code>Array.map()</code> 返回每次函数调用的结果组成的数组</li><li><code>Array.forEach()</code> 没有返回值 </li></ul><p>以上方法都不回修改数组中包含的值</p><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><ul><li><p><code>Array.reduce()</code></p></li><li><p><code>Array.reduceRight()</code></p></li><li><p>两个参数</p><ul><li>每一项上调用的函数<ul><li>四个参数<ul><li>前一个值</li><li>当前值</li><li>项的索引</li><li>数组对象</li></ul></li></ul></li><li>（可选的）作为归并基础的初始值</li></ul></li><li><p>返回值作为第一个参数传给下一项</p></li><li><p>第一次迭代发生在第二项上，第一个参数是数组的第一项，第二个参数是数组的第二项</p></li></ul><h2 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h2><ul><li><code>Date.parse()</code> <ul><li>params: 表示日期字符串，格式因地区而异</li><li>return: 毫秒</li></ul></li><li><code>Date.UTC()</code><ul><li>params: 年份、月份（0开始）、天数、小时、分钟、秒、毫秒</li><li>return: 毫秒</li></ul></li><li><code>Date.now()</code><h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3></li><li><code>Date.toLocaleString()</code> 根据当地时区</li><li><code>Date.toString()</code> 带有时区信息</li><li><code>Date.valueOf()</code> 毫秒<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3></li><li><code>Date.toDateString()</code></li><li><code>Date.toTimeString()</code></li><li><code>Date.toLocaleDateString()</code></li><li><code>Date.toLocaleTimeString()</code></li><li><code>Date.toUTCString()</code></li><li><code>Date.toLocaleString()</code></li></ul><p>因浏览器而异</p><h2 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</span><br></pre></td></tr></table></figure><ul><li>pattern<ul><li>( [ { \ ^ $ | ) ? * + . ] } 需要转义</li></ul></li><li>flags<ul><li>g 全局，默认匹配第一个停止</li><li>i 不区分大小写</li><li>m 多行模式<h3 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h3></li></ul></li><li><code>global</code> </li><li><code>ignoreCase</code> </li><li><code>lastIndex</code> </li><li><code>multiline</code> </li><li><code>source</code> </li></ul><h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><ul><li><code>exec</code> </li><li><code>test</code> </li><li><code>toString</code> </li><li><code>toLocaleString</code> </li><li><code>valueOf</code> </li></ul><h3 id="构造函数属性"><a href="#构造函数属性" class="headerlink" title="构造函数属性"></a>构造函数属性</h3><p>其他语言中被看成是<strong>静态属性</strong></p><table><thead><tr><th>长属性名</th><th>短属性名</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>$_</td><td>最近一次要匹配的字符串</td></tr><tr><td>lastMatch</td><td>$&amp;</td><td>最近一次的匹配项</td></tr><tr><td>lastParen</td><td>$+</td><td>最近一次匹配的捕获组</td></tr><tr><td>leftContext</td><td>$`</td><td>input 字符串中 lastMatch 之前的文本</td></tr><tr><td>multiline</td><td>$*</td><td>布尔值，是否所有表达式都使用多行模式</td></tr><tr><td>rightContext</td><td>$’</td><td>input 字符串中 lastMatch 之后的文本</td></tr></tbody></table><h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><ul><li><p>每个函数都是 Function 类型的实例，具有属性和方法。</p></li><li><p>函数名是一个只想函数对象的指针，不会与某个函数绑定。</p><h5 id="创建实例-2"><a href="#创建实例-2" class="headerlink" title="创建实例"></a>创建实例</h5></li><li><p>函数声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>区别：<br>解析器会先读取函数声明，在执行任何代码之前可用（函数声明提升）<br>函数表达式要等解析器执行到它所在的代码行才会被解释执行</p></blockquote></li><li><p>Function 构造函数（不推荐）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>);</span><br></pre></td></tr></table></figure><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>声明两个同名函数，后面的函数覆盖前面的，结合 “函数是对象，函数名是指针” 很好理解。</p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3></li><li><p>函数名本身是变量，可以作为值来使用</p></li><li><p>可以作为参数，也可以作为返回值</p></li></ul><h3 id="函数的内部属性"><a href="#函数的内部属性" class="headerlink" title="函数的内部属性"></a>函数的内部属性</h3><ul><li><code>arguments</code> 类数组对象<ul><li><code>callee</code> 属性，该属性是一个指针，指向拥有这个 arguments 对象的函数</li></ul></li><li><code>this</code> 引用的是执行函数的环境对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sindow.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">// "red"</span></span><br><span class="line"></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();   <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure></li><li><code>caller</code> 调用当前函数的函数的引用，全局中调用当前函数则 null<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(inner.caller);</span><br><span class="line">    <span class="comment">// inner.callr 指向 outer()</span></span><br><span class="line">    <span class="comment">// 等价于 arguments.callee.caller</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3></li><li><code>length</code> 函数希望接收的命名参数的个数</li><li><code>prototype</code><ul><li>对引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，toString() 和 valueOf() 等方法都是保存在 prototype 名下，只是通过各自对象的实例访问。</li><li>不可枚举，for-in 无法发现。</li></ul></li></ul><p>每个函数都包含两个非继承而来的方法，都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。</p><ul><li><p><code>apply</code> </p><ul><li>两个参数<ul><li>在其中运行函数的作用域</li><li>参数数组</li></ul></li></ul></li><li><p><code>call</code> </p><ul><li>1 + n 个参数<ul><li>在其中运行函数的作用域</li><li>一个一个地传入参数</li></ul></li></ul></li><li><p><code>bind</code> 创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值</p></li></ul><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript 提供 3 个特殊的引用类型：<code>Boolean</code>、<code>Number</code>、<code>String</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"smoe.txt"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>基本类型不是对象，理论上不应该有方法。<br>当第二行代码访问 s1 时，访问过程处于一种读取模式，从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台自动完成：<br>(1) 创建 String 类型的一个实例<br>(2) 在实例上调用指定的方法<br>(3) 销毁这个实例</p></blockquote><ul><li>引用类型与基本包装类型的主要区别是对象的生存期<ul><li>引用类型的实例在执行流离开当前作用域之前一直保存在内存中</li><li>基本包装类型只存在于一行代码的执行瞬间</li></ul></li><li>可以显示的创建基本包装类型的对象，但会分不清自己在处理基本类型还是引用类型的值</li><li>new 调用基本包装类型的构造函数，和转型函数是不一样的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value); <span class="comment">// 转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number); <span class="comment">// "number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);     <span class="comment">// “object"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>布尔表达式中，所有的对象都会转为 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>产生误解，建议不要使用</p><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><ul><li><code>toString(n)</code> n 进制</li><li><code>toFixed(n)</code> 四舍五入 n 位小数</li><li><code>toExponential(n)</code> n 位数表示一个数字</li></ul><h4 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h4><ul><li><code>charAt</code></li><li><code>charCodeAt</code></li><li><code>方括号表示法[]下标读取字符</code></li></ul><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><ul><li><code>concat</code> 拼接字符串，常用<code>+</code></li><li><code>slice</code></li><li><code>substr</code></li><li><code>substring</code></li></ul><h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><ul><li><code>indexOf</code></li><li><code>lastIndexOf</code></li></ul><h4 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim() 方法"></a>trim() 方法</h4><p>创建一个字符串的副本，删除前置以及后缀的所有空格，然后返回结果</p><h4 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h4><ul><li><code>toLowerCase</code></li><li><code>toLocaleLowerCase</code></li><li><code>toUpperCase</code></li><li><code>toLocaleUpperCase</code></li></ul><h4 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h4><ul><li><code>match</code><ul><li>params:正则表达式或 RegExp 对象</li><li>本质调用 RegExp 的 exec</li></ul></li><li><code>search</code><ul><li>params:正则表达式或 RegExp 对象</li><li>return: 下标，找不到 -1</li></ul></li><li><code>replace</code> <ul><li>两个参数，用第二个参数替换第一个</li><li>第一个参数可以是正则</li><li>第二个参数可以是函数</li></ul></li><li><code>split</code> 基于一个制定的分隔符，将一个字符串分割成多个子字符串</li></ul><h4 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare() 方法"></a>localeCompare() 方法</h4><p>比较两个字符串，各地区实现不同</p><h4 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode() 方法"></a>fromCharCode() 方法</h4><p>接收一个或多个字符编码，然后转换成一个字符串</p><h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>ECMA-262对<strong>单体内置对象</strong>的定义：<u>由 ECMAScript 实现提供的，不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。</u></p><p>前面已经介绍了大多数内置对象，如 Object、Array、String</p><h3 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h3><ul><li>不属于任何其他对象的属性和方法，最终都是 Global 对象的属性和方法</li><li>事实上，没有全局变量或全局函数。所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。如<ul><li>isNan()、isFinite()、parseint()</li><li>encodeURI() 用于整个 URI<br>encodeURIEomponent() 用于 URI 中的一段<br>decodeURI()<br>decodeURIEomponent()</li><li>eval() 像一个完整的 ECMAScript 解析器<ul><li>params: 要执行的 ECMAScript 字符串</li></ul></li><li>Global 对象属性<ul><li>undefined、NaN、Infinity 等</li><li>Object、Function 等</li></ul></li><li>window 对象<ul><li>Web 浏览器中，Global 对象是 window 对象的一部分</li></ul></li></ul></li></ul><h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><ul><li>Math 对象的属性<ul><li>Math.E</li><li>Math.LN10</li><li>Math.LN2</li><li>Math.LOG2E</li><li>Math.LOG10</li><li>Math.PI</li><li>Math.SQRT1_2</li><li>Math.SQRT2</li></ul></li><li>min()、max()</li><li>舍入方法<ul><li>Math.ceil() 向上舍入</li><li>Math.floor() 向下舍入</li><li>Math.round() 四舍五入</li></ul></li><li>random() [0, 1) 随机数</li><li>其他方法<ul><li>Math.abs(num)</li><li>Math.exp(num)</li><li>Math.log(num)</li><li>Math.pow(num, power)</li><li>Math.sqrt(num)</li><li>Math.acos(x)</li><li>……</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 变量、作用域和内存问题</title>
      <link href="/2020/02/17/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/17/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><ul><li>基本数据类型（5）按值访问，可以操作保存在变量中的实际的值。占据固定大小的空间，被保存在栈内存中。</li><li>引用类型（1）的值是保存在内存中的对象，保存在堆内存中。JS 不能直接操作对象的内存空间：复制保存对象的某个变量时，操作对象的引用；为对象添加属性时，操作的是实际的对象。</li></ul><h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><ul><li>基本类型：创建新值</li><li>引用类型：创建新值，值是指针，实际与旧值引用同一个对象</li></ul><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript 中所有函数的参数都是按值传递的。</p><ul><li>基本类型：被传递的值会被复制给一个局部变量。</li><li>引用类型：被传递的值的<strong>地址</strong>复制给一个局部变量。因此这个局部变量的变化会反应在函数的外部。<blockquote><p>若在函数体内对这个局部变量进行重新赋值，那么保存的地址就改变了，指向的内存也不再是被传入的对象。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//“Nicholas”</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = <span class="string">"Greg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//“Nicholas”</span></span><br></pre></td></tr></table></figure><p>在内部重写 obj 时，变量引用的就是一个局部对象了。局部对象在函数执行完毕后立即被销毁。</p><h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><ul><li>基本类型：<code>typeof</code></li><li>引用类型：<code>instanceof</code></li><li>根据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result = variable instanceof constructor</span></span><br><span class="line"><span class="comment">// 根据原型链来识别</span></span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>);</span><br></pre></td></tr></table></figure>所有引用类型的值都是 Object 的实例。<code>Obj instanceof Object</code> 始终返回 true，检测基本类型始终 false，因为基本类型不是对象。</li></ul><h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><ul><li>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</li><li>每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的所有变量和函数都保存在这个对象中。</li><li><strong>全局执行环境</strong>：根据宿主环境。WEB 浏览器中是 window 对象。</li><li><strong>执行环境</strong>，函数的环境，保存在栈中。</li><li>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，<u>保证对执行环境有权访问的所有变量和函数的有序访问。</u><blockquote><p>作用域链的前端，始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>作为变量对象。活动对象在最开始时只包含一个变量（即arguments对象，全局环境中不存在）。下一个变量对象来自包含（外部）环境……一直到全局执行环境。<br>标识符解析是沿着作用域链一级一级地搜索标识符的过程。<br>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境重的变量和函数。</p></blockquote></li></ul><h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><ul><li>try-catch 语句的 catch 块</li><li>with 语句<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</span><br><span class="line">    <span class="keyword">with</span> (location) &#123;</span><br><span class="line">        <span class="keyword">var</span> url = href + qs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>with 语句接收 location 对象，因此其变量对象中包含了 location 对象的所有属性和方法，而这个变量被添加到了作用域链的前端。<blockquote><p>疑问：<br>作用域链：全局执行环境-&gt;buildUrl()-&gt;with(location)<br>with 中定义的变量 url 为什么能够在外部环境 buildUrl 中访问？url是被定义在全局执行环境中的 location 变量对象中吗？</p><hr><p>因为没有块级作用域，变量声明会被添加到当前的执行环境（这里是buildUrl（））中</p></blockquote></li></ul><h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(color);</span><br></pre></td></tr></table></figure><p>js 中，if 语句中的变量声明会将变量添加到当前的执行环境（这里是全局环境）<br>如果没有用 var 声明，会直接被添加到全局环境。</p><blockquote><p>let 似乎解决了这个问题，本书没有讲到，看完 es6 再来补。</p></blockquote><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><ul><li>当变量进入环境，标记为“进入环境”。<ul><li>逻辑上讲，永远不能释放进入环境的变量所占用的内存。</li></ul></li><li>当变量离开环境时，则标记“离开环境”。</li><li>可以使用任何方式来标记变量。如：<ul><li>翻转某个特殊的位</li><li>“进入环境”变量列表及“离开环境”变量列表<blockquote><p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后再被加上标记的变量将被视为准备删除的变量。最后完成内存清除工作，销毁值并回收内存空间。</p></blockquote></li></ul></li></ul><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>跟踪记录每个值被引用的次数，赋值给变量则该值+1，若变量取得另一个值，则该值-1。</p><blockquote><p>垃圾收集器下次运行时，释放计数 0 的值占用的内存。</p></blockquote><blockquote><p>循环引用会导致引用次数永远不为 0<br>BOM 和 DOM 中的对象是使用 C++ 以 COM（Component Object Model，组件对象模型）对象的形式实现的，COM 对象的垃圾收集机制就是引用计数策略。<br>解决：手动断开循环引用（赋值为null）</p></blockquote><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>垃圾收集器是周期运行的，如果为变量分配的内存数量很大，那么回收工作量也相当大，确定时间间隔很重要。</p><h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>使用具备垃圾收集机制的语言编写程序，一般不必操心内存管理。但 js 比较特殊，因为分配给 Web 浏览器的可用内存通常比桌面应用少。<br>尽量少用内存页面会有更好的性能。一旦数据不再有用，赋值 null 来<strong>解除引用</strong>。适用于大多数全局变量和全局对象的属性，局部变量会在离开执行环境时自动解除。<br>解除引用不是自动回收内存，是让值脱离环境，垃圾收集器下次运行的时候将其回收。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 基本概念</title>
      <link href="/2020/02/15/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/02/15/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>ECMAScript 标示符采用驼峰大小写格式</p><h3 id="严格模式-strict-mode"><a href="#严格模式-strict-mode" class="headerlink" title="严格模式 strict mode"></a>严格模式 strict mode</h3><p>在顶部添加代码 <code>&quot;use strict&quot;;</code><br>编译指示(pragma)，用于告诉支持的 JavaScript 引擎切换到严格模式。<br>函数体中包含指定函数在严格模式下执行。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>松散类型：可以用来保存任何类型的数据。每个变量仅仅用于保存值的占位符。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>5 基本数据类型 - <code>Undefined、Null、Boolean、Number、String</code><br>1 复杂数据类型 - <code>Object</code><br><code>Oobject</code> 本质上是由一组无序的名值对组成的<br>ECMAScript 不支持任何创建自定义类型的机制</p><p><code>typeof</code> 操作符，返回值（均为字符串）<br>未定义：<code>&quot;undefined&quot;</code><br>布尔值：<code>&quot;boolean&quot;</code><br>字符串：<code>&quot;string&quot;</code><br>数值：<code>&quot;number&quot;</code><br>对象或<code>null</code>：<code>&quot;object&quot;</code><br>函数：<code>&quot;function&quot;</code><br>特殊值 <code>null</code> 被认为是一个空的对象引用，因此返回 <code>&quot;object&quot;</code>。<br>safari 5 和 Chrome 7 及之前版本 <code>typeof 正则表达式</code> 会返回 <code>&quot;function&quot;</code>，而其他浏览器返回<code>&quot;object&quot;</code></p><blockquote><p>从技术角度讲，函数在 ECMAScript 中是对象，而不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 <code>typeof</code> 操作符区分函数和其他对象是有必要的。</p></blockquote><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><p><code>Undefined</code> 类型只有一个值，即 <code>undefined</code></p><blockquote><p>变量已声明但未初始化（message）：该变量的值为 <code>undefined</code>,<code>typeof</code> 返回<code>&quot;undefined&quot;</code><br>若变量未声明（age）：只可以执行<code>typeof</code> 操作符，返回<code>&quot;undefined&quot;</code>，其他操作产生错误。</p><p> <img src="/.com//%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="变量初始化"></p></blockquote><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h3><p><code>Null</code> 类型只有一个值，即 <code>null</code>，表示一个空对象指针，因此 <code>typeof null</code> 返回 <code>&quot;object&quot;</code>。<br>如果定义的变量准备用于保存对象，那么最好初始化为 <code>null</code>，可以直接判断是否已经保存了一个对象的引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>) &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，<code>undefined</code> 派生自 <code>null</code>，因此：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>); </span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。调用 <code>转型函数 Boolean()</code> 获得对应 Boolean 值。</p><table><thead><tr><th>数据类型</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>任何非空字符串</td><td>“”（空字符串）</td></tr><tr><td>Number</td><td>任何非零数字值（包括无穷大）</td><td>0 和 NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>N/A</td><td>undefined</td></tr><tr><td>N/A：not applicable 的缩写，不适用</td><td></td><td></td></tr></tbody></table><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>使用 <a href="https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin" target="_blank" rel="noopener">IEEE754</a> 格式来表示整数和浮点数值（双精度数值）。<br>为了支持各种数值类型，ECMA-262定义了不同的数值字面量格式。</p><ul><li>十进制</li><li>八进制（0）</li><li>十六进制（0x）<br>在进行算数计算时，都会转为十进制数值。<h5 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h5>浮点数值需要的内存空间是整数值的两倍。<br>6 个 0 以上，e表示法：3.125e7、3e-17<br>浮点数值最高精度 17 位小数，但在算数计算时精度远不如整数。<img src="/.com//%E7%B2%BE%E5%BA%A6.png" alt="精度"><br>（IEEE745 数值的浮点计算通病，不是 ECMAScript 独有）</li></ul><h5 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h5><p><code>Number.MIN_VALUE</code> 5e-324<br><code>Number.MAX_VALUE</code> 1.7976931348623157e+308<br><code>Number.POSITIVE_INFINITY</code> 或 <code>Infinity</code> 正无穷<br><code>Number.NEGATIVE_INFINITY</code> 或 <code>-Infinity</code> 负无穷<br><code>isFinite()</code>有穷返回 <code>true</code></p><h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><ul><li>任何涉及 NaN 的操作都会返回 NaN</li><li>NaN 与任何值都不相等，包括自己本身</li><li><code>isNaN()</code> 函数判断变量是否<strong>可以转为数值</strong></li></ul><blockquote><p>isNaN(object):<br>首先调用对象的 valueOf() 方法，检查该方法的返回值是否可以转换为数值<br>如果不能，基于这个返回值再调用 toString() 方法，再测试返回值。</p></blockquote><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><p><code>Number()</code> 任何类型<br><code>parseInt()</code> 字符串<br><code>parseFloat()</code> 字符串</p><blockquote><p>parseInt 和 parseFloat 从第一个符合条件的字符开始转换，开始后若碰到不符合的字符，抛弃之后的字符。</p></blockquote><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><ul><li>Unicode 字符组成的字符序列。</li><li>ECMAScript 中双引号/单引号没有区别。</li></ul><h5 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h5><p>字符字面量，即转义字符，被作为一个字符来解析。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>不可改变<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">"Java"</span>;</span><br><span class="line">lang = lang + <span class="string">"Script"</span>;</span><br><span class="line"><span class="comment">// 首先创建一个能容纳 10 个字符的新字符串，然后填充 “Java” 和 “Script”，最后销毁原来的字符串。（不在原字符串上修改）</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="转为字符串"><a href="#转为字符串" class="headerlink" title="转为字符串"></a>转为字符串</h5><ul><li><p><code>toString()</code> 几乎每个值都有这个方法，<code>null</code> 和 <code>undefined</code> 值没有。</p><ul><li>通常不需要参数。</li><li>调用数值的 <code>toString()</code> 方法时可以传递进制基数作为参数。</li></ul></li><li><p>不知道是不是 <code>null</code> 或 <code>undefined</code> 的时候可以使用转型函数 <code>String()</code></p><ul><li>如果值有 <code>toString()</code> 方法，调用</li><li>如果值是 <code>null</code>，返回 <code>&quot;null&quot;</code></li><li>如果值是 <code>undefined</code>，返回 <code>&quot;undefined&quot;</code></li></ul></li><li><p><code>obj + &quot;&quot;</code> 和字符串加在一起</p></li></ul><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><ul><li>对象是一组数据和功能的集合。<blockquote><p>在 ECMAScript 中，<code>Object</code> 类型所具有的任何属性和方法也同样存在于更具体的对象中。<br><code>Object</code> 的每个实例都具有下列属性和方法。</p></blockquote></li><li><code>Constructor</code> 构造函数</li><li><code>hasOwnProperty(propertyName)</code> 检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。参数（propertyName）为字符串</li><li><code>isProtorypeOf(object)</code> 检查传入的对象是否是另一个对象的原型</li><li><code>propertyIsEnumerable(propertyName)</code> 检查给定的属性是否能够使用 for-in 语句。参数（propertyName）为字符串</li><li><code>toLocaleString()</code> 根据本地规范进行格式化</li><li><code>toString()</code> </li><li><code>valueOf()</code> 通常自动调用</li></ul><blockquote><p>从技术角度讲，ECMA-262 中对象的行为不一定适用于 JS 中的其他对象。如 BOM 和 DOM 中的对象属于宿主对象，宿主对象可能会也可能不会继承 Object。</p></blockquote><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符应用于对象时，通常会调用对象的 <code>valueOf()</code> 和（或）<code>toString()</code> 方法。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>枚举对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性没有顺序，所以先后顺序因浏览器而异。</p><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>类似 go to 不建议使用</p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>简化多次编写同一个对象的工作<br>大量使用 with 会导致性能下降，不建议使用</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>比较值时使用全等 <code>===</code></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>未指定返回值的函数返回 <code>undefined</code></p><blockquote><p>函数要么始终返回一个值，要么永远都不要返回值。</p></blockquote><h3 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h3><ul><li>函数体内通过 arguments 对象来访问参数数组。</li><li>ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。<blockquote><p>详看第四章 —— 传递参数</p></blockquote></li></ul><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>不存在函数签名的特性，ECMAScript 函数不能重载<br>定义两个名字相同的函数，会被后面定义的函数覆盖</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 在 HTML 中使用 JavaScript</title>
      <link href="/2020/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8%20HTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20JavaScript/"/>
      <url>/2020/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8%20HTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20JavaScript/</url>
      
        <content type="html"><![CDATA[<h2 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a><code>script</code>元素</h2><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li><p>src 可选。包含要执行代码的外部文件。</p><blockquote><p>如果有 src，标签内嵌入的 JavaScript 代码会被忽略<br>可以包含来自外部域的 JavaScript 文件。这点与 <code>img</code> 相同</p></blockquote></li><li><p>async 可选。立即下载脚本，但不妨碍页面中其他操作。只对外部脚本文件有效。<strong>不能保证按顺序执行。不要修改 DOM 会在load 事件前执行，可能会在 <code>DOMContentLoaded</code> 事件触发之前或之后执行。</strong></p></li><li><p>defer 可选。延迟到文档完全被解析和显示之后（<code>/html</code>标签后）执行。<strong>只对外部脚本文件有效。</strong>（嵌入脚本的 defer 属性会被忽略）<strong>延迟脚本不一定会按照顺序执行，也不一定会在 <code>DOMContentLoaded</code> 事件触发前执行，因此最好只有一个延迟脚本。</strong></p><blockquote><p>只要不存在 defer 和 async 属性，浏览器都会按照 <code>scrip</code> 元素在页面中出现的先后顺序进行解析</p></blockquote></li></ul><ul><li>type 可选。language（已废弃）的替代属性；脚本语言的内容类型（MIME 类型）。默认值 text/javascript<blockquote><p>不推荐 text/javascript 和 text/ecmascript<br>服务器在传送 JavaScript 文件时使用的 MIME 类型通常是 application/x-javascript<br>非 IE 浏览器中可以使用 application/javascript 和 application/ecmascript</p></blockquote></li><li>charset 可选。表示通过 src 属性指定代码的字符集。大多数浏览器忽略</li></ul><h3 id="标签的位置"><a href="#标签的位置" class="headerlink" title="标签的位置"></a>标签的位置</h3><p>放在 <code>head</code> 中必须先把 js 代码下载、解析和执行完成后才能开始呈现页面内容，此时页面空白。<br>把 js 引用放在 <code>body</code> 中，空白时间会缩短。<br>或者设置 defer 属性，立即下载，延迟（<code>/html</code>标签后）执行。</p><h2 id="外部文件的优点"><a href="#外部文件的优点" class="headerlink" title="外部文件的优点"></a>外部文件的优点</h2><ul><li>可维护性：集中精力编辑 js 代码</li><li>可缓存：如果两个页面使用同一个文件，只需下载一次</li><li>适应未来</li></ul><h2 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h2><p><code>!DOCTYPE html</code></p><h2 id="noscript元素"><a href="#noscript元素" class="headerlink" title="noscript元素"></a><code>noscript</code>元素</h2><ul><li>浏览器不支持脚本</li><li>浏览器支持脚本，但脚本被禁用<br>符合上述条件，元素内容会被显示。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 JavaScript 简介</title>
      <link href="/2020/01/16/%E7%AC%AC%E4%B8%80%E7%AB%A0-JavaScript%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/01/16/%E7%AC%AC%E4%B8%80%E7%AB%A0-JavaScript%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>ECMA-262——定义一种名为 ECMAScript 的新脚本语言的标准<br>浏览器开发商将 ECMAScript 作为各自 JavaScript 实现的基础</p><blockquote><p>JavaScript 包括：</p><ul><li>核心： ECMAScript</li><li>文档对象模型： DOM</li><li>浏览器对象模型： BOM</li></ul></blockquote><h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><ul><li>没有输入和输出定义</li><li>ECMA-262 定义了 ECMAScript 基础，在此基础上可以构建更完善的脚本语言</li><li>宿主环境提供基本的 ECMAScript 实现，也提供该语言的拓展，以便语言和环境之间对接交互</li></ul><p>ECMA-262 标准规定了</p><ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>对象<br>ECMAScript 就是对实现该标准规定的各个方面内容的语言的描述<br>JavaScript 实现了 ECMAScript<br>Adobe ActionScript 也实现了 ECMAScript<h6 id="什么是-ECMAScript-兼容"><a href="#什么是-ECMAScript-兼容" class="headerlink" title="什么是 ECMAScript 兼容"></a>什么是 ECMAScript 兼容</h6><blockquote><p>要想成为 ECMAScript 的实现，必须做到：</p><ul><li>支持 ECMA-262 描述的所有“类型、值、对象、属性、函数以及程序语法和语义”</li><li>支持 Unicode 字符标准</li><li>可以进行拓展：<ul><li>添加 ECMA-262 没有描述的“更多类型、值、对象、属性和函数”。主要指新对象和对象的新属性</li><li>支持 ECMA-262 没有定义的“程序和正则表达式语法”。即可以修改和拓展内置的正则表达式语法</li></ul></li></ul><p>为开发人员基于 ECMAScript 开发一门新语言提供了广阔的空间和极大的灵活性</p></blockquote></li></ul><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM（Document Object Model）是针对 XML 但经过拓展用于 HTML 的 API（Application Programming Interface）</p><ul><li>W3C 制定了 DOM 标准</li><li>DOM 不止针对 JavaScript，很多别的语言也实现了 DOM</li><li>DOM 包括 DOM 核心和 DOM HTML<ul><li>DOM 核心规定如何映射基于 XML 的文档结构</li><li>DOM HTML 模块则在 DOM 核心 的基础上添加了针对 HTML 的对象和方法</li></ul></li></ul><p>除了 DOM 核心和 DOMHTML 接口之外，另外几种语言发布了只针对自己的 DOM 标准。以下语言都是基于 XML 的，每种语言的 DOM 标准都添加了与特定语言相关的新方法和新接口：</p><ul><li>SVG(Scalable Vector Graphic)</li><li>MathML（Mathematical Markup Language）</li><li>SMIL（Synchronized Multimedia Integration Language）<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3>开发人员使用 BOM（Browser Object Model）控制浏览器显示的页面以外的部分<br>BOM 作为 JavaScript 实现的一部分却没有相关的标准。H5 致力于把很多 BOM 功能写入正式规范。<br>根本上讲，BOM 只处理浏览器窗口和框架；但习惯上把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
