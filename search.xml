<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第六章 面向对象程序设计</title>
      <link href="/2020/02/28/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2020/02/28/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li>面向对象语言的标志是都有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。</li><li>而 ECMAScript 中没有类的概念，因此它的对象和基于类的语言中的对象有所不同。</li><li>ECMAscript 对象定义：<u>无序属性的集合，其属性可以包含基本值、对象或函数。</u></li><li>每个对象都是基于一个引用类型创建的。可以是原生类型，也可以是开发人员定义的类型。</li></ul><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><h5 id="属性数据"><a href="#属性数据" class="headerlink" title="属性数据"></a>属性数据</h5><ul><li><code>[[Configurable]]</code>:表示能否通过 delete 删除属性从而定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li><li><code>[[Enumerable]]</code>:表示能否通过 for-in 循环返回属性。</li><li><code>[[Writable]]</code>:表示能否修改属性的值。</li><li><code>[[Value]]</code>:包含设个属性的数据值。<blockquote><p><code>Object.defineProperty(属性所在对象，属性的名字，描述符对象)</code>：修改属性默认的特性</p></blockquote></li></ul><h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><ul><li><code>[[Configurable]]</code>:表示能否通过 delete 删除属性从而定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li><li><code>[[Enumerable]]</code>:表示能否通过 for-in 循环返回属性。</li><li><code>[[Get]]</code>:在读取属性时调用的函数，默认值 <code>undefined</code>。</li><li><code>[[Set]]</code>:在写入属性时调用的函数，默认值 <code>undefined</code>。<blockquote><p>访问器属性不能直接定义，必须使用<code>Object.defineProperty()</code>来定义。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">     _year: <span class="number">2004</span>,</span><br><span class="line">     edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123; </span><br><span class="line">     <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="keyword">set</span>: function(newValue) &#123; </span><br><span class="line">     <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123; </span><br><span class="line">         <span class="keyword">this</span>._year = newValue; </span><br><span class="line">         <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>; </span><br><span class="line">alert(book.edition); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><ul><li><code>Object.defineProperties(对象，要添加和修改属性)</code> 通过描述赋一次定义多个属性<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3></li><li><code>Object.getOwnPropertyDescriptor(属性所在的对象，要读取其描述符的属性名称)</code>返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。</li></ul><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul><li>抽象了创建具体对象的过程<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3></li><li>定义在 Global 对象（浏览器即 window 对象）中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（this 就指向了这个新对象）</li><li>执行构造函数中的代码</li><li>返回新对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor == Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h5><ul><li>构造函数与其他函数唯一的区别是调用方式不同<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">person.sayName();</span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"><span class="built_in">window</span>.sayName();</span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">o.sayName();</span><br></pre></td></tr></table></figure></li></ul><h5 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h5><ul><li><p>每个方法都要在每个实例上重新创建一遍</p></li><li><p>不同实例上的同名函数是不相等的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> <span class="keyword">this</span>.age = age; </span><br><span class="line"> <span class="keyword">this</span>.job = job; </span><br><span class="line"> <span class="keyword">this</span>.sayName = sayName; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> alert(<span class="keyword">this</span>.name); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果需要很多方法，就需要定义很多全局函数</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3></li><li><p>每个函数都有 prototype（原型）属性</p><ul><li>是一个指针，指向一个对象<ul><li>对象包含所有实例共享的属性和方法</li><li>换句话说，prototype 就是通过调用构造函数而创建的对象实例的原型对象</li></ul></li></ul></li><li><p>好处</p><ul><li>让所有对象实例共享它所包含的属性和方法</li><li>不必在构造函数中定义对象实例的信息，而且将这些信息直接添加到原型对象中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Grey"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Doctor"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h5></li></ul></li><li><p>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象</p></li><li><p>默认情况下，所有原型对象会自动获得一个 constructor(构造函数) 属性，这个属性包含一个指向 prototype 属性所在函数（也就是构造函数）的指针</p></li><li><p><code>Person.prototype.constructor</code> 指向 <code>Person</code><br><img src="/.com//%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p></li><li><p>每个实例有一个<code>[[Prototype]]</code>（<code>__proto__</code>）属性，指向构造函数的原型对象</p></li><li><p><code>isPrototypeOf()</code>确定原型关系</p><ul><li><code>Person.prototype.isPrototypeOf(person)</code></li></ul></li><li><p><code>Object.getPrototypeOf()</code> 返回[[Prototype]] 的指针</p><ul><li><code>Object.getPrototypeOf(person) == Person.prototype</code></li></ul></li><li><p>在实例中修改属性值，会屏蔽原型中的同名属性</p><ul><li><code>delete person.name</code> 删除实例中的 name 属性，<code>console.log(person.name)</code> 将输出原型中的 name 属性 <code>Person.prototype.name</code></li></ul></li><li><p><code>hasOwnProperty()</code> 检测一个属性是否在实例中，false 来自原型</p></li></ul><h5 id="原型与-in-操作符"><a href="#原型与-in-操作符" class="headerlink" title="原型与 in 操作符"></a>原型与 in 操作符</h5><ul><li>单独使用<ul><li>属性 in 实例</li><li>无论属性在实例还是在原型，都返回 true</li></ul></li><li>for-in<ul><li>返回可枚举的（enumerated）属性</li><li>无论属性在实例还是在原型<blockquote><p><code>Object.keys(对象)</code> 返回所有可枚举属性名<br><code>Object.getOwnPropertyNames(对象)</code> 返回所有属性名</p></blockquote></li></ul></li></ul><h5 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Grey"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Doctor"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>字面量形式创建原型<ul><li><code>Person.prototype.constructor</code> 不再指向 Person</li><li>（前面说）每创建一个函数，就会同时创建它的 prototype 对象，这个对象自动获得 constructor 属性</li><li>这里完全重写了默认的 prototype 对象，constructor 属性指向 Object 构造函数<h5 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h5></li></ul></li><li>实例中的指针仅指向原型，而不指向构造函数</li><li>重写原型对象切断了现有原型与之前任何一件存在的对象实例直接的联系；对象实例引用的原型是重写之前的</li></ul><h5 id="原型模式的缺点"><a href="#原型模式的缺点" class="headerlink" title="原型模式的缺点"></a>原型模式的缺点</h5><p>如果原型包含引用类型值的属性，由于原型中的值是所有实例对象共享的，在一个实例对象中修改引用类型，会体现在别的实例对象中</p><h3 id="组合使用构造函数模型和原型模式"><a href="#组合使用构造函数模型和原型模式" class="headerlink" title="组合使用构造函数模型和原型模式"></a>组合使用构造函数模型和原型模式</h3><ul><li>构造函数模型用于定义实例属性</li><li>原型模式用于定义方法和共享属性</li></ul><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><ul><li><p>在构造函数中检查是否存在某个方法，再决定是否需要初始化原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3></li><li><p>不能用 instanceof</p></li><li><p>不推荐</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寄生构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3></li><li><p>稳妥对象</p><ul><li>没有公共属性，方法也不引用 this</li></ul></li><li><p>安全的环境中禁止使用 this 和 new</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只有 sayName() 能访问数据成员</p></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>面向对象语言中<ul><li>接口继承<ul><li>只继承方法签名</li></ul></li><li>实现继承<ul><li>继承实际的方法</li></ul></li></ul></li><li>ECMAScript 中函数没有签名，无法实现接口继承，故只支持实现继承<ul><li>依靠原型链<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3></li></ul></li><li>利用原型让一个引用类型继承另一个引用类型的属性和方法<blockquote><p>构造函数 A 和原型 A 都有一个指向原型对象 A 的指针，而原型对象 A 有一个指向构造函数 A 的指针。<br>让原型对象 A 等于另一个类型的实例 B。<br>此时原型对象 A（也就是实例 B）将包含一个指向原型对象 B 的指针，原型对象 B 中包含一个指向构造函数 B 的指针。<br>假如原型 B 又是另一个类型的实例 C，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。<br>这就是所谓原型链的基本概念。</p></blockquote></li></ul><h5 id="默认的原型"><a href="#默认的原型" class="headerlink" title="默认的原型"></a>默认的原型</h5><p>所有引用类型默认继承 Object，在原型链最后都是 Object 原型对象，包含一个指针指向 Object 构造函数。</p><h5 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h5><ul><li><code>实例 instanceof 构造函数</code> 实例的原型链中出现过构造函数就返回 true</li><li><code>原型对象.isPrototypeOf(实例)</code> 实例的原型链中出现过原型对象就返回 true</li></ul><h5 id="对象字面量创建原型方法会重写原型链"><a href="#对象字面量创建原型方法会重写原型链" class="headerlink" title="对象字面量创建原型方法会重写原型链"></a>对象字面量创建原型方法会重写原型链</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">// 导致上一行代码无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    getSubValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">    &#125;,</span><br><span class="line">    someOtherMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="原型链的缺点"><a href="#原型链的缺点" class="headerlink" title="原型链的缺点"></a>原型链的缺点</h5><ul><li>不能给超类型的构造函数传递参数<h3 id="借用构造函数（伪造对象-经典继承）"><a href="#借用构造函数（伪造对象-经典继承）" class="headerlink" title="借用构造函数（伪造对象/经典继承）"></a>借用构造函数（伪造对象/经典继承）</h3></li><li>在子类型构造函数的内部调用超类型构造函数（利用 call 或 apply）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承了 SuperType</span></span><br><span class="line">    SUperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以给超类型的构造函数传递参数<h3 id="组合继承（伪经典继承）"><a href="#组合继承（伪经典继承）" class="headerlink" title="组合继承（伪经典继承）"></a>组合继承（伪经典继承）</h3></li><li>最常用</li><li>组合原型链和借用构造函数</li><li>原型链实现对原型属性和方法的继承</li><li>借用构造函数实现对实例属性的继承</li><li>缺点<ul><li>调用两次超类型构造函数<ul><li>创建子类型原型</li><li>子类型构造函数内部</li></ul></li></ul></li></ul><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><ul><li><code>Object.create(作为新对象原型的对象， 作为新对象定义额外属性的对象)</code> 返回一个新对象</li></ul><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><ul><li>创建一个仅用于封装继承过程的函数，该<br>函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3></li><li>通过借用构造函数来继承属性</li><li>通过原型链的混成形式来继承方法</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 引用类型</title>
      <link href="/2020/02/22/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/02/22/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>引用类型</strong>是一种数据结构，用于将数据和功能组织在一起。</li><li>引用类型的值（对象）是引用类型的一个实例。</li><li><u>引用类型与类看起来相似，但并不相同。</u></li><li>ECMAScript 从技术上讲是一门面向对象的语言，但不具备传统的面向对象语言所支持的类和接口等基本结构。</li><li>引用类型也被称为<strong>对象定义</strong>，描述一类对象所具有的属性和方法。</li><li>ECMAScript 提供类很多原生引用类型（例如 Object）</li></ul><h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>大多数对象都是 Object 类型的实例</p><h6 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h6><ul><li>new 操作符<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure></li><li>对象字面量<ul><li>对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义只包含默认属性和方法的对象</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><blockquote><p>通过对象字面量定义对象时，实际上不会调用 Object 构造函数<br>疑问：对象字面量是怎么定义对象的？</p></blockquote></li></ul></li></ul><h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>和其他语言的区别：每一项可以保存任何类型的数据，互相之间不影响</p><h6 id="创建实例-1"><a href="#创建实例-1" class="headerlink" title="创建实例"></a>创建实例</h6><ul><li>new<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>); <span class="comment">// length = 20</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Grey"</span>); <span class="comment">// length = 1</span></span><br></pre></td></tr></table></figure></li><li>省略 new<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// length = 3</span></span><br></pre></td></tr></table></figure></li><li>数组字面量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [];</span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br></pre></td></tr></table></figure><blockquote><p>数组字面量表示法时不会调用 Array 构造函数</p></blockquote></li></ul><hr><ul><li>length 可修改，会移除超出的项</li><li>当把一个值放在超出当前数组大小的位置上时，会重新计算长度，长度值为最后一项的索引 + 1<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="comment">// ["red", "blue", "green"]</span></span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// ["red", "blue"]</span></span><br><span class="line">colors.length = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// ["red", "blue", empty]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// ["red", "blue", empty, "green"] length = 4</span></span><br></pre></td></tr></table></figure><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><code>value instanceof Array</code> 假定只有一个全局执行环境，如果从一个框架向另一个框架传入数组，就具有不同的构造函数<br><code>Array.isArray()</code><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3></li><li><code>Array.toString()</code></li><li><code>Array.toLocaleString()</code></li><li><code>Array.valueOf()</code><h3 id="栈-队列方法"><a href="#栈-队列方法" class="headerlink" title="栈/队列方法"></a>栈/队列方法</h3></li><li><code>Array.push</code> 末尾添加</li><li><code>Array.pop</code> 取最后一项并移除</li><li><code>Array.shift</code> 取第一项并移除</li><li><code>Array.unshift</code> 头部添加<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3></li><li><code>Array.reverse()</code> 反转顺序</li><li><code>Array.sort()</code> 先转 toString()，字符串升序<ul><li>sort 接收比较函数<ul><li>params1 -&gt; params2 ===&gt; -1</li><li>params2 -&gt; params1 ===&gt; 1<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3></li></ul></li></ul></li><li><code>Array.concat</code></li><li><code>Array.slice(a, b)</code> [a, b)<ul><li>负数则从末尾开始数</li></ul></li><li><code>Array.splice(a, b, ...c)</code><ul><li>a 位置</li><li>b 要删除的项数</li><li>c 插入的内容（若干）</li><li>return 被删除的内容</li></ul></li></ul><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>查找数组内容，<code>===</code>，返回下标</p><ul><li><code>Array.indexOf()</code></li><li><code>Array.lastIndexOf()</code><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3></li><li>两个参数<ul><li>要在每一项上运行的函数<ul><li>三个参数<ul><li>数组项的值</li><li>该项再数组中的位置</li><li>数组对象本身</li></ul></li></ul></li><li>（可选的）运行该函数的作用域对象<ul><li>影响this的值</li></ul></li></ul></li><li><code>Array.every()</code> 每一项都返回 true，则返回 true</li><li><code>Array.some()</code> 任一项返回 true，则返回 true</li><li><code>Array.filter()</code> 返回该函数返回 true 的项组成的数组</li><li><code>Array.map()</code> 返回每次函数调用的结果组成的数组</li><li><code>Array.forEach()</code> 没有返回值 </li></ul><p>以上方法都不回修改数组中包含的值</p><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><ul><li><p><code>Array.reduce()</code></p></li><li><p><code>Array.reduceRight()</code></p></li><li><p>两个参数</p><ul><li>每一项上调用的函数<ul><li>四个参数<ul><li>前一个值</li><li>当前值</li><li>项的索引</li><li>数组对象</li></ul></li></ul></li><li>（可选的）作为归并基础的初始值</li></ul></li><li><p>返回值作为第一个参数传给下一项</p></li><li><p>第一次迭代发生在第二项上，第一个参数是数组的第一项，第二个参数是数组的第二项</p></li></ul><h2 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h2><ul><li><code>Date.parse()</code> <ul><li>params: 表示日期字符串，格式因地区而异</li><li>return: 毫秒</li></ul></li><li><code>Date.UTC()</code><ul><li>params: 年份、月份（0开始）、天数、小时、分钟、秒、毫秒</li><li>return: 毫秒</li></ul></li><li><code>Date.now()</code><h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3></li><li><code>Date.toLocaleString()</code> 根据当地时区</li><li><code>Date.toString()</code> 带有时区信息</li><li><code>Date.valueOf()</code> 毫秒<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3></li><li><code>Date.toDateString()</code></li><li><code>Date.toTimeString()</code></li><li><code>Date.toLocaleDateString()</code></li><li><code>Date.toLocaleTimeString()</code></li><li><code>Date.toUTCString()</code></li><li><code>Date.toLocaleString()</code></li></ul><p>因浏览器而异</p><h2 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</span><br></pre></td></tr></table></figure><ul><li>pattern<ul><li>( [ { \ ^ $ | ) ? * + . ] } 需要转义</li></ul></li><li>flags<ul><li>g 全局，默认匹配第一个停止</li><li>i 不区分大小写</li><li>m 多行模式<h3 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h3></li></ul></li><li><code>global</code> </li><li><code>ignoreCase</code> </li><li><code>lastIndex</code> </li><li><code>multiline</code> </li><li><code>source</code> </li></ul><h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><ul><li><code>exec</code> </li><li><code>test</code> </li><li><code>toString</code> </li><li><code>toLocaleString</code> </li><li><code>valueOf</code> </li></ul><h3 id="构造函数属性"><a href="#构造函数属性" class="headerlink" title="构造函数属性"></a>构造函数属性</h3><p>其他语言中被看成是<strong>静态属性</strong></p><table><thead><tr><th>长属性名</th><th>短属性名</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>$_</td><td>最近一次要匹配的字符串</td></tr><tr><td>lastMatch</td><td>$&amp;</td><td>最近一次的匹配项</td></tr><tr><td>lastParen</td><td>$+</td><td>最近一次匹配的捕获组</td></tr><tr><td>leftContext</td><td>$`</td><td>input 字符串中 lastMatch 之前的文本</td></tr><tr><td>multiline</td><td>$*</td><td>布尔值，是否所有表达式都使用多行模式</td></tr><tr><td>rightContext</td><td>$’</td><td>input 字符串中 lastMatch 之后的文本</td></tr></tbody></table><h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><ul><li><p>每个函数都是 Function 类型的实例，具有属性和方法。</p></li><li><p>函数名是一个只想函数对象的指针，不会与某个函数绑定。</p><h5 id="创建实例-2"><a href="#创建实例-2" class="headerlink" title="创建实例"></a>创建实例</h5></li><li><p>函数声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>区别：<br>解析器会先读取函数声明，在执行任何代码之前可用（函数声明提升）<br>函数表达式要等解析器执行到它所在的代码行才会被解释执行</p></blockquote></li><li><p>Function 构造函数（不推荐）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>);</span><br></pre></td></tr></table></figure><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>声明两个同名函数，后面的函数覆盖前面的，结合 “函数是对象，函数名是指针” 很好理解。</p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3></li><li><p>函数名本身是变量，可以作为值来使用</p></li><li><p>可以作为参数，也可以作为返回值</p></li></ul><h3 id="函数的内部属性"><a href="#函数的内部属性" class="headerlink" title="函数的内部属性"></a>函数的内部属性</h3><ul><li><code>arguments</code> 类数组对象<ul><li><code>callee</code> 属性，该属性是一个指针，指向拥有这个 arguments 对象的函数</li></ul></li><li><code>this</code> 引用的是执行函数的环境对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sindow.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">// "red"</span></span><br><span class="line"></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();   <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure></li><li><code>caller</code> 调用当前函数的函数的引用，全局中调用当前函数则 null<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(inner.caller);</span><br><span class="line">    <span class="comment">// inner.callr 指向 outer()</span></span><br><span class="line">    <span class="comment">// 等价于 arguments.callee.caller</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3></li><li><code>length</code> 函数希望接收的命名参数的个数</li><li><code>prototype</code><ul><li>对引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，toString() 和 valueOf() 等方法都是保存在 prototype 名下，只是通过各自对象的实例访问。</li><li>不可枚举，for-in 无法发现。</li></ul></li></ul><p>每个函数都包含两个非继承而来的方法，都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。</p><ul><li><p><code>apply</code> </p><ul><li>两个参数<ul><li>在其中运行函数的作用域</li><li>参数数组</li></ul></li></ul></li><li><p><code>call</code> </p><ul><li>1 + n 个参数<ul><li>在其中运行函数的作用域</li><li>一个一个地传入参数</li></ul></li></ul></li><li><p><code>bind</code> 创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值</p></li></ul><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript 提供 3 个特殊的引用类型：<code>Boolean</code>、<code>Number</code>、<code>String</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"smoe.txt"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>基本类型不是对象，理论上不应该有方法。<br>当第二行代码访问 s1 时，访问过程处于一种读取模式，从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台自动完成：<br>(1) 创建 String 类型的一个实例<br>(2) 在实例上调用指定的方法<br>(3) 销毁这个实例</p></blockquote><ul><li>引用类型与基本包装类型的主要区别是对象的生存期<ul><li>引用类型的实例在执行流离开当前作用域之前一直保存在内存中</li><li>基本包装类型只存在于一行代码的执行瞬间</li></ul></li><li>可以显示的创建基本包装类型的对象，但会分不清自己在处理基本类型还是引用类型的值</li><li>new 调用基本包装类型的构造函数，和转型函数是不一样的<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value); <span class="comment">// 转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number); <span class="comment">// "number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);     <span class="comment">// “object"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>布尔表达式中，所有的对象都会转为 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(result); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>产生误解，建议不要使用</p><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><ul><li><code>toString(n)</code> n 进制</li><li><code>toFixed(n)</code> 四舍五入 n 位小数</li><li><code>toExponential(n)</code> n 位数表示一个数字</li></ul><h4 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h4><ul><li><code>charAt</code></li><li><code>charCodeAt</code></li><li><code>方括号表示法[]下标读取字符</code></li></ul><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><ul><li><code>concat</code> 拼接字符串，常用<code>+</code></li><li><code>slice</code></li><li><code>substr</code></li><li><code>substring</code></li></ul><h4 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h4><ul><li><code>indexOf</code></li><li><code>lastIndexOf</code></li></ul><h4 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim() 方法"></a>trim() 方法</h4><p>创建一个字符串的副本，删除前置以及后缀的所有空格，然后返回结果</p><h4 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h4><ul><li><code>toLowerCase</code></li><li><code>toLocaleLowerCase</code></li><li><code>toUpperCase</code></li><li><code>toLocaleUpperCase</code></li></ul><h4 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h4><ul><li><code>match</code><ul><li>params:正则表达式或 RegExp 对象</li><li>本质调用 RegExp 的 exec</li></ul></li><li><code>search</code><ul><li>params:正则表达式或 RegExp 对象</li><li>return: 下标，找不到 -1</li></ul></li><li><code>replace</code> <ul><li>两个参数，用第二个参数替换第一个</li><li>第一个参数可以是正则</li><li>第二个参数可以是函数</li></ul></li><li><code>split</code> 基于一个制定的分隔符，将一个字符串分割成多个子字符串</li></ul><h4 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare() 方法"></a>localeCompare() 方法</h4><p>比较两个字符串，各地区实现不同</p><h4 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode() 方法"></a>fromCharCode() 方法</h4><p>接收一个或多个字符编码，然后转换成一个字符串</p><h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>ECMA-262对<strong>单体内置对象</strong>的定义：<u>由 ECMAScript 实现提供的，不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。</u></p><p>前面已经介绍了大多数内置对象，如 Object、Array、String</p><h3 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h3><ul><li>不属于任何其他对象的属性和方法，最终都是 Global 对象的属性和方法</li><li>事实上，没有全局变量或全局函数。所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。如<ul><li>isNan()、isFinite()、parseint()</li><li>encodeURI() 用于整个 URI<br>encodeURIEomponent() 用于 URI 中的一段<br>decodeURI()<br>decodeURIEomponent()</li><li>eval() 像一个完整的 ECMAScript 解析器<ul><li>params: 要执行的 ECMAScript 字符串</li></ul></li><li>Global 对象属性<ul><li>undefined、NaN、Infinity 等</li><li>Object、Function 等</li></ul></li><li>window 对象<ul><li>Web 浏览器中，Global 对象是 window 对象的一部分</li></ul></li></ul></li></ul><h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><ul><li>Math 对象的属性<ul><li>Math.E</li><li>Math.LN10</li><li>Math.LN2</li><li>Math.LOG2E</li><li>Math.LOG10</li><li>Math.PI</li><li>Math.SQRT1_2</li><li>Math.SQRT2</li></ul></li><li>min()、max()</li><li>舍入方法<ul><li>Math.ceil() 向上舍入</li><li>Math.floor() 向下舍入</li><li>Math.round() 四舍五入</li></ul></li><li>random() [0, 1) 随机数</li><li>其他方法<ul><li>Math.abs(num)</li><li>Math.exp(num)</li><li>Math.log(num)</li><li>Math.pow(num, power)</li><li>Math.sqrt(num)</li><li>Math.acos(x)</li><li>……</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 变量、作用域和内存问题</title>
      <link href="/2020/02/17/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/17/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><ul><li>基本数据类型（5）按值访问，可以操作保存在变量中的实际的值。占据固定大小的空间，被保存在栈内存中。</li><li>引用类型（1）的值是保存在内存中的对象，保存在堆内存中。JS 不能直接操作对象的内存空间：复制保存对象的某个变量时，操作对象的引用；为对象添加属性时，操作的是实际的对象。</li></ul><h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><ul><li>基本类型：创建新值</li><li>引用类型：创建新值，值是指针，实际与旧值引用同一个对象</li></ul><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript 中所有函数的参数都是按值传递的。</p><ul><li>基本类型：被传递的值会被复制给一个局部变量。</li><li>引用类型：被传递的值的<strong>地址</strong>复制给一个局部变量。因此这个局部变量的变化会反应在函数的外部。<blockquote><p>若在函数体内对这个局部变量进行重新赋值，那么保存的地址就改变了，指向的内存也不再是被传入的对象。</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//“Nicholas”</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = <span class="string">"Greg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//“Nicholas”</span></span><br></pre></td></tr></table></figure><p>在内部重写 obj 时，变量引用的就是一个局部对象了。局部对象在函数执行完毕后立即被销毁。</p><h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><ul><li>基本类型：<code>typeof</code></li><li>引用类型：<code>instanceof</code></li><li>根据<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result = variable instanceof constructor</span></span><br><span class="line"><span class="comment">// 根据原型链来识别</span></span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>);</span><br></pre></td></tr></table></figure>所有引用类型的值都是 Object 的实例。<code>Obj instanceof Object</code> 始终返回 true，检测基本类型始终 false，因为基本类型不是对象。</li></ul><h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><ul><li>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</li><li>每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的所有变量和函数都保存在这个对象中。</li><li><strong>全局执行环境</strong>：根据宿主环境。WEB 浏览器中是 window 对象。</li><li><strong>执行环境</strong>，函数的环境，保存在栈中。</li><li>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，<u>保证对执行环境有权访问的所有变量和函数的有序访问。</u><blockquote><p>作用域链的前端，始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>作为变量对象。活动对象在最开始时只包含一个变量（即arguments对象，全局环境中不存在）。下一个变量对象来自包含（外部）环境……一直到全局执行环境。<br>标识符解析是沿着作用域链一级一级地搜索标识符的过程。<br>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境重的变量和函数。</p></blockquote></li></ul><h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><ul><li>try-catch 语句的 catch 块</li><li>with 语句<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</span><br><span class="line">    <span class="keyword">with</span> (location) &#123;</span><br><span class="line">        <span class="keyword">var</span> url = href + qs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>with 语句接收 location 对象，因此其变量对象中包含了 location 对象的所有属性和方法，而这个变量被添加到了作用域链的前端。<blockquote><p>疑问：<br>作用域链：全局执行环境-&gt;buildUrl()-&gt;with(location)<br>with 中定义的变量 url 为什么能够在外部环境 buildUrl 中访问？url是被定义在全局执行环境中的 location 变量对象中吗？</p><hr><p>因为没有块级作用域，变量声明会被添加到当前的执行环境（这里是buildUrl（））中</p></blockquote></li></ul><h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(color);</span><br></pre></td></tr></table></figure><p>js 中，if 语句中的变量声明会将变量添加到当前的执行环境（这里是全局环境）<br>如果没有用 var 声明，会直接被添加到全局环境。</p><blockquote><p>let 似乎解决了这个问题，本书没有讲到，看完 es6 再来补。</p></blockquote><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><ul><li>当变量进入环境，标记为“进入环境”。<ul><li>逻辑上讲，永远不能释放进入环境的变量所占用的内存。</li></ul></li><li>当变量离开环境时，则标记“离开环境”。</li><li>可以使用任何方式来标记变量。如：<ul><li>翻转某个特殊的位</li><li>“进入环境”变量列表及“离开环境”变量列表<blockquote><p>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后再被加上标记的变量将被视为准备删除的变量。最后完成内存清除工作，销毁值并回收内存空间。</p></blockquote></li></ul></li></ul><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>跟踪记录每个值被引用的次数，赋值给变量则该值+1，若变量取得另一个值，则该值-1。</p><blockquote><p>垃圾收集器下次运行时，释放计数 0 的值占用的内存。</p></blockquote><blockquote><p>循环引用会导致引用次数永远不为 0<br>BOM 和 DOM 中的对象是使用 C++ 以 COM（Component Object Model，组件对象模型）对象的形式实现的，COM 对象的垃圾收集机制就是引用计数策略。<br>解决：手动断开循环引用（赋值为null）</p></blockquote><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>垃圾收集器是周期运行的，如果为变量分配的内存数量很大，那么回收工作量也相当大，确定时间间隔很重要。</p><h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>使用具备垃圾收集机制的语言编写程序，一般不必操心内存管理。但 js 比较特殊，因为分配给 Web 浏览器的可用内存通常比桌面应用少。<br>尽量少用内存页面会有更好的性能。一旦数据不再有用，赋值 null 来<strong>解除引用</strong>。适用于大多数全局变量和全局对象的属性，局部变量会在离开执行环境时自动解除。<br>解除引用不是自动回收内存，是让值脱离环境，垃圾收集器下次运行的时候将其回收。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 基本概念</title>
      <link href="/2020/02/15/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/02/15/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>ECMAScript 标示符采用驼峰大小写格式</p><h3 id="严格模式-strict-mode"><a href="#严格模式-strict-mode" class="headerlink" title="严格模式 strict mode"></a>严格模式 strict mode</h3><p>在顶部添加代码 <code>&quot;use strict&quot;;</code><br>编译指示(pragma)，用于告诉支持的 JavaScript 引擎切换到严格模式。<br>函数体中包含指定函数在严格模式下执行。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>松散类型：可以用来保存任何类型的数据。每个变量仅仅用于保存值的占位符。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>5 基本数据类型 - <code>Undefined、Null、Boolean、Number、String</code><br>1 复杂数据类型 - <code>Object</code><br><code>Oobject</code> 本质上是由一组无序的名值对组成的<br>ECMAScript 不支持任何创建自定义类型的机制</p><p><code>typeof</code> 操作符，返回值（均为字符串）<br>未定义：<code>&quot;undefined&quot;</code><br>布尔值：<code>&quot;boolean&quot;</code><br>字符串：<code>&quot;string&quot;</code><br>数值：<code>&quot;number&quot;</code><br>对象或<code>null</code>：<code>&quot;object&quot;</code><br>函数：<code>&quot;function&quot;</code><br>特殊值 <code>null</code> 被认为是一个空的对象引用，因此返回 <code>&quot;object&quot;</code>。<br>safari 5 和 Chrome 7 及之前版本 <code>typeof 正则表达式</code> 会返回 <code>&quot;function&quot;</code>，而其他浏览器返回<code>&quot;object&quot;</code></p><blockquote><p>从技术角度讲，函数在 ECMAScript 中是对象，而不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 <code>typeof</code> 操作符区分函数和其他对象是有必要的。</p></blockquote><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h3><p><code>Undefined</code> 类型只有一个值，即 <code>undefined</code></p><blockquote><p>变量已声明但未初始化（message）：该变量的值为 <code>undefined</code>,<code>typeof</code> 返回<code>&quot;undefined&quot;</code><br>若变量未声明（age）：只可以执行<code>typeof</code> 操作符，返回<code>&quot;undefined&quot;</code>，其他操作产生错误。</p><p> <img src="/.com//%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="变量初始化"></p></blockquote><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h3><p><code>Null</code> 类型只有一个值，即 <code>null</code>，表示一个空对象指针，因此 <code>typeof null</code> 返回 <code>&quot;object&quot;</code>。<br>如果定义的变量准备用于保存对象，那么最好初始化为 <code>null</code>，可以直接判断是否已经保存了一个对象的引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>) &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，<code>undefined</code> 派生自 <code>null</code>，因此：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>); </span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><p>ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。调用 <code>转型函数 Boolean()</code> 获得对应 Boolean 值。</p><table><thead><tr><th>数据类型</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>任何非空字符串</td><td>“”（空字符串）</td></tr><tr><td>Number</td><td>任何非零数字值（包括无穷大）</td><td>0 和 NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>N/A</td><td>undefined</td></tr><tr><td>N/A：not applicable 的缩写，不适用</td><td></td><td></td></tr></tbody></table><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>使用 <a href="https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin" target="_blank" rel="noopener">IEEE754</a> 格式来表示整数和浮点数值（双精度数值）。<br>为了支持各种数值类型，ECMA-262定义了不同的数值字面量格式。</p><ul><li>十进制</li><li>八进制（0）</li><li>十六进制（0x）<br>在进行算数计算时，都会转为十进制数值。<h5 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h5>浮点数值需要的内存空间是整数值的两倍。<br>6 个 0 以上，e表示法：3.125e7、3e-17<br>浮点数值最高精度 17 位小数，但在算数计算时精度远不如整数。<img src="/.com//%E7%B2%BE%E5%BA%A6.png" alt="精度"><br>（IEEE745 数值的浮点计算通病，不是 ECMAScript 独有）</li></ul><h5 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h5><p><code>Number.MIN_VALUE</code> 5e-324<br><code>Number.MAX_VALUE</code> 1.7976931348623157e+308<br><code>Number.POSITIVE_INFINITY</code> 或 <code>Infinity</code> 正无穷<br><code>Number.NEGATIVE_INFINITY</code> 或 <code>-Infinity</code> 负无穷<br><code>isFinite()</code>有穷返回 <code>true</code></p><h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><ul><li>任何涉及 NaN 的操作都会返回 NaN</li><li>NaN 与任何值都不相等，包括自己本身</li><li><code>isNaN()</code> 函数判断变量是否<strong>可以转为数值</strong></li></ul><blockquote><p>isNaN(object):<br>首先调用对象的 valueOf() 方法，检查该方法的返回值是否可以转换为数值<br>如果不能，基于这个返回值再调用 toString() 方法，再测试返回值。</p></blockquote><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><p><code>Number()</code> 任何类型<br><code>parseInt()</code> 字符串<br><code>parseFloat()</code> 字符串</p><blockquote><p>parseInt 和 parseFloat 从第一个符合条件的字符开始转换，开始后若碰到不符合的字符，抛弃之后的字符。</p></blockquote><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><ul><li>Unicode 字符组成的字符序列。</li><li>ECMAScript 中双引号/单引号没有区别。</li></ul><h5 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h5><p>字符字面量，即转义字符，被作为一个字符来解析。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>不可改变<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">"Java"</span>;</span><br><span class="line">lang = lang + <span class="string">"Script"</span>;</span><br><span class="line"><span class="comment">// 首先创建一个能容纳 10 个字符的新字符串，然后填充 “Java” 和 “Script”，最后销毁原来的字符串。（不在原字符串上修改）</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="转为字符串"><a href="#转为字符串" class="headerlink" title="转为字符串"></a>转为字符串</h5><ul><li><p><code>toString()</code> 几乎每个值都有这个方法，<code>null</code> 和 <code>undefined</code> 值没有。</p><ul><li>通常不需要参数。</li><li>调用数值的 <code>toString()</code> 方法时可以传递进制基数作为参数。</li></ul></li><li><p>不知道是不是 <code>null</code> 或 <code>undefined</code> 的时候可以使用转型函数 <code>String()</code></p><ul><li>如果值有 <code>toString()</code> 方法，调用</li><li>如果值是 <code>null</code>，返回 <code>&quot;null&quot;</code></li><li>如果值是 <code>undefined</code>，返回 <code>&quot;undefined&quot;</code></li></ul></li><li><p><code>obj + &quot;&quot;</code> 和字符串加在一起</p></li></ul><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><ul><li>对象是一组数据和功能的集合。<blockquote><p>在 ECMAScript 中，<code>Object</code> 类型所具有的任何属性和方法也同样存在于更具体的对象中。<br><code>Object</code> 的每个实例都具有下列属性和方法。</p></blockquote></li><li><code>Constructor</code> 构造函数</li><li><code>hasOwnProperty(propertyName)</code> 检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。参数（propertyName）为字符串</li><li><code>isProtorypeOf(object)</code> 检查传入的对象是否是另一个对象的原型</li><li><code>propertyIsEnumerable(propertyName)</code> 检查给定的属性是否能够使用 for-in 语句。参数（propertyName）为字符串</li><li><code>toLocaleString()</code> 根据本地规范进行格式化</li><li><code>toString()</code> </li><li><code>valueOf()</code> 通常自动调用</li></ul><blockquote><p>从技术角度讲，ECMA-262 中对象的行为不一定适用于 JS 中的其他对象。如 BOM 和 DOM 中的对象属于宿主对象，宿主对象可能会也可能不会继承 Object。</p></blockquote><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符应用于对象时，通常会调用对象的 <code>valueOf()</code> 和（或）<code>toString()</code> 方法。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>枚举对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性没有顺序，所以先后顺序因浏览器而异。</p><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>类似 go to 不建议使用</p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>简化多次编写同一个对象的工作<br>大量使用 with 会导致性能下降，不建议使用</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>比较值时使用全等 <code>===</code></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>未指定返回值的函数返回 <code>undefined</code></p><blockquote><p>函数要么始终返回一个值，要么永远都不要返回值。</p></blockquote><h3 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h3><ul><li>函数体内通过 arguments 对象来访问参数数组。</li><li>ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。<blockquote><p>详看第四章 —— 传递参数</p></blockquote></li></ul><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>不存在函数签名的特性，ECMAScript 函数不能重载<br>定义两个名字相同的函数，会被后面定义的函数覆盖</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 在 HTML 中使用 JavaScript</title>
      <link href="/2020/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8%20HTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20JavaScript/"/>
      <url>/2020/02/09/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9C%A8%20HTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20JavaScript/</url>
      
        <content type="html"><![CDATA[<h2 id="script元素"><a href="#script元素" class="headerlink" title="script元素"></a><code>script</code>元素</h2><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li><p>src 可选。包含要执行代码的外部文件。</p><blockquote><p>如果有 src，标签内嵌入的 JavaScript 代码会被忽略<br>可以包含来自外部域的 JavaScript 文件。这点与 <code>img</code> 相同</p></blockquote></li><li><p>async 可选。立即下载脚本，但不妨碍页面中其他操作。只对外部脚本文件有效。<strong>不能保证按顺序执行。不要修改 DOM 会在load 事件前执行，可能会在 <code>DOMContentLoaded</code> 事件触发之前或之后执行。</strong></p></li><li><p>defer 可选。延迟到文档完全被解析和显示之后（<code>/html</code>标签后）执行。<strong>只对外部脚本文件有效。</strong>（嵌入脚本的 defer 属性会被忽略）<strong>延迟脚本不一定会按照顺序执行，也不一定会在 <code>DOMContentLoaded</code> 事件触发前执行，因此最好只有一个延迟脚本。</strong></p><blockquote><p>只要不存在 defer 和 async 属性，浏览器都会按照 <code>scrip</code> 元素在页面中出现的先后顺序进行解析</p></blockquote></li></ul><ul><li>type 可选。language（已废弃）的替代属性；脚本语言的内容类型（MIME 类型）。默认值 text/javascript<blockquote><p>不推荐 text/javascript 和 text/ecmascript<br>服务器在传送 JavaScript 文件时使用的 MIME 类型通常是 application/x-javascript<br>非 IE 浏览器中可以使用 application/javascript 和 application/ecmascript</p></blockquote></li><li>charset 可选。表示通过 src 属性指定代码的字符集。大多数浏览器忽略</li></ul><h3 id="标签的位置"><a href="#标签的位置" class="headerlink" title="标签的位置"></a>标签的位置</h3><p>放在 <code>head</code> 中必须先把 js 代码下载、解析和执行完成后才能开始呈现页面内容，此时页面空白。<br>把 js 引用放在 <code>body</code> 中，空白时间会缩短。<br>或者设置 defer 属性，立即下载，延迟（<code>/html</code>标签后）执行。</p><h2 id="外部文件的优点"><a href="#外部文件的优点" class="headerlink" title="外部文件的优点"></a>外部文件的优点</h2><ul><li>可维护性：集中精力编辑 js 代码</li><li>可缓存：如果两个页面使用同一个文件，只需下载一次</li><li>适应未来</li></ul><h2 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h2><p><code>!DOCTYPE html</code></p><h2 id="noscript元素"><a href="#noscript元素" class="headerlink" title="noscript元素"></a><code>noscript</code>元素</h2><ul><li>浏览器不支持脚本</li><li>浏览器支持脚本，但脚本被禁用<br>符合上述条件，元素内容会被显示。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 JavaScript 简介</title>
      <link href="/2020/01/16/%E7%AC%AC%E4%B8%80%E7%AB%A0-JavaScript%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/01/16/%E7%AC%AC%E4%B8%80%E7%AB%A0-JavaScript%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>ECMA-262——定义一种名为 ECMAScript 的新脚本语言的标准<br>浏览器开发商将 ECMAScript 作为各自 JavaScript 实现的基础</p><blockquote><p>JavaScript 包括：</p><ul><li>核心： ECMAScript</li><li>文档对象模型： DOM</li><li>浏览器对象模型： BOM</li></ul></blockquote><h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><ul><li>没有输入和输出定义</li><li>ECMA-262 定义了 ECMAScript 基础，在此基础上可以构建更完善的脚本语言</li><li>宿主环境提供基本的 ECMAScript 实现，也提供该语言的拓展，以便语言和环境之间对接交互</li></ul><p>ECMA-262 标准规定了</p><ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>对象<br>ECMAScript 就是对实现该标准规定的各个方面内容的语言的描述<br>JavaScript 实现了 ECMAScript<br>Adobe ActionScript 也实现了 ECMAScript<h6 id="什么是-ECMAScript-兼容"><a href="#什么是-ECMAScript-兼容" class="headerlink" title="什么是 ECMAScript 兼容"></a>什么是 ECMAScript 兼容</h6><blockquote><p>要想成为 ECMAScript 的实现，必须做到：</p><ul><li>支持 ECMA-262 描述的所有“类型、值、对象、属性、函数以及程序语法和语义”</li><li>支持 Unicode 字符标准</li><li>可以进行拓展：<ul><li>添加 ECMA-262 没有描述的“更多类型、值、对象、属性和函数”。主要指新对象和对象的新属性</li><li>支持 ECMA-262 没有定义的“程序和正则表达式语法”。即可以修改和拓展内置的正则表达式语法</li></ul></li></ul><p>为开发人员基于 ECMAScript 开发一门新语言提供了广阔的空间和极大的灵活性</p></blockquote></li></ul><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>DOM（Document Object Model）是针对 XML 但经过拓展用于 HTML 的 API（Application Programming Interface）</p><ul><li>W3C 制定了 DOM 标准</li><li>DOM 不止针对 JavaScript，很多别的语言也实现了 DOM</li><li>DOM 包括 DOM 核心和 DOM HTML<ul><li>DOM 核心规定如何映射基于 XML 的文档结构</li><li>DOM HTML 模块则在 DOM 核心 的基础上添加了针对 HTML 的对象和方法</li></ul></li></ul><p>除了 DOM 核心和 DOMHTML 接口之外，另外几种语言发布了只针对自己的 DOM 标准。以下语言都是基于 XML 的，每种语言的 DOM 标准都添加了与特定语言相关的新方法和新接口：</p><ul><li>SVG(Scalable Vector Graphic)</li><li>MathML（Mathematical Markup Language）</li><li>SMIL（Synchronized Multimedia Integration Language）<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3>开发人员使用 BOM（Browser Object Model）控制浏览器显示的页面以外的部分<br>BOM 作为 JavaScript 实现的一部分却没有相关的标准。H5 致力于把很多 BOM 功能写入正式规范。<br>根本上讲，BOM 只处理浏览器窗口和框架；但习惯上把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript高级程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
