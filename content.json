{"meta":{"title":"life kicks in right now","subtitle":"life kicks in right now","description":"","author":"ziiyan","url":"http://ziiyan.github.io","root":"/"},"pages":[{"title":"About","date":"2020-02-29T17:00:22.000Z","updated":"2020-02-29T17:07:08.458Z","comments":true,"path":"about/index.html","permalink":"http://ziiyan.github.io/about/index.html","excerpt":"","text":"因上努力，果上随缘"},{"title":"Tags","date":"2020-02-29T17:11:52.306Z","updated":"2020-02-29T17:01:01.709Z","comments":true,"path":"tags/index.html","permalink":"http://ziiyan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面试准备：水平垂直居中","slug":"面试准备：水平垂直居中","date":"2020-08-05T09:06:52.000Z","updated":"2020-08-05T15:40:50.125Z","comments":true,"path":"2020/08/05/面试准备：水平垂直居中/","link":"","permalink":"http://ziiyan.github.io/2020/08/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9A%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/","excerpt":"","text":"123&lt;div class=\"container\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; 1、水平居中1.1、行内元素 缺点：为了居中元素，使文本也居中了，因此可能需要重置文本位置。 优点：不需要固定居中元素的宽。 1234567.container &#123; text-align: center;&#125;.item &#123; display: inline-block; text-align: left; /* if need initial text position */&#125; 该方案的原理是：上面代码中的 text-align: center; 会使文本居中，但是对块级元素无效，如果将元素设置为 inline-block，该元素就会被当做文本对待，从而实现元素居中。 1.2、块级元素1.2.1、margin123.item &#123; margin: 0 auto;&#125; 该方案的原理是：元素被设置成块级后，会独占一行，如果其宽度没有占满横向空间，那么剩余的空间就处于待分配状态，此时设置 margin: auto; 意味着把剩余的空间分配给 margin，并且左右均分，所以就实现了水平居中。 1.2.2、flex1234.container &#123; display: flex; justify-content: center;&#125; 1.2.3、绝对定位1.2.3.1、transform12345678.container &#123; position: relative;&#125;.item &#123; position: absolute; left: 50%; transform: translateX(-50%);&#125; 1.2.3.2、margin-left12345678.container &#123; position: relative;&#125;.item &#123; position: absolute; left: 50%; margin-left: -0.5 * 元素item的宽度;&#125; 2、垂直居中2.1、行内元素123456.container &#123; height: 高度;&#125;.item &#123; line-height: 高度;&#125; 单行文本 元素的 height 和 line-height 相同的时候，会使其文本内容垂直居中。因此该方案利用了这一特点，不过文本内容虽然垂直居中了，但是元素并没有，因此再将元素设置为 inline-block，这样元素就会被当做文本对待了。同时由于具有了 inline 属性，vertical-align: middle; 也就可以生效了。 2.2、块级元素2.2.1、flex1234.container &#123; display: flex; align-items: center;&#125; 2.2.2、绝对定位2.2.2.1、transform12345.item &#123; position: absolute; top: 50%; transform: translateY(0, -50%);&#125; 2.2.2.2、margin-top12345678.container &#123; position: relative;&#125;.item &#123; position: absolute; left: 50%; margin-top: -0.5 * 元素item的高度;&#125; 3、水平垂直居中3.1、Flex 优点：不需要固定居中元素的宽高 12345.container &#123; display: flex; justify-content: center; /* 水平居中 */ align-items: center; /* 垂直居中 */&#125; 123456.container &#123; display: flex;&#125;.item &#123; margin: auto;&#125; 3.2、Grid 优点：不需要固定居中元素的宽高。 缺点：兼容性不如 flex 123456.container &#123; display: grid;&#125;.item &#123; margin: auto;&#125; 3.3、绝对定位3.3.1、transform 优点：不需要固定居中元素的宽高 123456789.container &#123; position: relative;&#125;.item &#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; 3.3.2、负 margin 缺点：不需要固定居中元素的宽高 12345678910.container &#123; position: relative;&#125;.item &#123; position: absolute; left: 50%; top: 50%; margin-left: -0.5 * 宽度; margin-top: -0.5 * 高度;&#125; 3.3.3、calc 缺点：需要固定居中元素的宽高 12345678.container &#123; position: relative;&#125;.item &#123; position: absolute; left: calc(50% - 0.5 * 宽度); top: calc(50% - 0.5 * 高度);&#125; 3.3.4、margin: auto1234567891011.container &#123; position: relative;&#125;.item &#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto;&#125; 该方案的原理是：使用了 CSS 中的定位属性（absolute、fixed 等）后，如果 left 设置了具体值，没有设置 right 和 width，那么就会自动计算，把剩余的空间分配给 right 和 width。如果 left、right 和 width 都设置了具体值，并且没有占满横向空间，那么剩余空间就处于待分配状态，此时设置 margin: auto; 意味着把剩余的空间分配给 margin，并且左右均分，所以就实现了水平居中，垂直方向同理。 但是要知道该方法的副作用： left: 0; right: 0; 相当于 width: 100%; top: 0; bottom: 0; 相当于 height: 100%; 缺点：需要固定居中元素的宽高，否则其宽高会被设为 100%（副作用）。 reference 一起搞懂 CSS 水平居中与垂直居中的16个方法 CSS 拷问：水平垂直居中方法你会几种？","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ziiyan.github.io/tags/CSS/"},{"name":"面试","slug":"面试","permalink":"http://ziiyan.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试准备：数组","slug":"面试准备：数组去重","date":"2020-08-05T06:10:37.000Z","updated":"2020-08-05T07:31:48.902Z","comments":true,"path":"2020/08/05/面试准备：数组去重/","link":"","permalink":"http://ziiyan.github.io/2020/08/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9A%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","excerpt":"","text":"1、数组去重 最笨的办法双层 for 循环 先排序，相邻比较 1.1、indexOf 1arr.indexOf(searchElement[, fromIndex]) indexOf()方法返回在数组中可以找到一个给定元素的第一个索引 如果不存在，则返回 -1 123456789function unique(arr) &#123; let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (result.indexOf(arr[i]) === -1) &#123; result.push(arr[i]); &#125; &#125; return result;&#125; 1.2、includes123456789function unique(arr) &#123; let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (!result.includes(arr[i])) &#123; result.push(arr[i]) &#125; &#125; return result;&#125; 1.3、reduce12345function unique(arr) &#123; return arr.reduce(function(pre, cur) &#123; return pre.includes(cur) ? pre : [...pre, cur] &#125;, [])&#125; 1.4、Map1234567891011function unique(arr) &#123; let result = []; let map = new Map(); for (let i = 0; i &lt; arr.length; i++) &#123; if (!map.has(arr[i])) &#123; map.set(arr[i]); result.push(arr[i]); &#125; &#125; return result;&#125; 1.5、Set1234function unique(arr) &#123; return [...new Set(arr)]; // Array.from(new Set(arr))&#125; 为什么要搭配扩展运算符和 Array.from？ Set 返回的是一个类数组对象 什么是类数组对象？ 可以通过索引属性访问元素并且拥有 length 属性的对象 区别：类数组对象不能直接使用数组的方法 可以通过 Function.call 或者 Function.apply 方法来间接调用 例如 Array.prototype.push.call() arguments document.getElementsXXX() 2、判断数组 方法 描述 arr instanceof Array 检测构造函数的 prototype 是否出现在对象的原型链中 Array.isArray(arr) Object.prototype.toString.call(arr)===”[object Array]” 对象都有内部属性 [[Class]] 表示对象的分类，无法直接访问，通过 Object.prototype.toString()访问，但一般 toString 都被重写了，所以需要 call arr.constructor === Array","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ziiyan.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"http://ziiyan.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"学习笔记：Flex 布局","slug":"学习笔记：Flex布局","date":"2020-08-02T02:00:03.000Z","updated":"2020-08-03T07:10:15.707Z","comments":true,"path":"2020/08/02/学习笔记：Flex布局/","link":"","permalink":"http://ziiyan.github.io/2020/08/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AFlex%E5%B8%83%E5%B1%80/","excerpt":"","text":"1、Flex 布局123.box &#123; display: flex;&#125; 行内元素 123.box &#123; display: inline-flex;&#125; 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效 2、基本概念 容器（flex container） 设置 flex 布局的元素 项目（flex item） 容器的直接子元素 主轴（main axis）：默认沿主轴排列 开始位置（main start） 结束位置（main end） 交叉轴（cross axis） 开始位置（across start） 结束位置（across end） 单个项目占据主轴的空间（main size） 单个项目占据交叉轴的空间（cross size） 3、容器的属性 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1、flex-direction flex-direction 决定主轴的方向 row （默认）水平，左 -&gt; 右 row-reverse 水平，左 &lt;- 右 column 垂直，上 -&gt; 下 column-reverse 垂直，上 &lt;- 下 3.2、 flex-wrap flex-wrap 如果一条轴线排不下，如何换行 nowrap （默认）不换行 wrap 换行，第一行在上方 wrap-reverse 换行，第一行在下方 3.3、flex-flow flex-flow 是 flex-direction 和 flex-wrap 的简写 flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt; 3.4、justify-content justify-content 项目在主轴上的对齐方式 flex-start （默认）左对齐 flex-end 右对齐 center 居中 space-between 两端对齐，项目间隔相等 space-around 每个项目两侧间隔相等（项目之间的间距是项目与边框间距的两倍） 3.5、align-item align-item 项目在交叉轴上的对齐方式 flex-start 起点对齐 flex-end 终点对齐 center 居中 baseline 项目第一行文字的基线对齐 stretch （默认）项目未设置高度或高度 auto，占满整个容器高度 3.6、align-content align-content （如果有多根主轴）多根主轴的对齐方式，只有一根不起作用 flex-start 与交叉轴的起点对齐 flex-end 与交叉轴的终点对齐 center 与交叉轴的中点对齐 space-between 与交叉轴两端对齐，轴线之间的间隔平均分布 space-around 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍 stretch 轴线占满整个交叉轴 4、项目的属性 order flex-grow flex-shrink flex-basis flex align-self 4.1、order order 项目排列顺序，默认 0，数值越小越靠前 order: &lt;integer&gt; 4.2、flex-grow flex-grow 项目方大比例，默认 0，即不放大 flex-grow: &lt;number&gt; 4.3、flex-shrink flex-shrink 项目方大比例，默认 1，即缩小 flex-shrink: &lt;number&gt; 4.4、flex-basis flex-basis 项目占据的默认主轴空间，即放大或缩小之前项目占据的空间，浏览器根据这个属性计算主轴是否有多余空间，默认 auto flex-basis: &lt;length&gt; | auto 4.5、flex flex属性是flex-grow, flex-shrink 和 flex-basis的简写 flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt; auto (1 1 auto) none (0 0 auto) 4.6、align-self align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items，默认值为auto，表示继承父元素的align-items属性 auto flex-start flex-end center baseline stretch 5、实战5.1、骰子布局垂直居中123&lt;div class=\"box\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; 12345.box &#123; display: flex; justify-content: center; align-items: center;&#125; 5.2、网格布局5.3、圣杯布局5.4、输入框的布局5.5、悬挂式布局5.7、流式布局reference Flex 布局教程：语法篇 Flex 布局教程：实例篇","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ziiyan.github.io/tags/CSS/"}]},{"title":"学习笔记：CSS布局学习指南","slug":"学习笔记：CSS布局学习指南","date":"2020-07-31T02:01:37.000Z","updated":"2020-08-01T16:14:55.360Z","comments":true,"path":"2020/07/31/学习笔记：CSS布局学习指南/","link":"","permalink":"http://ziiyan.github.io/2020/07/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ACSS%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/","excerpt":"","text":"1、正常文档流（Normal Flow） 没有用任何CSS来改变页面布局的网页 在正常流中，元素盒子（boxes）会基于文档的写作模式（writing mode）一个接一个地排列 1.1、通过页面结构来发挥正常文档流的优势 CSS加载失败了，用户仍然能阅读你的页面内容 阅读器会按照元素在文档中的位置来读取页面内容 内容顺序和用户预期的阅读顺序一致则不必布局 思考如何布局之前需要认真思考文档结构 1.2、脱离正常文档流 一旦你有了一个结构良好的页面，你就需要去决定如何利用它并将它变为我们需要的布局结构 2、浮动（Float） 浮动被用来将盒子（box）置于左侧或右侧，同时让内容环绕其展示 2.1、清除浮动 一旦你对一个元素应用了浮动，所有接下来的元素都会环绕它直到内容处于它下方且开始应用正常文档流 当你不想要某个元素受到其之前的浮动元素影响时，为其添加clear属性即可 最常见的清除浮动的hack方案是：在容器内添加一个CSS伪元素，并将其clear属性设置为both 12345.container::after &#123; content: \"\"; display: table; clear: both;&#125; 2.2、块级格式上下文（Block Formatting Context） 清除浮动的另一个方法是在容器内创建BFC 一个BFC元素完全包裹住了它内部的所有元素，包括内部的浮动元素，保证浮动元素不会超出其底部 创建BFC的方式有很多种，其中最常用的一种清除浮动的方式是为元素设置除visible（默认）之外的overflow属性值 123.container &#123; overflow: auto;&#125; 副作用：滚动条 为了使清除浮动的意图更加直观，并且避免BFC的负面影响，你可以使用flow-root作为display属性的值 123.container &#123; display: flow-root;&#125; 2.3、浮动的一些遗留用法 在新的布局方式出现以前，float经常会被用来创建多栏布局 不建议再使用 3、定位（position） 当处于正常文档流时，元素的position属性为static 当改变元素的position属性时，通常情况下也会设置一些偏移量（top / left / bottom / right）来使元素相对于参照点进行一定的移动 不同的position值会产生不同的参照点 3.1、相对定位（relative） 参照位：元素在正常文档流中的位置 保留正常文档流中的位置 3.2、绝对定位（absolute） 参照位：position 不为 static 的父元素 从正常文档流中移除 3.3、固定定位（fixed） 参照位：视口 从正常文档流中移除 3.4、粘性定位（sticky） 让元素在页面滚动时如同在正常流中，但当其滚动到相对于视口的某个特定位置时就会固定在屏幕上，如同fixed一般 导航 菜单 比较新，有兼容性问题 4、弹性布局（Flex Layout） 一维布局（按行或者列） 使用display: flex来将元素变为弹性布局 直接子元素会变为弹性项（flex item），并按行排列 4.1、弹性盒子的轴（axis） 主轴：通过设置 flex-direction 属性 row (默认) column 交叉轴：与主轴垂直 4.2、方向和次序 通过设置flex-direction 属性来改变主轴方向 row-reverse column-reverse 也可以通过设置 order 属性，改变某一个弹性项的顺序 4.3. 一些Flex的属性 控制弹性项在主轴上空间大小 flex-grow：如果为正数，允许拉伸，值越大拉伸比例越大 flex-shrink：如果为正数，元素溢出容器时会进行收缩，值越大压缩越多 flex-basis：为弹性项设置初始大小 大多数情况下容器元素大小不会正好被分为许多初始大小的项，而是可能有一些不足或剩余空间。flex-grow和flow-shrink属性允许我们在容器大小不足或有空余时控制各个弹性项的大小 简写 flex: [flex-grow] [flex-shrink] [flex-basis] 5、网格布局（Grid Layout） 二维布局（按行和列） grid: grid 使用grid-template-columns和grid-template-rows属性来控制网格中的行与列，默认值为auto 常用的模式是为网格制定列宽度，但是允许网格按需添加行 fr是一种弹性单位，它可以指定网格容器内的空间被如何划分 5.1、关于网格的一些术语 inline axis block axis grid line grid cell grid area 5.2、网格的自动排列规则 网格容器的直接子元素就会开始将它们自己一个一个地放置在网格的单元格中 网格中任何没有被进行定位的直接子元素都会根据自动排列规则进行放置 5.3、基于行/列的基本定位方法 定位网格元素最简单的方式是使用基于行/列（line）的定位方法，只需告诉浏览器从哪一排到哪一排来进行合并 grid-column-start grid-column-end grid-row-start grid-row-end 缩写 grid-column: [start] / [end]、grid-row: [start] / [end] 5.4、通过命名区域来定位元素 grid-area 设置元素名字 grid-template-areas 设置布局方式 . 空出单元格 12345678910111213141516171819.item1 &#123; grid-area: a;&#125;.item2 &#123; grid-area: b;&#125;.item3 &#123; grid-area: c;&#125;.container &#123; display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; grid-template-areas: \"a a b b\" \"a a c c\";&#125; 6、显示顺序和文档顺序（visual and document order） 从上到下的阅读顺序来组织文档顺序 会有助于可读性和CSS的布局方式 7、盒模型的生成（box generation） 写在网页里的任何东西都会生成一个盒子（box） 7.1、不生成盒子或内容（display: none） 不会被展示，并且不会保留其本该占有的空间 7.2 不生成该元素，但是生成其所有子元素（display: contents） 自身的盒子不生成但所有的子元素都会照常生成 如果希望一个弹性布局或网格布局中的非直接子元素能应用这些布局，这就会非常有用 8、对齐 justify-content align-content place-content justify-items align-items place-items justify-self align-self place-self row-gap column-gap gap 9、多栏布局（多列布局） 支持创建多栏的布局类型 当展示一组高度不同的卡片或产品时多栏布局也非常有用 9.1、设置栏的宽度123.container &#123; column-width: 300px;&#125; 9.2、设置栏的数目123.container &#123; column-count: 3;&#125; 9.3、间距和栏规则 column-gap 间距 默认 1em column-rule 两栏间规则，类似 border，不占用空间 column-rule-width column-rule-color column-rule-style 9.4、允许元素横跨多栏 column-span all none 10、碎片化（Fragmentation） break-inside: avoid：确保卡片不会被截为两半分到不同的栏 reak-after: avoid：元素后禁止断行 reference 一篇全面的CSS布局学习指南 [译]","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ziiyan.github.io/tags/CSS/"}]},{"title":"面试准备-计算机网络","slug":"面试准备：计算机网络","date":"2020-07-27T15:01:08.000Z","updated":"2020-08-04T14:59:33.036Z","comments":true,"path":"2020/07/27/面试准备：计算机网络/","link":"","permalink":"http://ziiyan.github.io/2020/07/27/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"1、体系结构 TCP/IP体系结构(四层) 五层 OSI的体系结构(七层) 4、应用层 5、应用层 7、应用层 6、表示层 5、会话层 3、传输层 4、传输层 4、传输层 2、网络层 3、网络层 3、网络层 1、物理层 2、链路层 2、链路层 1、物理层 1、物理层 2、TCP2.1、定义 Transmission Control Protocol，传输控制协议 传输层 2.2、特点 面向连接 先建立连接、传输完成后释放连接 可靠 不丢失、无差错、不重复、按顺序到达 面向字节流 流：流入/出进程的字符序列 TCP一次传输的报文长度有限制，太大需分块 按序到达可以重新组合 全双工通信 双方都能发送数据 2.3、优缺点 可靠 慢 需要建立连接 发送确认包 2.4、应用场景 要求通信数据可靠 2.5、报文段格式 序号 本报文段所发送数据的第1个字节的序号 确认号（ACK） 期望收到对方下个报文段的第一个字节的序号 ACK = N ：N-1 都收到 SYN（同步位） 连接建立时用于同步序号 SYN = 1、ACK = 0：连接请求 SYN = 1、ACK = 1：连接请求响应 FIN（终止控制位） 释放连接 FIN = 1：发送完毕，请求释放连接 2.6、三次握手 描述 报文段信息 状态 客户端发送【连接请求】报文段 1、同步标志位 SYN = 1，2、随机起始序号 seq = x，3、不携带数据SYN = 1 的报文段不能携带数据，但要消耗一个序号 客户端【SYN_SEND】【同步已发送】 服务器发送【响应确认】报文段 1、同步标志位 SYN = 1，2、确认标记位 ACK = 1，3、随机起时序号 seq = y，4、确认号字段 ack = x+1同上，不携带数据 服务器【SYN_RCVD】【同步已接受】 客户端发送【连接确认】报文段 1、确认标记位 ACK = 1，2、序号 seq = x+13、确认号字段 ack = y+1可携带数据 客户端、服务器【ESTABLISHED】【创建】 为什么TCP建立连接需三次握手？ 两次？防止服务端与历史请求建立连接 两次握手 如果网络比较差，发送方连续发送多次建立连接的请求，服务端无法判断当前收到的请求是否已经过期 三次握手 如果当前连接是历史连接，即 SEQ 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接； 如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接 初始化序列号 通信双方都需要获得一个用于发送信息的初始化序列号 四次？可以但没必要 总可以使用更多的通信次数交换相同的信息 三次是最小次数 2.7、四次挥手 描述 报文段信息 状态 客户端发送【连接释放】报文段 1、终止控制位 FIN = 1，2、报文段序号，发送数据最后序号+1，seq = u，可携带数据 客户端【FIN-WAIT-1】【终止等待1】 服务器发送【连接释放确认】报文段 1、确认标记位 ACK = 1，2、报文段序号，发送数据最后序号+1，seq = v，3、确认号字段 ack = u+1 服务器【CLOSE-WAIT】【关闭等待】客户端【FIN-WAIT-2】【终止等待2】客户端 -&gt; 服务器 TCP 断开 服务器发送【释放连接】报文段 1、终止控制位 FIN = 1，2、却仍表姐为 ACK = 1，3、报文段序号 seq = w，4、重复确认号字段 ack = u+1，可携带数据 服务端【LAST-ACK】【最后确认】 客户端发送【连接释放确认】 1、确认标记位 ACK = 1，2、报文段序号 seq = u+1，3、确认号字段 ack = w+1，可携带数据 客户端【TIME-WAIT】【时间等待】经过时间等待后，客户才关闭服务器【CLOSED】【关闭】服务器 -&gt; 客户端 TCP 断开 为什么TCP释放连接需四次挥手？ 为了保证通信双方都能通知对方需释放 &amp; 断开连接 全双工，即双方都可以发送 &amp; 接收信息 两次挥手只能保证单向关闭 为什么客户端关闭连接前要等待时间？/ TIME-WAIT 的作用？ 为了保证客户端发送的【连接释放确认】报文能到达服务器 2.8、无差错传输2.8.1、含义 无差错：即 传输信道不出差错 发送 &amp; 接收效率匹配：即 无论发送方以多快的速度发送数据，接收方总来得及处理收到的数据 2.8.2、基础：滑动窗口 发送窗口 任意时刻，发送方维持的一组连续的、允许发送帧的帧序号 对发送方进行流量控制 收到确认帧，滑动窗口滑动 接受窗口 任意时刻，接收方维持的一组连续的、允许接收帧的帧序号 控制可接收哪些数据帧 只有当收到数据帧序号落入接收窗口，接收并滑动，否则丢弃帧 2.8.3、实现无差错传输的解决方案[2] 核心思想：采用一些可靠传输协议，使得 出错重传：出现差错时，让发送方重传差错数据 自动重传协议 速度匹配：当接收方来不及接收收到的数据时，可通知发送方降低发送数据的效率 流量控制 拥塞控制 自动重传协议 停等式：发送窗口 = 1、接收窗口 = 1 后退N帧：发送窗口 &gt; 1、接收窗口 = 1 选择重传：发送窗口 &gt; 1、接收窗口 &gt; 1 流量控制 &amp; 拥塞控制 流量控制：点对点 接收方根据自己接收缓存的大小，动态调整发送方窗口大小 发送方根据接收方返回的确认帧调整发送方窗口大小 拥塞控制：全局 防止过多的数据注入到网络中，使得网络中的路由器 &amp; 链路过载 慢开始 &amp; 拥塞避免 快重传 &amp; 快恢复 2.9、与 UDP 的区别 TCP：面向连接、可靠、字节流。适合数据可靠的场景 UDP：无连接、不可靠、数据报文段。适合通信速度高的场景 3、UDP3.1、定义 User Datagram Protocol，用户数据报协议 传输层 3.2、特点 无连接 不可靠 可能出现丢包，不管对方是否接收 面向报文 无长度限制，一次性发送 无拥塞控制 3.3、优缺点 速度快 不可靠 3.4、应用场景 要求通信速度高 3.5、报文段格式 源端口（回复时使用） 目的端口 长度 检验和（检测UDP在传输中是否有错，有错丢弃） 伪首部 3.6、与 TCP 的区别 TCP：面向连接、可靠、字节流。适合数据可靠的场景 UDP：无连接、不可靠、数据报文段。适合通信速度高的场景 4、HTTP4.1、定义 HyperText Transfer Protocol，超文本传输协议 应用层 4.2、特点 传输效率高 无连接：不需要建立 HTTP 连接 无状态：不保存历史&amp;状态信息 传输格式简单：请求时只需方法&amp;路径 传输可靠性高 基于 TCP 其它 兼容性好：支持 B/S、C/S 灵活性高：允许传输任意类型数据对象 4.3、工作方式 请求 / 相应 工作方式 4.4、HTTP 报文详解4.4.1、请求报文 请求行 GET、POST 方法的区别？ 语义：GET 请求，POST 提交 参数：GET 放 URL 中，POST 放 body 浏览器对 URL 有限制长度，HTTP 协议未限制 安全性：GET 参数可见，POST 数据在浏览器中无缓存 请求头 请求体 4.4.2、响应报文 状态行 常见状态码？ 200 404 302 304 响应头 响应体 4.5、额外知识4.5.1、HTTP 1.1 与 HTTP 1.0 的区别 http 1.1 引入持久连接，在一个 TCP 中可以传送多个 HTTP 请求 &amp; 响应 多个请求 &amp; 响应可以同时进行 引入更多请求头 &amp; 响应头 4.5.2、HTTP 与 HTTPS 的区别 URL 原理 功能 标准端口 CA http:// 应用层 不加密 80 不需要 https:// 传输层 加密（SSL、身份认证） 443 需要 4.5.3、HTTP 处理长连接的方式 Keep-Alive 机制 5、其它5.1、浏览器输入 URL 到页面显示的过程 dns解析 tcp连接 http请求 服务器响应 浏览器渲染 页面资源加载 建立连接 加载资源 页面资源渲染 处理HTML标记，构建DOM树 处理CSS标记，构建CSSOM树 将DOM树和CSSOM树融合成渲染树（会忽略不需要渲染的dom） 根据渲染树来布局，计算每个节点的几何信息 在屏幕上绘制各个节点 中间遇到各种资源时，会进行资源的下载 5.2、跨域5.2.1、同源策略 协议、域名、端口号 相同 限制： Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点操作 AJAX 请求 img、link、script 允许跨域加载资源 解决方案 cors res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE'); res.header('Access-Control-Allow-Headers', '*'); jsonp 原理：利用 &lt;script&gt;、&lt;link&gt;、&lt;img&gt; 没有同源限制 src 属性的值为接口地址 前后端约定好执行函数的名称 callback 前端定义该函数 callback(data) { console.log(data); } 后台返回数据 res.send(&#39;callback(${JSON.stringify(data))&#39;) nginx 反向代理 Node 中间件代理 postMessage websocket 5.3、cookie、localstroage、sessionstroage 的区别 Cookie适合存储一些session信息： cookie限制大小，约4k左右，不适合存储业务数据，尤其是数据量较大的值 存在有效期，到期自动销毁 cookie会每次随http请求一起发送，浪费宽 cookie设置了domain可以在子域共享跨域 可以使用爬虫抓取 localstroage适合存储应用共享的地址信息等： 存储数据量大，5M或者更大 有效期为永久 不会随http请求一起发送 不能跨域，但是可以使用postMessage和iframe消除这个影响,例如：cross-storage 在浏览器的隐私模式下不能读取 不能被爬虫读取 sessionstroage适合存储浏览状态等： 存储数据量大，5M或者更大 有效期为到浏览器关闭 不会随http请求一起发送 不能被爬虫读取 5.4、HTTPS5.4.1、HTTP 为什么不安全 明文传输，内容可能被窃听 无法验证报文的完整性，内容可能被篡改（中间人攻击） 不验证对方身份，可能被伪装 5.4.2、HTTPS 实现原理 HTTP 先跟 SSL 通信再由 SSL 跟 TCP 通信 HTTP HTTPS HTTP HTTP SSL TCP TCP IP IP SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应 用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是 当今世界上应用最为广泛的网络安全技术。 加密 数据传输阶段——对称密钥加密 加密和解密阶段使用同一个密钥 证书验证阶段——非对称密钥加密 对方公钥加密，对应私钥解密 比对称密钥复杂，慢 混合加密机制 非对称私钥用来交换共享密钥（公钥加密） 对称密钥用来交换数据（共享密钥加密） 证书 服务器把自己的公开密钥交给CA（Certificate Authority，数字认证机构） CA 用自己的私钥给服务器的公钥签名，并颁发公钥证书 客户端拿到服务器的公钥证书，用植入浏览器的CA公钥验证证书真实性，从而保证服务器公钥真实性 客户端使用服务器的公钥对报文加密后发送 服务器使用自己的私钥对豹纹解密 数据完整性 数字签名 发送方用摘要算法对报文提取生成数字摘要 使用私钥对摘要进行加密加密后的摘要作为数字签名附加在报文上，一起发送给接收方 接收方收到报文后，使用相同的摘要算法提取出摘要 再使用公钥对报文的数字签名进行解密 如果解密后的数字签名与提取出得摘要相同，那么就可以证明报文没被篡改，数据是完整的 5.4.3、HTTPS 完整流程 证书验证阶段 客户端发起 HTTPS 请求 服务端返回 HTTPS 证书 客户端验证证书是否合法 数据传输阶段 客户端生成共享密钥 公钥加密共享密钥，发送给服务端 服务端用私钥解密，获得共享密钥 共享密钥加密交换数据 5.4.4、HTTPS 缺点 速度慢 CA 付费 Reference 面试带你飞：这是一份全面的 计算机网络基础 总结攻略 计算机网络：这是一份全面 &amp; 详细 的TCP协议攻略 为什么 TCP 建立连接需要三次握手 计算机网络：这是一份全面&amp; 详细 HTTP知识讲解 九种跨域方式实现原理（完整版） 前端必须懂的计算机网络知识—(跨域、代理、本地存储) [秃破前端面试] —— HTTP &amp;&amp; HTTPS","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://ziiyan.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"面试","slug":"面试","permalink":"http://ziiyan.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"字节跳动-产品研发-一面凉经","slug":"字节跳动-产品研发-一面凉经","date":"2020-07-26T07:58:07.000Z","updated":"2020-08-03T15:13:30.722Z","comments":true,"path":"2020/07/26/字节跳动-产品研发-一面凉经/","link":"","permalink":"http://ziiyan.github.io/2020/07/26/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-%E4%BA%A7%E5%93%81%E7%A0%94%E5%8F%91-%E4%B8%80%E9%9D%A2%E5%87%89%E7%BB%8F/","excerpt":"","text":"计算机网络 TCP/IP 七层模型 TCP、UDP 在哪层，区别 TCP 怎么实现丢包检测机制 HTTP、HTTPS 区别 HTML 语义化标签有哪些 聊聊 meta 标签 CSS 实现水平垂直居中的方法，尽量多 实现双栏布局（左边定宽100px，右边自适应） JS 基本数据类型 关于 Symbol 知道多少 判断数据类型的方法 如何区分 Array 和 Object 节流、防抖场景 手写节流 / 防抖 Vue 双向绑定原理 setter、getter 的时候做了什么 数据结构 判断链表是否有环 岛屿最大面积","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ziiyan.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"浏览器缓存","slug":"浏览器缓存","date":"2020-07-21T07:58:33.000Z","updated":"2020-07-27T09:15:42.890Z","comments":true,"path":"2020/07/21/浏览器缓存/","link":"","permalink":"http://ziiyan.github.io/2020/07/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","excerpt":"","text":"HTTP 缓存1、缓存的判断策略1.1、存储策略 发生在收到请求响应后 用于决定是否缓存相应资源 1.2、过期策略 发生在请求前 用于判断缓存是否过期 1.3、协商策略 发生在请求中 用于判断缓存资源是否更新 浏览器下访问资源的方式主要有以下7种： (新标签)地址栏回车 链接跳转 前进、后退 从收藏栏打开链接 (window.open)新开窗口 刷新（Command + R / F5） 强制刷新（Command + Shift + R / Ctrl + F5） 2、缓存基础缓存又分为强缓存和弱缓存（又称为协商缓存），区别是获取资源时是否会发送请求。 2.1、强缓存 包括 Expires 和 Cache-Control 过期策略生效时应用的缓存 2.2、弱缓存 包括 Last-Modified 和 ETag 协商策略后应用的缓存 2.3、HTTP 相关字段2.3.1、Expires（1.0） 指定缓存的过期时间，为绝对时间 响应头字段 参考本地时间进行比对，在指定时刻后过期 因此修改本地时间就会失效 2.3.2、Cache-Control 指定资源的缓存机制 同时在请求头和响应头中设定 涉及存储策略、过期策略 2.3.2.1、cache-directive 大小写不敏感2.3.2.2、在请求头中的 max-age max-age=&lt;seconds&gt; 客户端不接受有效时间大于指定时间的缓存 Chrome和Firefox浏览器下的刷新操作（Command+ R / F5）均是在请求头上添加了max-age=0指令，表示不使用强缓存，但允许协商缓存 2.3.2.3、max-age 优先级高于 Expires2.3.2.4、no-cache 和 no-store no-cache：跳过强缓存，强制进入协商策略 no-store：不缓存 2.3.3、Pragma（1.0） 通常设置为Pragma:no-cache，作用与Cache-Control:no-cache相同 当在浏览器进行强刷（Comand + Shift + R / Ctrl + F5）或在NetWork面板内勾选禁用缓存（Disable Caches）时，会自动带上Pragma:no-cache和Cache-Control:no-cache，并且不会带上协商策略中所涉及的信息（下面介绍的If-Modified-Since/If-None-Match）。这时不会使用任何缓存，重新获取资源 2.3.4、Last-Modified / If-Modified-Since / If-Unmodified-Since Last-Modified用于标记请求资源的最后一次修改时间 返回的资源带有Last-Modified标识时，再次请求该资源，浏览器会自动带上If-Modified-Since，值为返回的Last-Modified值 请求到达服务器后，服务器进行判断，如果从上次更新后没有再更新，则返回304。如果更新了则重新返回 If-Modified-Since 只能用于 GET、HEAD If-Unmodified-Since 表示资源未修改则正常执行更新，否则返回412 2.3.5、ETag / If-Match / If-None-Match ETag是请求资源在服务器的唯一标识，浏览器可以根据ETag值缓存数据 再次请求时通过 If-None-Match 携带上次的 ETag 值 如果值不变，则返回304 如果改变则返回新的内容 ETag的优先级高于Last-Modified 3、缓存的优缺点![image-20200721172953127](/Users/wuziyan/Library/Application Support/typora-user-images/image-20200721172953127.png) 浏览器缓存应用程序缓存","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://ziiyan.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"性能","slug":"性能","permalink":"http://ziiyan.github.io/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"Vue.js 性能优化实践","slug":"首屏加载速度优化","date":"2020-07-20T05:30:32.000Z","updated":"2020-07-28T10:47:40.262Z","comments":true,"path":"2020/07/20/首屏加载速度优化/","link":"","permalink":"http://ziiyan.github.io/2020/07/20/%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/","excerpt":"","text":"1、webpack-bundle-analyzer 可视化的方式分析 bundle 打包情况 针对性优化 INSTALL1npm install --save-dev webpack-bundle-analyzer USAGE12345678910// vue.config.jsconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;module.exports = &#123; configureWebpack: &#123; plugins: [ new BundleAnalyzerPlugin() ... ] &#125;&#125; 这里主要发现两个问题： 1.1、组件替换不完全 Vuetify 解决方案删除这个包 1.2、第三方包未按需引入 ant design lodash 解决方案使用 babel-plugin-import 将 js 和 css 按需引入 原理 2、gZip 服务器发送压缩包，浏览器进行解压 目的是减少资源传输时间 客户端发送请求时 Accept-Encoding 字段说明自己接受哪些压缩方法 服务器发送资源时 Content-Encoding 字段说明数据的压缩方法 如果服务器在接收到请求时才进行压缩，然后压缩好再发送，压缩时间就会被用户感知 解决方案使用 compression-webpack-plugin 在前端项目打包时就进行压缩 test：正则匹配需要压缩的文件 threshold：超过阈值进行压缩 deleteOriginalAssets：是否删除原文件 这边由于保留了原文件及压缩包，所以打包出来的 dist 文件会比之前大，但对传输来说不影响 3、代码分割 把代码分离到不同的 bundle 中，可以按需加载或并行加载这些文件 常用的代码分离方法有三种： 入口起点：使用 entry 配置手动地分离代码 防止重复：使用 SplitChunksPlugin 去重和分离 chunk 动态导入：通过模块的内联函数调用来分离代码 在代码中自动将使用 import() 加载的模块分离成独立的包 3.1、提取公共代码 相同的资源被重复加载，浪费用户的流量和服务器的成本 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验 将多个页面的公共代码抽离成单独的文件 解决方案splitChunks 3.2、Vue.js 路由懒加载 把不同路由对应的组件分割成不同的代码块，当路由被访问的时候才加载对应组件 结合 Vue 的异步组件和 Webpack 的代码分割功能 4、预渲染5、浏览器缓存6、CDN Content Delivery Network，内容分发网络 使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://ziiyan.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"性能","slug":"性能","permalink":"http://ziiyan.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"网络","slug":"网络","permalink":"http://ziiyan.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"刷面经","slug":"刷面经","date":"2020-07-07T12:38:41.000Z","updated":"2020-07-27T09:31:22.401Z","comments":true,"path":"2020/07/07/刷面经/","link":"","permalink":"http://ziiyan.github.io/2020/07/07/%E5%88%B7%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"最近有点看不进去书，到牛客找面经上面对面经复习 主要是为了用自己的语言组织一下，怕面试了答不上来 HTML 简述一下你对 HTML 语义化的理解 用正确的标签做正确的事 便于浏览器及搜索引擎的解析，利于 SEO 可读性 视觉障碍的人可能会使用屏幕阅读器，语义化的文档对屏幕阅读器更友好 开发人员看代码时也更容易理解结构，利于维护 JS this 作用域 指向运行时所在的作用域，一般是调用函数的对象 如果是全局就是 Window 如果是该函数是一个构造函数，this指针指向一个新的对象 使用 call、apply、bind 可以改变 this 的指向 call、apply 区别： 第一个参数都是 this 需要指向的对象 call 参数一个个传 apply 传数组 bind 只是绑定一下，不执行，要执行的话需要再加括号 箭头函数没有自己的 this，根据作用域链去找 如果箭头函数使用 call、apply、bind，第一个参数会被忽略 什么样的 const 值可以更改 const 只规定了变量的内容不被修改 如果是基本数据类型（string、number、bool、undefined、null、symbol）就不能改，因为直接存的数据 如果是复杂数据类型（Object）就可以改，因为保存的是变量的地址，地址再指向真实的数据，改变真实数据的情况下，地址不会变 事件 事件捕获 处于目标阶段 事件冒泡 Promise 函数的柯里化 把接受多个参数的函数变换成接受一个参数的函数，并且返回接受余下参数的新函数 js 原型链 深浅复制 闭包 能够读取其他函数变量的函数 new 一个对象的过程 创建一个空对象 将对象的原型指向构造函数 执行构造函数中的代码 返回新对象 123let obj = &#123;&#125;obj.__proto__ = Base.prototype;Base.call(obj); CSS 垂直居中 怎么用 css 画一个三角形 相对定位 绝对定位 flex-box 怎么用 圣杯布局 &lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;style&gt; .left, .main, .right { position: relative; min-height: 200px; float: left; } .left { width: 200px; background: lightpink; margin-left: -100%; left: -200px; } .right { width: 300px; background-color: lightgreen; margin-left: -300px; right: -300px; } .main { width: 100%; background-color: lightblue; } .container { padding: 0 300px 0 200px; } &lt;/style&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041* 双飞翼布局 * &#96;&#96;&#96;html &lt;body&gt; &lt;div class&#x3D;&quot;container&quot;&gt; &lt;div class&#x3D;&quot;main&quot;&gt; &lt;div class&#x3D;&quot;inner&quot;&gt;content&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;style&gt; .left, .main, .right &#123; min-height: 200px; float: left; &#125; .left &#123; width: 200px; background: lightpink; margin-left: -100%; &#125; .right &#123; width: 300px; background: lightgreen; margin-left: -300px; &#125; .main &#123; width: 100%; background: lightblue; &#125; .inner &#123; background: salmon; min-height: 200px; margin: 0 300px 0 200px; &#125; &lt;&#x2F;style&gt; Vue 双向绑定原理 vue-router 实现方式 vue 和 React 的区别 mvvm 的设计模式 ViewModel 分离视图和模型，ViewModel 只关心数据和业务的处理 父子组件的通信机制 组件化思想 页面懒加载向写法 生命周期 数据结构 队列和栈的区别？用栈来实现队列 队列是先进先出，类似于排队；栈的话是先进后出，出入口是同一个，先进的元素会被压在下面 可以用两个栈，在出栈的时候把元素都先放到另外一个栈中，这样顺序就对了 网络 TCP、UDP区别？TCP如何做到双工可靠传输？TCP阻塞控制是什么？ TCP 是面向连接的，传输比较可靠；UDP 是不可靠传输，比较适用于实时应用 302 和 304 的区别 http code 的含义 HTTP 1.0/2.0 HTTPS HTTP的发展 如何优雅的谈论HTTP 操作系统 进程和线程的区别 其它 跨域 jsonp 原理 用户输入网址，看到页面的流程 Bootstrap 栅格系统的写法 怎么优化项目 存储 手撕代码 提取url中search部分参数，https://www.aliexpress.com/?a=1&amp;b=2 12345678910function fn (str) &#123; let arr = str.split('?')[1]; let params = arr.split('&amp;'); let ans = [] for (item of params) &#123; let param = item.split('='); ans.push(&#123;key: param[0], value: param[1]&#125;) &#125; return ans;&#125; 写一个类Person， 拥有属性age和name，拥有方法say(something)， 再写一个类Superman，继承Person，拥有自己的属性power，拥有自己的方法fly(height) 123456789101112131415161718class Person &#123; constructor(age, name) &#123; this.age = age; this.name = name; &#125; say(something) &#123; console.log(something) &#125;&#125;class Superman extends Person &#123; constructor(power) &#123; super(); this.power = power; &#125; fly(height) &#123; console.log(`fly to $&#123;height&#125;`) &#125;&#125; Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. 123456789function moveDup(params) &#123; for (let i = 1; i &lt; params.length; i++) &#123; if (params[i] === params[i-1]) &#123; params.splice(i, 1) &#125; &#125; return params&#125;console.log(moveDup([1, 2, 3, 3, 4, 5, 5])) quickSort 12345678910111213141516171819202122function quickSort(arr, left = 0, right = arr.length - 1) &#123; if (left &gt;= right) &#123; return &#125; const priv = arr[right]; let i = left; let j = right; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[i] &lt; priv) &#123; i++; &#125; arr[j] = arr[i]; while (j &gt; i &amp;&amp; arr[j] &gt; priv) &#123; j--; &#125; arr[i] = arr[j]; &#125; arr[j] = priv; quickSort(arr, left, j-1); quickSort(arr, j+1, right); return arr;&#125; debounce 123456789function debounce(fn, ms) &#123; let timer = null; return function () &#123; clearTimeout(timer); timer = setTimeout(()=&gt;&#123; fn.apply(this, arguments); &#125;, ms); &#125;&#125; throttle 1234567891011function throttle(fn, ms) &#123; let flag = true; return function() &#123; if (!flag) return; flag = false; setTimeout(()=&gt;&#123; fn.apply(this, arguments); flag = true &#125;, ms) &#125;&#125;","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ziiyan.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Webpakc 从原理到实战","slug":"Webpakc 从原理到实战","date":"2020-07-01T14:48:02.000Z","updated":"2020-07-27T09:19:51.167Z","comments":true,"path":"2020/07/01/Webpakc 从原理到实战/","link":"","permalink":"http://ziiyan.github.io/2020/07/01/Webpakc%20%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98/","excerpt":"","text":"Webpakc 从原理到实战 理解前端模块化 发展历程 不同模块化方案的实现 理解 webpack 打包核心思路 理解 loader &amp; plugin 简介 webpack 是一个现代 JavaScript 应用程序的静态模块 打包器 默认只处理 Javascript 逻辑多、文件多，项目的复杂度提高，所以需要打包 打包之外，还有“翻译”功能 —— loader 加上一些小动作 —— plugin 可插拔 原理与背景理解前端模块化作用域运行时 - 变量 函数 对象 可访问性 作用域决定了代码中变量和其它资源的可见性 命名空间模块化的优点 作用域封装 重用性 解除耦合 模块化方案进化史AMD Asynchronous Module Definition 12345define('getSum', ['math'], function (math) &#123; return function (a, b) &#123; console.log('sum: ' + math.sum(a, b)); &#125;&#125;); COMMONJS 服务端模块标准，不是用于浏览器环境 nodejs 采用并实现部分规范 1234const math = require('./math');exports.getSum = function (a, b) &#123; return a + b;&#125; ES6 MOUDLE Javascript 原生支持 1234import math from './math';export function sum(a, b) &#123; return a + b;&#125; Gulp、Grunt —— 自动化构建工具 打包只是自动化构建中的一部分 webpack 专门针对打包，代表着模块化的流行 webpack 的打包过程 从入口文件开始，分析整个应用的依赖树 将每个依赖模块包装起来，放到一个数组中等待调用 实现模块加载的方法，并把它放到模块执行的环境中，确保模块间可以互相调用 把执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数 实战配置开发环境npm 与包管理器 依赖 –save –dev 版本号 ^version 中版本和小版本 ^1.0.1 -&gt; 1.x.x 中取最新 ~version 小版本 ~1.0.1 -&gt; 1.0.x 中取最新 version: 特定版本 scripts npm install 过程 检查 .npmrc 文件：优先级为：项目级的 .npmrc 文件 &gt; 用户级的 .npmrc 文件&gt; 全局级的 .npmrc 文件 &gt; npm 内置的 .npmrc 文件 检查项目中有无 lock 文件。 无 lock 文件： 从 npm 远程仓库获取包信息 根据 package.json 构建依赖树，构建过程： 构建依赖树时，不管其是直接依赖还是子依赖的依赖，优先将其放置在 node_modules 根目录。 当遇到相同模块时，判断已放置在依赖树的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 node_modules 下放置该模块。 注意这一步只是确定逻辑上的依赖树，并非真正的安装，后面会根据这个依赖结构去下载或拿到缓存中的依赖包 在缓存中依次查找依赖树中的每个包 不存在缓存： 从 npm 远程仓库下载包 校验包的完整性 校验不通过： 重新下载 校验通过： 将下载的包复制到 npm 缓存目录 将下载的包按照依赖结构解压到 node_modules 存在缓存：将缓存按照依赖结构解压到 node_modules 将包解压到 node_modules 生成 lock 文件 有 lock 文件： 检查 package.json 中的依赖版本是否和 package-lock.json 中的依赖有冲突。 如果没有冲突，直接跳过获取包信息、构建依赖树过程，开始在缓存中查找包信息，后续过程相同 构建工程核心特性loader 和 pluginwebpack 与前端性能webpack 性能调优打包结果优化 BundleAnalyZerPlugin 构建过程优化 利用多线程 预编译缓存Tree-Shaking总结不止 “pack”","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://ziiyan.github.io/tags/Webpack/"}]},{"title":"回调地狱 Callback Hell","slug":"回调地狱-callbackhell","date":"2020-06-15T02:59:02.000Z","updated":"2020-06-15T02:59:31.925Z","comments":true,"path":"2020/06/15/回调地狱-callbackhell/","link":"","permalink":"http://ziiyan.github.io/2020/06/15/%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1-callbackhell/","excerpt":"","text":"http://callbackhell.com/","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://ziiyan.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"精读","slug":"精读","permalink":"http://ziiyan.github.io/tags/%E7%B2%BE%E8%AF%BB/"}]},{"title":"MDN-JavaScript","slug":"MDN-JavaScript","date":"2020-06-09T15:35:41.000Z","updated":"2020-06-28T03:18:29.319Z","comments":true,"path":"2020/06/09/MDN-JavaScript/","link":"","permalink":"http://ziiyan.github.io/2020/06/09/MDN-JavaScript/","excerpt":"","text":"数据类型字符串 indexOf 查找子串 slice 分片 replace 替换 split 字符串转数组 数组 join 数组转字符串（指定分隔符） toString 数组转字符串（逗号分隔） 事件原型_proto_ 在javascript中，函数可以有属性，每个函数都有一个特殊的属性叫作原型 原型链中的方法和属性没有被复制到其他对象——它们被访问需要通过前面所说的“原型链”的方式 没有官方的方法用于直接访问一个对象的原型对象——原型链中的“连接”被定义在一个内部属性中，在 JavaScript 语言标准中用 [[prototype]] 表示（参见 ECMAScript）。然而，大多数现代浏览器还是提供了一个名为 __proto__ （前后各有2个下划线）的属性，其包含了对象的原型 prototype prototype 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中 不在 prototype 对象内的成员，不会被“对象实例”或“继承自 Object() 的对象类型”所继承 这些方法/属性仅能被 Object() 构造器自身使用 123person = function () &#123;&#125;person1 = new function()Person1.__proto__ === person.prototype constructor 每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数（可以用来 new） 123456person = function () &#123;&#125;person1 = new function()person1.constructor === person// new function() &lt;=&gt; new person1.constructor()person1.constructor.name// \"person\" 原型式继承123456789101112function Person(first, last, age, gender, interests) &#123; this.name = &#123; first, last &#125;; this.age = age; this.gender = gender; this.interests = interests;&#125;;Person.prototype.greeting = function() &#123; alert('Hi! I\\'m ' + this.name.first + '.');&#125;; 12345678function Teacher(first, last, age, gender, interests, subject) &#123; Person.call(this, first, last, age, gender, interests); this.subject = subject;&#125;Teacher.prototype = Object.create(Person.prototype);Teacher.prototype.constructor = Teacher; 当我们输入类似var person1=new Person(...)来构造对象时，JavaScript实际上参考的是Person.prototype指向的对象来生成person1。 另一方面，Person()函数是Person.prototype的构造函数，也就是说Person===Person.prototype.constructor 委托 委托 - 特殊的对象将功能委托给通用的对象类型完成 考虑到JavaScript的工作方式，由于原型链等特性的存在，在不同对象之间功能的共享通常被叫做 委托 - 特殊的对象将功能委托给通用的对象类型完成。这也许比将其称之为继承更为贴切，因为“被继承”了的功能并没有被拷贝到正在“进行继承”的对象中，相反它仍存在于通用的对象中。 异步线程 一个线程是一个基本的处理过程，每个线程一次只能执行一个任务 现在的计算机大都有多个内核（core），因此可以同时执行多个任务 支持多线程的编程语言可以使用计算机的多个内核，同时完成多个任务 JavaScript 是单线程的 即使有多个内核，也只能在单一线程上运行多个任务，称为主线程（main thread） 异步代码Web workers 通过 Web workers 可以把一些任务交给一个名为 worker 的单独的线程 用一个 worker来运行一个耗时的任务，主线程就可以处理用户的交互（避免了阻塞） web workers 不能访问 DOM Promise Promises fetch 现代版的，更高效的 XMLHttpRequest 事件队列 像promise这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。 间隔 setTimeout() 在指定的时间后执行一段代码 setInterval() 以固定的时间间隔，重复运行一段代码 1234567let i = 1;setTimeout(function run() &#123; console.log(i); i++; setTimeout(run, 100);&#125;, 100); 123456let i = 1;setInterval(function run() &#123; console.log(i); i++&#125;, 100); 区别： 递归 setTimeout() 保证执行之间的延迟相同，例如在上述情况下为100ms。 代码将运行，然后在它再次运行之前等待100ms，因此无论代码运行多长时间，间隔都是相同的。 使用 setInterval() 的示例有些不同。 我们选择的间隔包括执行我们想要运行的代码所花费的时间。假设代码需要40毫秒才能运行 - 然后间隔最终只有60毫秒。 当递归使用 setTimeout() 时，每次迭代都可以在运行下一次迭代之前计算不同的延迟。 换句话说，第二个参数的值可以指定在再次运行代码之前等待的不同时间（以毫秒为单位）。 当你的代码有可能比你分配的时间间隔，花费更长时间运行时，最好使用递归的 setTimeout() - 这将使执行之间的时间间隔保持不变，无论代码执行多长时间，你不会得到错误。 requestAnimationFrame() 在浏览器下一次重新绘制显示之前执行指定的代码块，从而允许动画在适当的帧率下运行，而不管它在什么环境中运行 客户端 API浏览器 API DOM（文档对象模型） window是载入浏览器的标签 navigator表示浏览器存在于web上的状态和标识（即用户代理） document（在浏览器中用DOM表示）是载入窗口的实际页面 XMLHttpRequest Fetch API Canvas Web Storage API IndexedDB API 画图音频与视频客户端存储传统方法：cookie 过时、存在各种安全问题，而且无法存储复杂数据 唯一优势是它们得到了非常旧的浏览器的支持 新流派：Web Storage 和 IndexedDB Web Storage API 提供了一种非常简单的语法，用于存储和检索较小的、由名称和相应值组成的数据项。当您只需要存储一些简单的数据时，比如用户的名字，用户是否登录，屏幕背景使用了什么颜色等等，这是非常有用的。 IndexedDB API 为浏览器提供了一个完整的数据库系统来存储复杂的数据。这可以用于存储从完整的用户记录到甚至是复杂的数据类型，如音频或视频文件。 Web Storage 所有的 web storage 数据都包含在浏览器内两个类似于对象的结构中： sessionStorage 和 localStorage。 sessionStorage：只要浏览器开着，数据就会一直保存；关闭浏览器时数据会丢失 localStorage：一直保存数据，甚至到浏览器关闭又开启后也是这样 每个域都有一个单独的数据存储区 IndexedDB未来：Cache API Cache API 是为存储特定HTTP请求的响应文件而设计的，它对于像存储离线网站文件这样的事情非常有用，这样网站就可以在没有网络连接的情况下使用。 缓存通常与 Service Worker API 组合使用，尽管不一定非要这么做。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ziiyan.github.io/tags/JavaScript/"}]},{"title":"leetcode周赛-第192场","slug":"leetcode周赛-第192场","date":"2020-06-07T11:25:04.000Z","updated":"2020-07-27T09:18:38.245Z","comments":true,"path":"2020/06/07/leetcode周赛-第192场/","link":"","permalink":"http://ziiyan.github.io/2020/06/07/leetcode%E5%91%A8%E8%B5%9B-%E7%AC%AC192%E5%9C%BA/","excerpt":"","text":"T1代码12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; n * @return &#123;number[]&#125; */var shuffle = function(nums, n) &#123; let x = nums.slice(0, n); // x: [x1, x2, ..., xn] let y = nums.slice(n, 2 * n); // y: [y1, y2, ..., yn] let ans = [], t = 0; while (t &lt; n) &#123; ans.push(x[t]); ans.push(y[t]); // ans: [x1, y1, ..., xn, yn] t++; &#125; return ans;&#125;; 总结暴力模拟 别人的代码：12345678910var shuffle = function(nums, n) &#123; let xArr = nums.slice(0, n); let yArr = nums.slice(n, nums.length); let result = []; xArr.forEach((item, index) =&gt; &#123; result.push(item); result.push(yArr[index]); &#125;); return result;&#125;; 思想其实差不多，主要是这个 forEach，速度好像比较快 Array.prototype.forEach() 方法对数组的每个元素执行一次给定的函数。 语法1arr.forEach(callback(currentValue [, index [, array]])[, thisArg]) callback 为数组中每个元素执行的函数，该函数接收一至三个参数： currentValue 数组当前项的值 index 数组当前项的索引 array 数组对象本身 thisArg 可选 如果 thisArg 参数有值，则每次 callback 函数被调用时，this 都会指向 thisArg 参数 如果省略了 thisArg 参数，或者其值为 null 或 undefined，this 则指向全局对象。 返回值：undefined forEach 不会直接改变调用它的对象，但是那个对象可能会被 callback 函数改变 除了抛出异常以外，没有办法中止或跳出 forEach() 循环 Array.prototype.map() map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一次提供的函数后的返回值。 语法123var new_array = arr.map(function callback(currentValue[, index[, array]]) &#123; // Return element for new_array &#125;[, thisArg]) callback 为数组中每个元素执行的函数，该函数接收一至三个参数： currentValue 数组当前项的值 index 数组当前项的索引 array 数组对象本身 thisArg 可选 如果 thisArg 参数有值，则每次 callback 函数被调用时，this 都会指向 thisArg 参数 如果省略了 thisArg 参数，或者其值为 null 或 undefined，this 则指向全局对象。 返回值：一个由原数组每个元素执行回调函数的结果组成的新数组 map不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）——这个与 forEach 是一样的 不该使用map： 不打算使用返回的新数组 没有从回调函数中返回值 forEach 和 map 区别map 生成一个新数组，forEach 则没有 二者均不修改数组，但在回调函数里的修改会同步到原数组 所以区别只有是否返回新的数组 如果同时需要原数组&amp;新数组——map 如果不需要原数组——forEach T2代码123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; arr * @param &#123;number&#125; k * @return &#123;number[]&#125; */var getStrongest = function(arr, k) &#123; arr.sort((a, b) =&gt; a - b); // 将数组 arr 从小到大排序 let n = arr.length; let m = arr[parseInt((n-1)/2)]; // m: 数组中位数 let tmp = []; // tmp: 临时数组，用于统计 每个元素与中位数的距离，即 |arr[i] - m| for (let i = 0; i &lt; n; i++) &#123; tmp.push(&#123; val: arr[i], // val: 数组元素 dis: Math.abs(arr[i] - m) // dis: 当前元素与中位数的距离 &#125;); &#125; tmp.sort((a, b) =&gt; &#123; // 将 tmp 排序（根据题目的值强弱排序） if (a.dis === b.dis) &#123; // 若 dis 相等 return b.val - a.val; // 根据 val 从大到小排序 &#125; return b.dis - a.dis; // 否则根据 dis 从大到小排序 &#125;); let ans = tmp.map(obj =&gt; &#123; // 将 tmp 中的 val 抽离出来，赋值到 ans（抛弃 dis） return obj.val; &#125;) return ans.slice(0, k); // 取前 k 位&#125;; 总结暴力模拟，排序 别人的代码：12345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; arr * @param &#123;number&#125; k * @return &#123;number[]&#125; */var getStrongest = function(arr, k) &#123; let len = arr.length, midIndex = Math.floor((len - 1) / 2); let other = [...arr].sort((a, b) =&gt; a - b); let m = other[midIndex]; arr.sort((a, b) =&gt; &#123; if ( Math.abs(a - m) &gt; Math.abs(b - m) || (Math.abs(a - m) == Math.abs(b - m) &amp;&amp; a &gt; b) ) &#123; // a 比 b 强 return -1; &#125; else &#123; return 1; &#125; &#125;); return arr.slice(0, k);&#125;;作者：ignore_express链接：https://leetcode-cn.com/problems/the-k-strongest-values-in-an-array/solution/js-by-ignore_express-4/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 感觉大家的思路也都差不多……但是别人的写法就是效率比较高（摔 Array.prototype.sort() 用原地算法对数组的元素进行排序，并返回数组 默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的 数字：11 &lt; 2 大小写：’Banana’ &lt; ‘cherry’ 语法1arr.sort([compareFunction(a, b)]) compareFunction 可选 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 返回值：排序后的数组。请注意：数组已原地排序 T3代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @param &#123;string&#125; homepage */var BrowserHistory = function(homepage) &#123; this._stack = [homepage]; this._cur = 0;&#125;;/** * @param &#123;string&#125; url * @return &#123;void&#125; */BrowserHistory.prototype.visit = function(url) &#123; this._stack = this._stack.slice(0, this._cur + 1); this._stack.push(url); this._cur += 1;&#125;;/** * @param &#123;number&#125; steps * @return &#123;string&#125; */BrowserHistory.prototype.back = function(steps) &#123; this._cur = Math.max(this._cur - steps, 0); return this._stack[this._cur];&#125;;/** * @param &#123;number&#125; steps * @return &#123;string&#125; */BrowserHistory.prototype.forward = function(steps) &#123; this._cur = Math.min(this._cur + steps, this._stack.length - 1); return this._stack[this._cur];&#125;;/** * Your BrowserHistory object will be instantiated and called as such: * var obj = new BrowserHistory(homepage) * obj.visit(url) * var param_2 = obj.back(steps) * var param_3 = obj.forward(steps) */ 总结模拟，这种题目没找到好办法，面向测试用例编程 T4","categories":[],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://ziiyan.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"MDN-CSS(Cascading Style Sheets)","slug":"MDN-CSS","date":"2020-06-07T06:05:20.000Z","updated":"2020-06-09T15:36:40.672Z","comments":true,"path":"2020/06/07/MDN-CSS/","link":"","permalink":"http://ziiyan.github.io/2020/06/07/MDN-CSS/","excerpt":"","text":"CSS 工作原理 浏览器载入HTML文件（比如从网络上获取）。 将HTML文件转化成一个DOM（Document Object Model）。 接下来，浏览器会拉取该HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理。 浏览器拉取到CSS之后会进行解析，根据选择器的不同类型（比如element、class、id等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id选择器等）应用在对应的DOM的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。 上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。 网页展示在屏幕上（这一步被称为着色）。 冲突规则层叠 同级，后面 &gt; 前面 优先级 千位： 如果声明在 style 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。 百位： 选择器中包含ID选择器则该位得一分。 十位： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。 个位：选择器中包含元素、伪元素选择器则该位得一分。 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。 !important 覆盖普通规则的层叠 继承 有些属性可以被继承，有些不行 控制继承，所有属性都可以取以下三个值 inherit 开启继承 initial 不继承 unset 自然继承 选择器 选择器 示例 学习CSS的教程 类型选择器 h1 { } 类型选择器 通配选择器 * { } 通配选择器 类选择器 .box { } 类选择器 ID选择器 #unique { } ID选择器 标签属性选择器 a[title] { } 标签属性选择器 伪类选择器 p:first-child { } 伪类 伪元素选择器 p::first-line { } 伪元素 后代选择器 article p 后代运算符 子代选择器 article &gt; p 子代选择器 相邻兄弟选择器 h1 + p 相邻兄弟 通用兄弟选择器 h1 ~ p 通用兄弟 盒模型外部显示类型块级 display: block 每个盒子都会换行 width 和 height 属性可以发挥作用 padding、margin、border 会将其他元素从当前盒子周围“推开” 盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽 内联 display: inline 盒子不会产生换行 width 和 height 属性将不起作用 垂直方向的padding、margin、border会被应用但是不会把其他处于 inline 状态的盒子推开 水平方向的padding、margin、border会被应用而且也会把其他处于 inline 状态的盒子推开 中间状态 display: inlin-block 不会换行 设置width 和height 属性会生效。 padding, margin, 以及border 会推开其他元素。 内部显示类型 flex grid 盒模型 Content box: 这个区域是用来显示内容 Padding box: 包围在内容区域外部的空白区域 不可以为负数 Border box: 边框盒包裹内容和内边距 Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域 可以为负数 注意外边距折叠 标准盒模型 box-sizing: content-box width 和 height 包含 content box 替代（IE）盒模型 box-sizing: border-box width 和 height 包含 content box、padding box、border box 溢出块级排版上下文（Block Formatting Context，BFC）CSS 的值数字，长度和百分比绝对长度单位 单位 名称 cm 厘米 mm 毫米 Q 四分之一毫米 in 英寸 pc 十二点活字 pt 点 px 像素 相对长度单位 单位 相对于 em 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width ex 字符“x”的高度 ch 数字“0”的宽度 rem 根元素的字体大小 lh 元素的line-height vw 1vw 视窗宽度的1% vh 1vh 视窗高度的1% vmin 1vmin 视窗较小尺寸的1% vmax 1vmax 视图大尺寸的1% ems and rems em 父元素字体大小 rem 根元素字体大小 颜色图片位置字符串和标识符函数编码风格方法论OOCSSBEM BEM 块级元素修饰字符（Block Element Modifier） SASS Sass（Syntactically Awesome StyleSheets）严格缩进 Scss（Sassy CSS）兼容 css 的 sass 定义变量原生css也可以 布局正常布局流（默认）覆盖默认布局 display block、inline、inline-block 是正常布局流 其他（如 grid、flex）不是 浮动 float position 默认 static，正常布局流 表格布局 display: table 多列布局 弹性盒子（Flexbox） 一维 display: flex 直接子元素会按照flex进行布局 网格（Grid） 二维 display: grid 浮动（float） 从正常布局流(normal flow)中移除 其他内容会在这个被设置浮动的元素周围环绕 清除浮动 clear left：停止任何活动的左浮动 right：停止任何活动的右浮动 both：停止任何活动的左右浮动 定位（position）static 将元素放在文档布局流的默认位置 relative 相对于元素在正常的文档流中的位置移动它 absolute 将元素完全从页面的正常布局流中移出，类似将它单独放在一个图层中 相对于该元素的最近被定位祖先元素 fixed 相对浏览器视口固定 sticky 让元素先保持和position: static一样的定位 当它的相对视口位置达到某一个预设值时，像position: fixed一样定位 CSS 表格布局（table）##多列布局 column-count column-width column-gap column-rule 响应式设计 RWD，responsive web design（允许Web页面适应不同屏幕宽度因素等，进行布局和外观的调整） 媒体查询123@media media-type and (media-feature-rule) &#123; /* CSS rules go here */&#125; 一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的（例如印刷品或者屏幕） all print screen speech 一个媒体表达式，是一个被包含的CSS生效所需的规则或者测试 宽和高 朝向 orientation portrait landscape hover pointer 一组CSS规则，会在测试通过且媒体类型正确的时候应用 媒体查询匹配逻辑：与/或/非 移动优先设计：为窄屏设备（例如移动设备）创建一个简单的单栏布局，然后检查是否是大些的屏幕，在你知道你有足够容纳的屏幕宽度的时候，开始采用一种多栏的布局 灵活网格 每个元素都有一个作为宽度的百分数，而且确保整个布局的和不会超过100% 现代布局技术多列布局flexGrid响应式图像 &lt;picture&gt; &lt;img&gt; srcset sizes 响应式排版 通过媒体查询改变字体大小 使用视口单位实现响应式排版 视口元标签1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; 移动端浏览器因此会把视口宽度设为960像素，并以这个宽度渲染页面 用设备的实际宽度 device-width 覆写了默认的 width=960px @规则 @charset, 定义样式表使用的字符集. @import, 告诉 CSS 引擎引入一个外部样式表. @namespace, 告诉 CSS 引擎必须考虑XML命名空间。 嵌套@规则, 是嵌套语句的子集,不仅可以作为样式表里的一个语句，也可以用在条件规则组里： @media, 如果满足媒介查询的条件则条件规则组里的规则生效。 @page, 描述打印文档时布局的变化. @font-face, 描述将下载的外部的字体。 @keyframes, 描述 CSS 动画的中间步骤 . @supports, 如果满足给定条件则条件规则组里的规则生效。 @document, 如果文档样式表满足给定条件则条件规则组里的规则生效。 (推延至 CSS Level 4 规范)","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ziiyan.github.io/tags/CSS/"}]},{"title":"MDN-HTML","slug":"MDN-HTML","date":"2020-06-04T13:42:32.000Z","updated":"2020-06-09T15:36:33.130Z","comments":true,"path":"2020/06/04/MDN-HTML/","link":"","permalink":"http://ziiyan.github.io/2020/06/04/MDN-HTML/","excerpt":"","text":"语义为什么需要结构化 用户经常只阅读开头的标题 SEO 屏幕阅读器 为什么需要语义 SEO 屏幕阅读器 语义化标签标题/段落 &lt;h1&gt; ~ &lt;h6&gt; &lt;p&gt; 最好只对每个页面使用一次 列表 Lists 无序 &lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序 &lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 嵌套列表12345678910&lt;ol&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt; &lt;ul&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ol&gt; 强调 &lt;em&gt; &lt;strong&gt; 表象元素（没有语义） &lt;i&gt; 被用来传达传统上用斜体表达的意义：外国文字，分类名称，技术术语，一种思想…… &lt;b&gt; 被用来传达传统上用粗体表达的意义：关键字，产品名称，引导句…… &lt;u&gt;被用来传达传统上用下划线表达的意义：专有名词，拼写错误…… 描述列表 &lt;dl&gt; description list - 描述列表 &lt;dt&gt; description term - 描述术语 &lt;dd&gt; description description - 描述列表的描述部分 dt 与 dd 之间有缩进 引用 块引用 &lt;blockquote cite=&quot;http://xxx...&quot;&gt; cite 不显示 行内引用 &lt;q cite=&quot;http://xxx...&quot;&gt; cite 不显示 引文 &lt;cite&gt;MDN&lt;/cite&gt; 斜体，显示在页面上 缩略语 &lt;abbr title=&quot;全称&quot;&gt;缩写&lt;/abbr&gt; 上标/下标 &lt;sub&gt; &lt;sup&gt; 构建内容 &lt;header&gt;页眉 &lt;nav&gt; 导航栏 &lt;main&gt; 主内容，存放每个页面独有的内容。每个页面上只能用一次 &lt;main&gt;，且直接位于&lt;body&gt; 中。最好不要把它嵌套进其它元素。 &lt;article&gt; 包围的内容即一篇文章，与页面其它部分无 &lt;section&gt; &lt;div&gt; &lt;aside&gt; 侧边栏，嵌套在 &lt;main&gt; 中 &lt;footer&gt; 换行水平分割线 &lt;br&gt; &lt;hr&gt; 段落级元素之间的主题转换 无语义（少用） &lt;div&gt; &lt;span&gt; 代码 &lt;code&gt; 用于标记计算机通用代码。 &lt;pre&gt; 用于保留空白字符（通常用于代码块） &lt;var&gt;用于标记具体变量名。 &lt;kbd&gt; 用于标记输入电脑的键盘（或其他类型）输入。 &lt;samp&gt; 用于标记计算机程序的输出。 时间 &lt;time datetime=&quot;&quot;&gt; 说明文字 &lt;figure&gt; &lt;figcaption&gt; 1234&lt;figure&gt; &lt;img src=\"...\" /&gt; &lt;figcaption&gt;描述说明&lt;/figcaption&gt;&lt;/figure&gt; HTML元素参考 超链接 尽可能使用相对链接 首先，检查代码要容易得多——相对URL通常比绝对URL短得多，这使得阅读代码更容易。 其次，在可能的情况下使用相对URL更有效。 当使用绝对URL时，浏览器首先通过DNS查找服务器的真实位置，然后再转到该服务器并查找所请求的文件。另一方面，相对URL，浏览器只在同一服务器上查找被请求的文件。 因此，如果你使用绝对URL而不是相对URL，你就会不断地让你的浏览器做额外的工作，这意味着它的效率会降低。 多媒体&amp;嵌入 &lt;video&gt; 视频 &lt;resource src=&quot;xxx&quot; type=&quot;video/mp4&quot;&gt; 没有 type 会顺序尝试加载 &lt;video&gt; 中多个 &lt;resource&gt; ，播放第一个匹配的源 &lt;audio&gt; 音频 &lt;iframe&gt; sandbox 提高安全性 &lt;embed&gt;、&lt;object&gt; 少用 Iframe - 安全问题 黑客利用 iframe 嵌入交互组件，例如按钮、表单，诱导用户点击 只在有必要时嵌入 使用 HTTPS HTTPS减少了远程内容在传输过程中被篡改的机会， HTTPS防止嵌入式内容访问您的父文档中的内容，反之亦然。 始终使用sandbox属性 配置CSP指令 svg 位图使用像素网格来定义 — 一个位图文件精确得包含了每个像素的位置和它的色彩信息。流行的位图格式包括 Bitmap (.bmp), PNG (.png), JPEG (.jpg), and GIF (.gif.) 矢量图使用算法来定义 — 一个矢量图文件包含了图形和路径的定义，电脑可以根据这些定义计算出当它们在屏幕上渲染时应该呈现的样子。 img优点 快速，熟悉的图像语法与alt属性中提供的内置文本等效。 可以通过在``元素嵌套&lt;img&gt;，使图像轻松地成为超链接。 缺点 无法使用JavaScript操作图像。 如果要使用CSS控制SVG内容，则必须在SVG代码中包含内联CSS样式。 （从SVG文件调用的外部样式表不起作用） 不能用CSS伪类来重设图像样式（如:focus）。 代码优点 将 SVG 内联减少 HTTP 请求，可以减少加载时间。 您可以为 SVG 元素分配class和id，并使用 CSS 修改样式，无论是在SVG中，还是 HTML 文档中的 CSS 样式规则。 实际上，您可以使用任何 SVG外观属性 作为CSS属性。 内联SVG是唯一可以让您在SVG图像上使用CSS交互（如:focus）和CSS动画的方法（即使在常规样式表中）。 您可以通过将 SVG 标记包在``元素中，使其成为超链接。 缺点 这种方法只适用于在一个地方使用的SVG。多次使用会导致资源密集型维护（resource-intensive maintenance）。 额外的 SVG 代码会增加HTML文件的大小。 浏览器不能像缓存普通图片一样缓存内联SVG。 您可能会在`` 元素中包含回退，但支持 SVG 的浏览器仍然会下载任何后备图像。你需要考虑仅仅为支持过时的浏览器，而增加额外开销是否真的值得。 iframe 不建议 缺点 如你所知， iframe有一个回退机制，如果浏览器不支持iframe，则只会显示回退。 此外，除非 SVG 和您当前的网页具有相同的 origin，否则你不能在主页面上使用 JavaScript 来操纵 SVG。 响应式图片 &lt;img&gt; srcset 属性 sizes 属性 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;&lt;/meta&gt; 这行代码会强制地让手机浏览器采用它们真实可视窗口的宽度来加载网页 &lt;picture&gt; &lt;source&gt; &lt;img&gt; 为什么不用 CSS 或 JavaScript 来做响应式？ 性能问题：先加载 HTML，再用 JavaScript 检测可视窗口的宽度，如果不合适再加载图片替换已经加载的图片。 表格 &lt;colgroup&gt; &lt;col&gt; &lt;caption&gt; 表格标题 scope 行/列标题 id header","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://ziiyan.github.io/tags/HTML/"}]},{"title":"三种主流的Web服务实现方案(REST+SOAP+RPC)","slug":"三种主流的Web服务实现方案-REST-SOAP-XML-RPC","date":"2020-06-03T14:27:52.000Z","updated":"2020-07-27T09:21:30.582Z","comments":true,"path":"2020/06/03/三种主流的Web服务实现方案-REST-SOAP-XML-RPC/","link":"","permalink":"http://ziiyan.github.io/2020/06/03/%E4%B8%89%E7%A7%8D%E4%B8%BB%E6%B5%81%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88-REST-SOAP-XML-RPC/","excerpt":"","text":"RPC Remote recedure call，远程过程调用 像调用本地服务（方法）一样调用服务器的服务（方法） SOAP Simple Object Access Protocol，简单对象访问协议 REST Representation State Transfer，表现层状态转移 Resource Representation State Transfer 资源在网络中以某种表现形式进行状态转移 Resource：资源，即数据（前面说过网络的核心）。比如 newsfeed，friends等 Representational：某种表现形式，比如用JSON，XML，JPEG等 State Transfer：状态变化。通过HTTP动词实现 看 url 就知道要什么看 http method 就知道干什么看 http status code 就知道结果如何 用URL定位资源，用HTTP描述操作","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://ziiyan.github.io/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"剑指 offer：45.把数组排成最小的数","slug":"剑指 offer：45-把数组排成最小的数","date":"2020-05-28T13:35:18.000Z","updated":"2020-07-27T11:44:31.568Z","comments":true,"path":"2020/05/28/剑指 offer：45-把数组排成最小的数/","link":"","permalink":"http://ziiyan.github.io/2020/05/28/%E5%89%91%E6%8C%87%20offer%EF%BC%9A45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/","excerpt":"","text":"题目输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 提示: 0 &lt; nums.length &lt;= 100说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路自定义排序 ab &lt; ba 则 [a, b] ab &gt; ba 则 [b, a] 不知道规律大概想破脑袋也想不出来？ 代码1234567/** * @param &#123;number[]&#125; nums * @return &#123;string&#125; */var minNumber = function(nums) &#123; return nums.sort((a, b) =&gt; (a+''+b) - (b+''+a)).join('');&#125;; 总结 JavaScript sort 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 JavaScript join 把数组中的所有元素放入一个字符串 参数为要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。","categories":[],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://ziiyan.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"剑指 offer：59-I.滑动窗口的最大值","slug":"剑指 offer：59-I-滑动窗口的最大值","date":"2020-05-27T15:52:18.000Z","updated":"2020-07-27T11:44:35.574Z","comments":true,"path":"2020/05/27/剑指 offer：59-I-滑动窗口的最大值/","link":"","permalink":"http://ziiyan.github.io/2020/05/27/%E5%89%91%E6%8C%87%20offer%EF%BC%9A59-I-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","excerpt":"","text":"题目给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 提示： 你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路写法有点暴力……效率比较差 Array.slice(i, j)截取子数组 Array[i~j]，Math.max(...Array) 取最大 代码1234567891011121314/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number[]&#125; */var maxSlidingWindow = function(nums, k) &#123; if (nums.length === 0) return []; let ans = []; for (let i = 0; i &lt;= nums.length - k; i++) &#123; let tmp = nums.slice(i, i+k); ans.push(Math.max(...tmp)); &#125; return ans;&#125;; 总结 Array.slice(i, j) 扩展运算符 ...","categories":[],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://ziiyan.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"剑指 offer：59-II.队列的最大值","slug":"剑指 offer：59-II-队列的最大值","date":"2020-05-27T15:42:18.000Z","updated":"2020-07-27T11:44:44.350Z","comments":true,"path":"2020/05/27/剑指 offer：59-II-队列的最大值/","link":"","permalink":"http://ziiyan.github.io/2020/05/27/%E5%89%91%E6%8C%87%20offer%EF%BC%9A59-II-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","excerpt":"","text":"题目请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 限制： 1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 100001 &lt;= value &lt;= 10^5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路维护一个单调递减的队列 maxx。 value 入队时，检查 maxx 尾部，小于当前 value 的元素全部出栈。 入队 4 queue 4 maxx 4 入队 2 queue 4 2 maxx 4 2 入队 3 queue 4 2 3 maxx 4 3 出队 queue 2 3 maxx 3 可以保证 maxx 队首的始终是 queue 中的最大值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var MaxQueue = function() &#123; this.queue = []; this.maxx = [];&#125;;/** * @return &#123;number&#125; */MaxQueue.prototype.max_value = function() &#123; if (this.maxx.length) &#123; return this.maxx[0]; &#125; return -1;&#125;;/** * @param &#123;number&#125; value * @return &#123;void&#125; */MaxQueue.prototype.push_back = function(value) &#123; this.queue.push(value); while (this.maxx.length &amp;&amp; this.maxx[this.maxx.length-1] &lt; value) &#123; this.maxx.pop(); &#125; this.maxx.push(value);&#125;;/** * @return &#123;number&#125; */MaxQueue.prototype.pop_front = function() &#123; if (this.queue.length) &#123; let cur = this.queue.shift(); if (cur === this.maxx[0]) &#123; this.maxx.shift(); &#125; return cur; &#125; return -1;&#125;;/** * Your MaxQueue object will be instantiated and called as such: * var obj = new MaxQueue() * var param_1 = obj.max_value() * obj.push_back(value) * var param_3 = obj.pop_front() */ 总结联动 包含min函数的栈","categories":[],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://ziiyan.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"剑指 offer：30. 包含min函数的栈","slug":"剑指 offer：30-包含min函数的栈","date":"2020-05-27T15:14:18.000Z","updated":"2020-07-27T11:44:13.546Z","comments":true,"path":"2020/05/27/剑指 offer：30-包含min函数的栈/","link":"","permalink":"http://ziiyan.github.io/2020/05/27/%E5%89%91%E6%8C%87%20offer%EF%BC%9A30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","excerpt":"","text":"题目定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 提示： 各函数的调用总次数不超过 20000 次 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路维护一个单调递减的栈 minn，保证当前 stack 中的最小值始终保持在 minn 的末尾（栈顶） stack出栈的时候检查是否是最小值（即等于minn 栈顶元素） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * initialize your data structure here. */var MinStack = function() &#123; this.minn = []; this.stack = [];&#125;;/** * @param &#123;number&#125; x * @return &#123;void&#125; */MinStack.prototype.push = function(x) &#123; this.stack.push(x); if (!this.minn.length) &#123; this.minn.push(x); &#125; else if (x &lt;= this.minn[this.minn.length-1]) &#123; this.minn.push(x); &#125;&#125;;/** * @return &#123;void&#125; */MinStack.prototype.pop = function() &#123; let t = this.stack.pop(); if (t === this.minn[this.minn.length-1]) &#123; this.minn.pop(); &#125; return t;&#125;;/** * @return &#123;number&#125; */MinStack.prototype.top = function() &#123; return this.stack[this.stack.length-1];&#125;;/** * @return &#123;number&#125; */MinStack.prototype.min = function() &#123; return this.minn[this.minn.length-1];&#125;;/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.min() */ 总结联动 队列的最大值","categories":[],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://ziiyan.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"剑指 offer：09. 用两个栈实现队列","slug":"剑指 offer：09-用两个栈实现队列","date":"2020-05-27T15:06:18.000Z","updated":"2020-07-27T11:44:11.483Z","comments":true,"path":"2020/05/27/剑指 offer：09-用两个栈实现队列/","link":"","permalink":"http://ziiyan.github.io/2020/05/27/%E5%89%91%E6%8C%87%20offer%EF%BC%9A09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","excerpt":"","text":"题目用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 提示： 1 &lt;= values &lt;= 10000最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路stack1 负责入队，保证入队顺序。要么为空，要么是正确的队列顺序。 stack2 负责出队，保证出队顺序。要么为空，要么是逆序的队列顺序。 代码123456789101112131415161718192021222324252627282930313233var CQueue = function() &#123; this.stack1 = []; this.stack2 = [];&#125;;/** * @param &#123;number&#125; value * @return &#123;void&#125; */CQueue.prototype.appendTail = function(value) &#123; while (this.stack2.length) &#123; this.stack1.push(this.stack2.pop()) &#125; this.stack1.push(value) return null;&#125;;/** * @return &#123;number&#125; */CQueue.prototype.deleteHead = function() &#123; while (this.stack1.length) &#123; this.stack2.push(this.stack1.pop()) &#125; return this.stack2.length ? this.stack2.pop() : -1&#125;;/** * Your CQueue object will be instantiated and called as such: * var obj = new CQueue() * obj.appendTail(value) * var param_2 = obj.deleteHead() */ 总结 水题","categories":[],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://ziiyan.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"Vue预渲染实战-prerender-spa-plugin","slug":"Vue预渲染实战","date":"2020-05-27T03:17:16.000Z","updated":"2020-05-27T12:11:15.795Z","comments":true,"path":"2020/05/27/Vue预渲染实战/","link":"","permalink":"http://ziiyan.github.io/2020/05/27/Vue%E9%A2%84%E6%B8%B2%E6%9F%93%E5%AE%9E%E6%88%98/","excerpt":"","text":"前言官网需要 SEO，看了下方案觉得预渲染比较合适 界面少 弱交互 服务器端渲染 vs 预渲染 (SSR vs Prerendering) 如果你调研服务器端渲染 (SSR) 只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。 如果你使用 webpack，你可以使用 prerender-spa-plugin 轻松地添加预渲染。它已经被 Vue 应用程序广泛测试 - 事实上，作者是 Vue 核心团队的成员。 What is Prerendering? Recently, SSR (Server Side Rendering) has taken the JavaScript front-end world by storm. The fact that you can now render your sites and apps on the server before sending them to your clients is an absolutely revolutionary idea (and totally not what everyone was doing before JS client-side apps got popular in the first place…) However, the same criticisms that were valid for PHP, ASP, JSP, (and such) sites are valid for server-side rendering today. It’s slow, breaks fairly easily, and is difficult to implement properly. Thing is, despite what everyone might be telling you, you probably don’t need SSR. You can get almost all the advantages of it (without the disadvantages) by using prerendering. Prerendering is basically firing up a headless browser, loading your app’s routes, and saving the results to a static HTML file. You can then serve it with whatever static-file-serving solution you were using previously. It just works with HTML5 navigation and the likes. No need to change your code or add server-side rendering workarounds. In the interest of transparency, there are some use-cases where prerendering might not be a great idea. Tons of routes - If your site has hundreds or thousands of routes, prerendering will be really slow. Sure you only have to do it once per update, but it could take ages. Most people don’t end up with thousands of static routes, but just in-case… Dynamic Content - If your render routes that have content that’s specific to the user viewing it or other dynamic sources, you should make sure you have placeholder components that can display until the dynamic content loads on the client-side. Otherwise it might be a tad weird. 三种不同渲染方式的区别 客户端渲染：用户访问 url -&gt; 请求 html 文件 -&gt; 加载 css/js -&gt; 前端动态渲染页面内容 性能消耗在客户端 服务端渲染：用户访问 url -&gt; 服务端根据访问路径请求所需数据 -&gt; 拼接成 html -&gt; 返回给前端 网络传输数据量大 预渲染：构建阶段生成匹配预渲染路径的 html 文件 -&gt; 用户访问 url -&gt; 返回 html 给前端 构建出来的 html 文件已经有静态数据，需要ajax数据的部分未构建 原理 puppeteer是谷歌出品的一个插件，可以完成很多的操作，广泛使用在爬虫、测试自动化等浏览器自动化方向的应用，而prerender-spa-plugin这个插件正是依赖puppeteer操作chromium这个真正的浏览器内核对SPA跑了一遍，生成一个静态的HTML，里面是已经填好的dom节点和数据，就是这么简单粗暴，为了给用户直接返回有内容的xhtml文档，提前在一个浏览器里跑了一遍，生成了跑过js和css之后index.html(跟路由)和其他文档。这样的话有两个缺陷，第一个：无法展示用户自身的内容，第二个：不适合动态路由多的大型项目。 作者：mguy_1链接：https://juejin.im/post/5c125787f265da611d668807来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 安装1yarn install prerender-spa-plugin --save 配置123456// router.jsconst router = new VueRouter(&#123; mode: 'history', base: process.env.BASE_URL, routes&#125;) 1234567891011121314151617// vue.config.jsconst PrerenderSPAPlugin = require('prerender-spa-plugin');const Renderer = PrerenderSPAPlugin.PuppeteerRenderer;module.exports = &#123; configureWebpack: &#123; …… plugins: [ new PrerenderSPAPlugin(&#123; // 输出路径 staticDir: path.join(__dirname, 'dist'), // 需要预渲染的路由 routes: ['/'] &#125;) ] &#125;&#125; 后记配置还是比较简单，坑点是 prerender-spa-plugin 安装超级慢。官方源和淘宝源换来换去 / 科学上网开开关关，折腾了半天才下好。 都说大量路由不适合用预渲染，但实际上主要是构建过程比较慢，似乎对用户来说没什么区别？","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://ziiyan.github.io/tags/Vue/"},{"name":"浏览器","slug":"浏览器","permalink":"http://ziiyan.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"web性能权威指南-网络技术概览","slug":"web性能权威指南-网络技术概览","date":"2020-05-27T02:48:02.000Z","updated":"2020-06-09T15:36:51.827Z","comments":true,"path":"2020/05/27/web性能权威指南-网络技术概览/","link":"","permalink":"http://ziiyan.github.io/2020/05/27/web%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/","excerpt":"","text":"第1章 延迟与带宽 延迟 ：分组从信息源发送到目的地所需的时间 带宽 ：逻辑或物理通信路径最大的吞吐量 延迟的构成 延迟是消息（ message）或分组（packet）从起点到终点经历的时间。 路由器 传播延迟：消息从发送端到接收端需要的时间 传输延迟：消息中的所有比特转移到链路中需要的时间 处理延迟：处理分组首部、检查位错误及确定分组目标所需的时间 排队延迟：到来的分组排队等待处理的时间 -&gt; 缓冲区爆满 传播延迟 CDN（Content Delivery Network，内容分发网络） 把内容部署在全球各地，让用户从最近的服务器加载内容，大幅降低传播分组的时间。 大多数网站性能的瓶颈都是延迟，而不是宽带。 第2章 TCP的构成因特网两个核心协议： IP（Internet Protocol，因特网协议） 负责联网主机之间的路由选择和寻址 TCP（Transmission Control Protocol，传输控制协议） 负责在不可靠的传输信道之上提供可靠的抽象层 TCP/IP 常被称为 “因特网协议套件”（Internet Protocol Suite） 三次握手客户端与服务器在交换应用数据之前，必须就起始分组序列号，以及其他一些连接相关的细节达成一致，出于安全考虑，序列号由两端随机生成。 SYN（synchronous） 客户端选择一个随机序列号 x，并发送一个 SYN 分组，其中可能还包括其他 TCP 标志和选项 SYN ACK 服务器给 x 加 1，并选择自己的一个随机序列号 y，追加自己的标志和选项，返回响应 ACK（acknowledgement） 客户端给 x 和 y 加 1 并发送握手期间的最后一个 ACK 分组 客户端可以在发送ACK分组之后立即发送数据，而服务器必须等接收到ACK分组之后才能发送数据。 三次握手带来的延迟使得每创建一个新TCP连接都要付出很大代价。而这也决定了提高TCP应用性能的关键，在于想办法重用连接。 拥塞预防及控制流量控制 流量控制是一种预防发送端过多向接收端发送数据的机制 为实现流量控制，TCP 连接的每一方都要通告自己的接收窗口（rwnd），其中包含能够保存数据的缓冲区空间大小信息 第一次建立连接时，两端都会使用自身系统的默认设置来发送rwnd 如果其中一端跟不上数据传输，那它可以向发送端通告一个较小的窗口 这个过程贯穿于每个TCP连接的整个生命周期： 每个ACK分组都会携带相应的最新rwnd值，以便两端动态调整数据流速，使之适应发送端和接收端的容量及处理能力 慢启动 服务器通过TCP连接初始化一个新的拥塞窗口（cwnd）变量，将其值设置为一个系统设定的保守值 客户端与服务器之间最大可以传输（未经ACK确认的）数据量取rwnd和cwnd变量中的最小值 慢启动限制了可用的吞吐量，这对于小文件传输非常不利 拥塞预防 TCP调节性能主要依赖丢包反馈机制。 拥塞预防算法把丢包作为网络拥塞的标志 即路径中某个连接或路由器已经拥堵了，以至于必须采取删包措施 必须调整窗口大小，以避免造成更多的包丢失，从而保证网络畅通 重置拥塞窗口后，拥塞预防机制按照自己的算法来增大窗口以尽量避免丢包。 宽带延迟积第3章 UDP的构成第4章 传输层安全（TLS）","categories":[],"tags":[{"name":"性能","slug":"性能","permalink":"http://ziiyan.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"网络","slug":"网络","permalink":"http://ziiyan.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"剑指 offer：38.字符串的排列","slug":"剑指 offer：38-字符串的排列","date":"2020-05-25T15:42:18.000Z","updated":"2020-07-27T11:44:22.476Z","comments":true,"path":"2020/05/25/剑指 offer：38-字符串的排列/","link":"","permalink":"http://ziiyan.github.io/2020/05/25/%E5%89%91%E6%8C%87%20offer%EF%BC%9A38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","excerpt":"","text":"题目输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 限制： 1 &lt;= s 的长度 &lt;= 8 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路字符串 &quot;abc&quot; ，作为数组 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]，对数组[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 的元素进行全排列，去重。 vis 标记数组对应位置是否已经使用过。 递归，每次在数组中选择一个未使用的字符放入临时字符串。 递归出口：临时字符串长度 = 输入字符串长度。 采用 Set 去重。 代码123456789101112131415161718192021222324/** * @param &#123;string&#125; s * @return &#123;string[]&#125; */var permutation = function(s) &#123; let len = s.length; let vis = new Array(len).fill(false); const dfs = function (ans, str) &#123; if (str.length === len) &#123; ans.add(str); return; &#125; for (let i = 0; i &lt; len; i++) &#123; if (!vis[i]) &#123; vis[i] = true; dfs(ans, str+s[i]); vis[i] = false; &#125; &#125; &#125; let ans = new Set(); dfs(ans, ''); return [...ans];&#125;; 总结排列 🔗 回溯 set 用法 add() 添加元素 扩展运算符 ... […Set] ===&gt; Array","categories":[],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://ziiyan.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"PWA入门","slug":"PWA入门","date":"2020-05-23T09:30:58.000Z","updated":"2020-06-02T04:32:57.669Z","comments":true,"path":"2020/05/23/PWA入门/","link":"","permalink":"http://ziiyan.github.io/2020/05/23/PWA%E5%85%A5%E9%97%A8/","excerpt":"","text":"PWA 基本介绍PWA 是什么Progressive Web App，渐进式 Web 应用，提升 Web App 体验的方法，给用户原生用户的体验。https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps PWA 的优势 渐进式 - 适用于所有浏览器，不影响原 Web App 功能 流畅 - 借助 Wervice Worker 在离线或者网络较差的情况下正常访问 可安装 - 用户可以添加常用的 webapp 到桌面，免去应用商店下载的麻烦 原生体验 - 和 app 一样，拥有首屏加载动画，可以隐藏地址栏等沉浸式体验 粘性 - 通过推送离线通知等，可以让用户回流 PWA 核心技术揭秘web app manifest：应用程序清单https://developer.mozilla.org/zh-CN/docs/Web/Manifest 基本介绍 web app manifest 是 PWA 技术集合的一部分 web app manifest 可以让网站安装到设备的主屏幕，而不需要用户通过应用商店进行下载 web app manifest，在一个 JSON 文本文件中提供有关应用程序的信息（如名称、作者、图标和描述） 传统的 web app 入口： 网址 书签，收藏夹 直接搜索 Web app manifest 可以添加到桌面，有唯一的图标和名称 有启动时界面，避免生硬的过渡 隐藏浏览器相关的 UI，比如地址栏等 使用步骤 项目根目录下创建一个 manifes.json 文件 在 index.html 中引入 manifes.json 文件 1&lt;link rel=\"manifest\" href=\"manifest.json\" /&gt; 在 manifest.json 文件中提供常见的配置 需要在 https 协议或 http://localhost 下访问项目 常见配置 name 应用的名称 用户安装横幅提示的名称 启动画面中的文字 short_name 应用的短名称 主屏幕显示 start_url 设备启动应用程序时加载的 url 绝对路径 / 相对路径 icons：图标对象数组 一般配 144x144 background_color：启动动画的背景颜色 theme_color：应用程序的主题颜色 display：app 显示模式 fullscreen standalone minimal-ui service worker 一个标准的 PWA 程序，必须包含 3 个部分 https 服务器或者 http://localhost manifest.json service worker W3C 组织在 14 年 5 月提出 service worker 这样一个 HTML5 API，主要用来做持久的离线缓存 前端有很多性能优化手段（必须联网） CDN CSS Sprite 文件的合并压缩 异步加载 资源缓存 service worker 允许 web 应用在网络环境比较差或者是离线的环境下依旧可以使用 service worker 可以极大的提升 web app 的用户体验 service worker 是一个独立的 worker 线程，独立于当前网页进程，是一种特殊的 web worker web worker简介 浏览器中的 JavaScript 都是运行在一个单一主线程上的，在同一时间内只能做一件事 随着 web 业务不断复杂，逐渐在 JavaScript 中加了很多复杂运算过程，如果在主线程中计算，会造成性能问题 W3c 提供 web worker 的 API，web worker 脱离在主线程之外，将复杂的功能独立于主线程 完成后通过 postMessage 方法告诉主线程 web worker 是一个独立的运行环境，不能操作 DOM 和 BOM 使用 创建 1var worker = new Worker('work.js') 执行复杂计算 通知主线程 1self.postMessage(msg) 主线程监听消息 1worker.onmessage = function(msg) &#123;&#125; service worker 基本介绍 web worker 是临时的，无法操作缓存，无法持久存储 service worker 一旦被 install，就永远存在，除非被手动 unregister 用到的时候可以直接唤醒，不用的时候自动睡眠 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态） 离线内容开发者可控 必须在 HTTPS 环境下才能工作 异步实现，内部大都是通过 Promise 实现 ![image-20200524233840196](/Users/wuziyan/Library/Application Support/typora-user-images/image-20200524233840196.png) service worker 使用步骤 在 window.onload 中注册 service worker，防止与其他资源竞争 navigator 对象中内置了 serviceWorker 属性 service worker 在老版本的浏览器中不支持，需要进行浏览器兼容 if (‘serviceWorker’ in navigator) {} 注册 service worker navigator.serviceWorker.register(‘./sw.js’)，返回一个 promise 对象 12345678910window.onload = function () &#123; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker .register('./sw.js') .then(resitration =&gt; &#123;console.log(resitration)&#125;) .catch(err =&gt; &#123; console.log(err) &#125;) &#125;&#125; service worker 生命周期事件 Install 事件 注册成功触发 用于缓存资源 activate 事件 激活时候触发 用于删除陈旧资源 fetch 事件 发送请求时候触发 用于操作缓存或者读取网络资源 sw.js 改变，install 事件重新触发 activate 事件在 install 事件后触发 但已存在 service worker 了，那么就处于等待状态，直到当前 service worker 终止 可以通过 self.skipWaiting() 方法跳过等待，返回一个 promise 对象 event.waitUnitl(promise 对象) promise 对象执行结束后才结束当前生命周期函数 防止浏览器在异步操作前停止生命周期 Service worker 激活后，会在下一次刷新页面的时候生效 可以通过 self.clients.claim() 立即获取控制权 promise 异步编程的一种解决方案，比传统方案（回调函数和事件）更合理 以链式的方式进行异步编程，解决回调地狱 常用方法 Promise.resolve() Promise.reject() Promise.all() Promise.race() async / await 使异步操作更方便 async 修饰函数，async function fn() {} await 函数返回一个 promise 对象 await 只能出现在 async 函数中，后面跟一个 promise 对象，用于获取 promise 对象成功的结果 如果不是 promise 对象，直接返回值 await 阻塞 async 函数执行 await 后面的 promise 如果没有成功，会抛出异常，需要 try…catch fetch api fetch api 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的部分 例如请求和响应 service worker 中发送请求只能用 fetch api fetch api 是基于 promise 实现的 fetch(url, config) 用于发送 http 请求，返回一个包含响应结果的 promise 对象 response 是一个二进制数据流，需要调用 json() 方法转换成 json 数据 config 常见参数 body：设置请求体 headers：设置请求头 method：设置请求方式 cache storage基本使用 cacheStorage 接口表示 Cache 对象的存储，配合 service worker 来实现资源的缓存 caches api 类似于数据库的操作 caches.open(cacheName).then(function(cache) {}) 打开缓存，返回 promise 类似连接数据库 caches.keys() 返回 promise 对象，包括所有缓存的 key 数据库名 caches.delete(key) 根据 key 删除对应缓存（数据库） cache 对象常用方法（单条数据的操作） cache 接口为缓存的 Request / Response 对象对提供存储机制 cache.put(req, res) 把请求当成 key，把对应响应存储起来 cache.add(url) 根据 url 发起请求，把响应结果存储起来 cache.addAll(urls) 抓取一个 url 数组，并且把结果存储起来 cache.match(req) 获取 req 对应的 response 离线处理 caches 中已经缓存了我们需要的静态资源 当请求失败的时候，就可以去缓存中读取对应数据 通过 event.respondWith(response) 可以控制响应的内容 notification api基本使用 notifications API 的通知接口用于向用户配置和显示桌面通知 notification.permission 可以获取当前用户的授权情况 default 未授权 denied 拒绝，无法再次请求 granted 通过 notification.requestPermission() 可以请求用户的授权 通过 new notification(‘title’, { body: ‘…’ , icon: ‘…’ }) 可以显示通知 在授权情况下，可以在 service worker 中显示通知 self.registration.showNotification(‘title’, { body: ‘msg’ })","categories":[],"tags":[{"name":"PWA","slug":"PWA","permalink":"http://ziiyan.github.io/tags/PWA/"}]},{"title":"14.Proxy","slug":"14-Proxy","date":"2020-05-08T07:31:18.000Z","updated":"2020-05-08T09:03:51.620Z","comments":true,"path":"2020/05/08/14-Proxy/","link":"","permalink":"http://ziiyan.github.io/2020/05/08/14-Proxy/","excerpt":"","text":"概述 在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截 因此提供了一种机制，可以对外界的访问进行过滤和改写 Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义 Proxy 实例的方法Proxy.revocable()this 问题实例：Web 服务的客户端","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"canvas从入门到放弃","slug":"canvas从入门到放弃","date":"2020-04-25T04:46:30.000Z","updated":"2020-07-27T09:22:14.693Z","comments":true,"path":"2020/04/25/canvas从入门到放弃/","link":"","permalink":"http://ziiyan.github.io/2020/04/25/canvas%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/","excerpt":"","text":"简介H5 新增的标签，可以用脚本（js）在其中绘制图像的 HTML 元素。 基本使用元素可以用 css 设置属性，但比例不一致会扭曲，建议直接用 width height 属性 默认 width 300 height 150 单位 px 1&lt;canvas&gt;替换内容&lt;/canvas&gt; 不支持 canvas 的浏览器会显示替换内容，尾标签不可省略 渲染上下文&lt;canvas&gt; 创建一个固定大小的画布，公开一个或多个渲染上下文（画笔），使用渲染上下文来绘制和处理要展示的内容。 主要使用 2D 上下文，WebGL 使用了基于 OpenGL ES 的 3D 上下文 检测支持特性1234567var canvas = document.getElementById('myCanvas');if (canvas.getContext) &#123; var ctx = canvas.getContext('2d'); ...&#125; else &#123;sr ...&#125; 绘制形状绘制矩形原生只支持矩形绘制，其他所有图形都至少需要生成一种路径（path） fillRect(x, y, width, height) 填充 strokeRect(x, y,width, height) 空心 clearRect(x, y, width, height) 清除区域 绘制路径路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合，每个路径都是闭合的。 路径绘制图形步骤： 创建路径起始点 调用绘制方法绘制路径 封闭路径 通过描边或填充路径区域来渲染图形 绘制方法： beginPath() 创建路径，画笔指向路径 moveTo(x, y) 画笔移动到坐标，设置路径起始点 closePath() 闭合路径（自动连接终点和起始点），画笔指向上下文 stroke() 线条 fill() 填充 线段 lineTo(x, y) 弧形 arc(x, y, r, startAngle, endAngle, anticlockwise) (x, y) 圆心，r 半径，startAngle 弧度到 endAngle 弧度结束，anticlockwise true 逆时针，false（默认）顺时针 12// 角度换算弧度const radians = (Math.PI / 180) * degrees arcTo(x1, y1, x2, y2, radius)根据给定的控制点和半径画弧，直线连接两个点 画一条与起始点-&gt;(x1, y1)，(x1, y1)-&gt;(x2, y2) 这两条切线相切的圆弧 绘制贝塞尔曲线二次贝塞尔曲线 quadraticCurveTo(cp1x, cp1y, x, y) (cp1x, cp1y) 控制点 (x, y) 结束点 三次次贝塞尔曲线 quadraticCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) 添加样式和颜色 fillStyle = color 填充颜色 strokeStyle = color 轮廓颜色 color：表示 css 颜色值的字符串、渐变对象、图案对象。默认黑色。设置后保持直到重新设置。 globalAlpha = transparencyValue全局透明度 lineWidth = 1.0 线宽，默认 1.0 lineCap = type 线条末端样式 butt 方形 round 圆形 square方形，多了一个高度是线段厚度一半的矩形 lineJoin = type 同一个 path 内，线条与线条之间接合处的样式 round 圆 bevel 平 miter 尖（默认） 虚线 setLineDash([实现长度，间隙长度]) lineDashOffset 偏移量 绘制文本 fillText(text, x, y [, maxWidth]) 在 (x, y) 填充文本，最大宽度可选 strokeText(text, x, y [, maxWidth]) 在 (x, y) 绘制边框，最大宽度可选 样式 font = value 文本样式，同 css font 属性 textAlign = value 对齐选项 start（默认） end left right center textBaseline = value 基线对齐选项 top hanging middle alphabetic（默认） ideographic bottom direction = value 文本方向 ltr trl Inherit（默认） 绘制图片由零开始创建图片 drawImage(img, x, y) 12345var img = new Image();img.src = 'myImage.png';img.onload = function () &#123; // 加载后再绘制 ctx.drawImage(img, 0, 0);&#125; img 可以是DOM元素 12var img = document.querySelector(\"img\");ctx.drawImage(img, 0, 0); drawImage(img, x, y, width, height) 图片缩放 drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) (sx, sy) 原图像中的点，剪裁 (sx+sWidth, sy+sHeight)；绘制到画布（dx, dy）上 状态的保存和恢复 save() 存储在栈中，可以多次调用，类似于 push() restore() 恢复，可以多次调用，类似于 pop() 变形使用前先保存状态便于恢复 translate(x, y) 移动原点到(x, y) rotate(angle) 旋转坐标轴，顺指针 scale(x, y) x 轴和 y 轴的缩放因子 transform(a, b, c, d, e, f) 变形矩阵 合成 globalCompositeOperation = type 默认：新图像+老图像（新图像在老图像上面） source-in：新图像的重叠部分 Source-out：新图像的没重叠部分 source-atop：老图像+重叠部分 destination-over：新图像+老图像（老图像在新图像上面） destination-in：老图像的重叠部分 destination-out：老图像的没重叠部分 destination-atop：老图像重叠部分+新图像（新图像在老图像下面） lighter：新图像+老图像（重叠区域颜色叠加） darken：新图像+老图像（重叠区域颜色取最深） lighten：新图像+老图像（重叠区域颜色取最亮） xor：重叠部分透明 copy：新图像保留，清楚其余部分 裁剪路径 clip() 遮罩，只显示路径内的区域 动画基本步骤 清空 canvas 绘制每一帧动画前，要清空所有 clearRect() 保存 canvas 状态 控制动画图形 真正的绘制动画帧 恢复 canvas 状态 控制动画 setInterval() setTimeout() requestAnimationFrame()","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ziiyan.github.io/tags/JavaScript/"}]},{"title":"DE打包优化","slug":"dataExplorer打包优化","date":"2020-04-07T11:24:25.000Z","updated":"2020-07-27T09:20:47.060Z","comments":true,"path":"2020/04/07/dataExplorer打包优化/","link":"","permalink":"http://ziiyan.github.io/2020/04/07/dataExplorer%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/","excerpt":"","text":"成果优化前 优化后工具安装1npm install webpack-bundle-analyzer 配置因为是 vue-cli 3.0，没有 webpack 配置文件了，在根目录下自己手动新建 vue.config.js 1234567module.exports = &#123; chainWebpack: config =&gt; &#123; config .plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin) &#125;&#125; 查看1npm run server 重新启动之后访问 http://127.0.0.1:8888 就是可视化的图了 Webpack 文件分离Webpack 文件分离包括两个部分，一个是 Bundle 的分离，一个是 Code 代码的分离: Bundle splitting: 实际上就是创建多个更小的文件，并行加载，以获得更好的缓存效果；主要的作用就是使浏览器并行下载，提高下载速度。并且运用浏览器缓存，只有代码被修改，文件名中的哈希值改变了才会去再次加载。 Code splitting: 只加载用户最需要的部分，其余的代码都遵从懒加载的策略；主要的作用就是加快页面加载速度，不加载不必要加载的东西。 Bundle splitting配置1234567891011121314151617181920212223242526module.exports = &#123; chainWebpack: config =&gt; &#123; config .plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin) &#125;, configureWebpack: &#123; optimization: &#123; splitChunks: &#123; chunks: 'all', maxInitialRequests: Infinity, minSize: 0, minChunks: 1, cacheGroups: &#123; commons: &#123; test: /[\\\\/]node_modules[\\\\/]/, name(module) &#123; const packageName = module.context.match(/[\\\\/]node_modules[\\\\/](.*?)([\\\\/]|$)/)[1]; return `modules.$&#123;packageName.replace('@', '')&#125;`; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 首先增加 maxInitialRequests 并设置成 Infinity，指定这个入口文件最大并行请求数 然后将 minSize 和 minChunks 分别设置成 0 和 1，即使模块非常小也将其提取出来，并且这个模块的引用次数只有 1 也要提取 最后配置匹配的依赖以及分离出的文件名格式 另外，我们还将运行时代码分离出来，这块代码还可以配合 InlineManifestWebpackPlugin 直接插入到 HTML 文件中。这里我们将这个配置设置成 single，即将所有chunk的运行代码打包到一个文件中 现在可以看到 app.js 被拆解成很多个单独的包，这些包在加载时可以并行下载，提高下载速度。 逐个击破Echarts项目里用到的只有 bar 这个图形，所以按需载入即可。 /src/plugins 下新建文件 echarts.js： 123456import echarts from 'echarts/lib/echarts'import 'echarts/lib/chart/bar'import 'echarts/lib/component/legend'export default echarts 使用到 Echarts 的组件中： 1import echarts from '@/plugins/echarts' 2.52 M -&gt; 830.76 KB monaco这个是代码编辑器，用到的地方比较多，本来想像 echarts 一样按需引入，但是引入完之后依旧非常大，考虑用 CDN 加速，参考： https://github.com/microsoft/monaco-editor/blob/master/docs/integrate-amd-cross.md https://www.cnblogs.com/XHappyness/p/9708102.html 1npm install html-loader --save-dev 1234567891011121314151617// index.html &lt;script type=\"text/javascript\" src=\"https://cdn.bootcss.com/monaco-editor/0.20.0/min/vs/loader.js\"&gt;&lt;/script&gt; &lt;script&gt; require.config(&#123; paths: &#123; 'vs': 'https://cdn.bootcss.com/monaco-editor/0.20.0/min/vs' &#125;&#125;); window.MonacoEnvironment = &#123; getWorkerUrl: function(workerId, label) &#123; return `data:text/javascript;charset=utf-8,$&#123;encodeURIComponent(` self.MonacoEnvironment = &#123; baseUrl: 'https://cdn.bootcss.com/monaco-editor/0.20.0/min/' &#125;; importScripts('https://cdn.bootcss.com/monaco-editor/0.20.0/min/vs/base/worker/workerMain.js');` )&#125;`; &#125; &#125;; require([\"vs/editor/editor.main\"], function () &#123;&#125;); &lt;/script&gt; 12345678910111213141516171819// vue.config.jsmodule.exports = &#123; ··· chainWebpack: config =&gt; &#123; config.module .rule('html') .test(/\\.html$/) .use('html-loader') .loader('html-loader') &#125; ··· configureWebpack: &#123; ... externals: &#123; 'monaco-editor': 'monaco-editor' &#125; &#125;&#125; 折腾了大半天总算可以，使用的时候需要 window.monaco.editor.create(...)","categories":[],"tags":[{"name":"工作","slug":"工作","permalink":"http://ziiyan.github.io/tags/%E5%B7%A5%E4%BD%9C/"}]},{"title":"Performance Benchmarking and Optimizing Hyperledger Fabric Blockchain Platform","slug":"Performance-Benchmarking-and-Optimizing-Hyperledger-Fabric-Blockchain-Platform","date":"2020-04-04T08:53:39.000Z","updated":"2020-05-10T17:20:10.828Z","comments":true,"path":"2020/04/04/Performance-Benchmarking-and-Optimizing-Hyperledger-Fabric-Blockchain-Platform/","link":"","permalink":"http://ziiyan.github.io/2020/04/04/Performance-Benchmarking-and-Optimizing-Hyperledger-Fabric-Blockchain-Platform/","excerpt":"","text":"Abstract The rise in popularity of permissioned blockchain platforms in recent time is significant. Hyperledger Fabric is one such permissioned blockchain platform and one of the Hyperledger projects hosted by the Linux Foundation. The Fabric comprises of various components such as smart-contracts, endorsers, committers, validators, and orderers. As the performance of blockchain platform is a major concern for enterprise applications, in this work, we perform a comprehensive empirical study to characterize the performance of Hyperledger Fabric and identify potential performance bottlenecks to gain a better understanding of the system. 最近一段时间，许可链平台的流行度显着上升。 Hyperledger Fabric 是一种这样的许可链平台，也是 Linux 基金会托管的 Hyperledger 项目之一。 Fabric 由各种组件组成，例如智能合约，背书节点，提交节点，验证节点和排序节点。 由于区块链平台的性能是企业应用程序的主要关注点，因此在这项工作中，我们进行了全面的实证研究，以表征 Hyperledger Fabric 的性能并确定潜在的性能瓶颈，以更好地了解系统。 We follow a two-phased approach. In the first phase, our goal is to understand the impact of various configuration parameters such as block size, endorsement policy, channels, resource allocation, state database choice on the transaction throughput &amp; latency to provide various guidelines on configuring these parameters. In addition, we also aim to identify performance bottlenecks and hotspots. We observed that (1) endorsement policy verification, (2) sequential policy validation of transactions in a block, and (3) state validation and commit (with CouchDB) were the three major bottlenecks. 我们遵循两阶段的方法。 在第一阶段，我们的目标是了解各种配置参数（例如块大小、背书策略、通道、资源配置、状态数据库选择）对交易吞吐量和延迟的影响，以提供有关配置这些参数的各种指导。 此外，我们还旨在确定性能瓶颈和热点。 我们观察到（1）背书策略验证，（2）块中交易的顺序策略验证，（3）状态验证和提交（使用 CouchDB）是三个主要瓶颈。 In the second phase, we focus on optimizing Hyperledger Fabric v1.0 based on our observations. We introduced and studied various simple optimizations such as aggressive caching for endorsement policy verification in the cryptography component (3× improvement in the performance) and parallelizing endorsement policy verification (7× improvement). Further, we enhanced and measured the effect of an existing bulk read/write optimization for CouchDB during state validation &amp; commit phase (2.5× improvement). By combining all three optimizations, we improved the overall throughput by 16× (i.e., from 140 tps to 2250 tps). 在第二阶段，我们将根据我们的观察优化 Hyperledger Fabric v1.0。 我们介绍并研究各种简单的优化方法，例如在加密组件中进行背书策略验证的主动缓存（性能提高了 3 倍）和并行化背书策略验证（提高 7 倍）。 此外，我们在验证和提交阶段期间增强并测量了现有的针对 CouchDB 批量读写优化的效果（提高 2.5 倍）。 通过结合这 3 个优化，我们将整体吞吐量提升了 16 倍，即从 140 tps 到 2250 tps。 I. INTRODUCTION Blockchain technologies initially gained popularity as they were seen as a way to get rid of the intermediary and decentralize the system. Since then, blockchain has witnessed a growing interest from different domains and use cases. A blockchain is a shared, distributed ledger that records transactions and is maintained by multiple nodes in the network where nodes do not trust each other. Each node holds the identical copy of the ledger which is usually represented as a chain of blocks, with each block being a logical sequence of transactions. Each block encloses the hash of its immediate previous block, thereby guaranteeing the immutability of ledger. 区块链最初开始流行是因为它们被认为是一种摆脱中介和去中心化系统的方式。从那之后，区块链见证了来自不同领域和用例日益增长的兴趣。 区块链是一个共享的、分布式的账本，它记录交易并由网络中互不信任的多个节点共同维护。每个节点都拥有该账本的相同副本，账本通常由区块链表示，每个区块都是交易的逻辑顺序。每个交易都包含前一个区块的哈希，从而保证了账本的不可篡改。 Blockchain is often hailed as a new breed of database systems, in essence being a distributed transaction processing system where the nodes are not trusted and the system needs to achieve Byzantine fault tolerance. Blockchain provides serializability, immutability, and cryptographic verifiability without a single point of trust unlike a database system; properties that have triggered blockchain adoption in a wide variety of industries. 区块链通常被誉为一种新型的数据库系统，本质上是一个分布式的交易处理系统，其中的节点不受信任，并且这个系统需要实现拜占庭容错。与数据库系统不同，区块链在没有单一信任点的情况下提供了可串行性、不可篡改性和加密可验证性；引发区块链在众多行业中采用的特性。 A blockchain network can be either permissionless or permissioned. In a permissionless network or public network such as Bitcoin, Ethereum, anyone can join the network to perform transactions. Due to a large number of nodes in a public network, a proof-of-work consensus approach is used to order transactions and create a block. In a permissioned network, the identity of each participant is known and authenticated cryptographically such that blockchain can store who performed which transaction. In addition, such a network can have extensive access control mechanisms built-in to limit who can (a) read &amp; append to ledger data, (b) issue transactions, (c) administer participation in the blockchain network. 区块链网络可以是未经许可的或经过许可的。 在未经许可的网络或公共网络（例如比特币、以太坊）中，任何人都可以加入网络以执行交易。由于公共网络中有大量节点，因此采用工作量证明共识算法来对交易进行排序并创建一个区块。 在经过许可的网络中，每个参与者的身份都是已知的，通过密码验证，区块链可以存储谁执行了哪个交易。此外，这样的网络可以内置广泛的网络控制机制来限制谁可以（a）读取并添加账本数据，（b）发送交易，（c）管理参与区块链网络。 A permissioned network is highly suitable for enterprise applications that require authenticated participants. Each node in a permissioned network can be owned by different organizations. Further, enterprise applications need complex data models and expressibility which can be supported using smart-contracts. Enterprises find value in being able to integrate diverse systems without having to build a centralized solution and to bring a level of trust among untrusting parties or to bring in a trusted third-party. Trade Finance and Food Safety are examples of blockchain applications where participants see value in visibility advantages it offers as compared to the existing loosely coupled centralized systems. 许可网络非常适合需要验证参与者身份的企业应用程序。 许可网络中的每个节点可以由不同的组织拥有。 此外，企业应用程序需要复杂的数据模型和可表达性，可以使用智能合约来支持它们。 企业发现了能够集成各种系统而无需构建集中式解决方案并在非信任方之间建立信任度或引入受信任的第三方的价值。 贸易金融和食品安全是区块链应用的例子，与现有的松散耦合的集中式系统相比，参与者在其可见性优势中看到了价值。 There is a lot of concern about the performance of permissioned blockchain platforms and their ability to handle a huge volume of transactions at low latency. Another concern is the richness of language to describe the transactions. Different blockchain platforms such as Quorum, Corda address these concerns using different techniques derived from the distributed systems domain. Hyperledger Fabric is an enterprise-grade open-source permissioned blockchain platform which has a modular design and a high degree of specifiability through trust models and pluggable components. Fabric is currently being used in many different use cases such as Global Trade Digitization, SecureKey, Everledger and is the focus of our performance study. 对于许可链平台的性能及其以低延迟处理大量交易的能力，存在很多担忧。 另一个问题是描述交易的语言丰富。 Quorum，Corda 等不同的区块链平台使用源自分布式系统领域的不同技术来解决这些问题。Hyperledger Fabric 是企业级开源许可链平台，具有模块化设计，并通过信任模型和可插拔组件实现高度可定制性。 目前，Fabric 已在许多不同的用例中使用，例如全球贸易数字化，SecureKey，Everledger，这是我们性能研究的重点。 Fabric consists of various components such as endorsers, ordering service, and committers. Further, it constitutes various phases in processing a transaction such as endorsement phase, ordering phase, validation and commit phase. Due to numerous components and phases, Fabric provides various configurable parameters such as block size, endorsement policy, channels, state database. Hence, one of the main challenges in setting up an efficient blockchain network is finding the right set of values for these parameters. For e.g., depending on the application and requirements, one might need to answer the following questions: What should be the block size to achieve a lower latency? How many channels can be created and what should be the resource allocation? What types of endorsement policy is more efficient? How much is the performance difference between GoLevelDB and CocuhDB when it is used as the state database? Fabric 由各种组件组成，例如智能合约，背书节点，提交节点，验证节点和排序节点。此外，它还构成了处理交易的各个阶段，例如背书阶段，排序阶段，验证和提交阶段。由于组件和阶段众多，Fabric 提供了各种可配置的参数，例如块大小，背书策略，通道，状态数据库。因此，建立有效的区块链网络的主要挑战之一是为这些参数找到正确的值集。例如，根据应用和要求，可能需要回答以下问题： 达到较低延迟的块大小应该是多少？ 可以创建多少个通道，应该怎么分配资源？ 哪种类型的认可政策更有效？ GoLevelDB 和 CocuhDB 用作状态数据库时它们之间的性能差异有多少？ To answer above questions and to identify the performance bottlenecks, we perform a comprehensive empirical study of Fabric v1.0 with various configurable parameters. Specifically, our three major contributions are listed below. We conducted a comprehensive empirical study of Fabric platform by varying values assigned to the five major parameters by conducting over 1000s of experiments. As a result, we provide six guidelines on configuring these parameters to attain the maximum performance. We identified three major performance bottlenecks: (i) crypto operations, (ii) serial validation of transactions in a block, and (iii) multiple REST API calls to CouchDB. Introduced and studied three simple optimizations to improve the overall performance by 16× (i.e., from 140 tps to 2250 tps) for a single channel environment. 为了回答上述问题并确定性能瓶颈，我们对 Fabric v1.0 的各种可配置参数的进行了全面的实证研究。 具体来说，以下是我们的三大贡献。 我们通过进行1000多次实验，通过改变分配给五个主要参数的值，对Fabric 平台进行了全面的实证研究。 最终，我们提供了六种有关配置这些参数的准则以获得最佳性能。 我们确定了三个主要的性能瓶颈：（i）加密操作，（ii）块中交易的串行验证以及（iii）对 CouchDB 的多个 REST API 调用。 引入并研究了三种简单的优化方法，针对单个通道环境将整体性能提高16倍（即从 140 tps 到 2250 tps）。 II. BACKGROUND: HYPERLEDGER FABRIC ARCHITECTURE &amp; CONFIGURATION PARAMETERS The Hyperledger Fabric is an implementation of permissioned blockchain system which has many unique properties suited for enterprise-class applications. It can run arbitrary smart contracts (a.k.a chaincodes) implemented in Go/JAVA/Nodejs language. It supports an application specifiable trust model for transaction validation and a pluggable consensus protocol to name a few. A Fabric network consists of different types of entities, peer nodes, ordering service nodes and clients, belonging to different organizations. Each of these has an identity on the network which is provided by a Membership Service Provider (MSP), typically associated with an organization. All entities in the network have visibility to identities of all organizations and can verify them. Hyperledger Fabric 是许可区块链系统的实现，具有许多适合企业级应用程序的独特属性。 它可以运行以 Go / JAVA / Nodejs 语言实现的任意智能合约（也称为链码）。 它支持用于交易验证的应用程序可定制的信任模型和可插拔的共识协议等。 Fabric 网络由属于不同组织的不同类型的实体、对等节点、排序节点和客户端组成。这些中的每一个在网络上都有一个身份，该身份由通常由组织相关联的成员资格服务提供商（MSP）提供。 网络中的所有实体都可以查看所有组织的身份，并可以对其进行验证。 A. Key Components in FabricPeer A peer node executes the chaincode, which implements a user smart-contract, and maintains the ledger in a file system. The chaincode is allowed access to the shared state by well-defined ledger APIs. A peer is further segregated as an endorsing peer, one which has the chaincode logic and executes it to endorse a transaction or a committing peer, one which does not hold the chaincode logic. Irrespective of this differentiation, both types of peer maintain the ledger. Additionally, both peers maintain the current state as StateDB in a key-value store such that chaincode can query or modify the state using the database query language. 对等节点执行链码（该链码实现了用户智能合约）并在文件系统中维护账本。 链码可以通过定义明确的分类账本 API 访问共享状态。 对等节点进一步被分类为背书节点（具有链码逻辑和执行链码以背书一个交易）或提交节点（没有链码逻辑）。 不论这些区别是什么，两种类型的对等节点都共同维护账本。 此外，两种对等节点在键值存储中将当前状态保持为 StateDB，以便链码可以使用数据库查询语言查询或修改状态。 Endorsement Policies Chaincodes are written in generalpurpose languages that execute on untrusted peers in the network. This poses multiple problems, one of non-deterministic execution and the other of trusting the results from any given peer. The endorsement policy addresses these two concerns, by specifying as part of an endorsement policy, the set of peers that need to simulate the transaction and endorse or digitally sign the execution results. Endorsement policies are specified as boolean expressions over network principals identities. A principal here is a member of a specific organization. 链码用通用语言编写，可在网络中不受信任的对等节点上执行。 这带来了多个问题，一个是不确定性执行，另一个是信任来自任意给定对等节点的结果。背书策略通过指定作为背书策略的一部分对等节点集合来解决这两个问题，这些对等点需要模拟交易并背书或对执行结果进行数字签名。背书策略被指定为基于网络主体身份的布尔表达式。 此处的负责人是特定组织的成员。 System chaincodes System chaincode has the same programming model as normal user chaincodes and is built into the peer executable, unlike user chaincodes. Fabric implements various system chaincodes; the life cycle system chaincode (LSCC)—to install/instantiate/update chaincodes; the endorsement system chaincode (ESCC)—to endorse a transaction by digitally signing the response; the validation system chaincode (VSCC)—to validate a transaction’s endorsement signature set against the endorsement policy; the configuration system chaincode (CSCC) – to manage channel configurations. 系统链码具有与普通用户链码相同的编程模型，并且内置在对等节点可执行文件中，这与用户链码不同。 Fabric 实现各种系统链码； 生命周期系统链代码（LSCC）-用来安装/实例化/更新链码； 背书系统链码（ESCC）-通过对响应进行数字签名来背书交易； 验证系统链码（VSCC）-根据背书策略来验证交易的背书签名集； 配置系统链码（CSCC）–管理通道配置。 Channel Fabric introduces a concept called channel as a “private” subnet of communication between two or more peers to provide a level of isolation. Transactions on a channel are only seen by the peer members and participants. The immutable ledger and chaincodes are on a per-channel basis. Further, the consensus is applicable on a per-channel basis, i.e., there is no defined order for transaction across channels. Fabric 引入了一个称为通道的概念，作为两个或多个对等节点之间的“专用”通信子网，以提供一定程度的隔离。 通道上的交易仅由对等节点成员和参与者可见。 在每个通道上都有不变的账本和链码。 此外，共识适用于每个通道，即没有定义的跨通道的交易顺序。 Ordering Service An Ordering Service Node (OSN), participate in the consensus protocol and cuts block of transactions which is delivered to the peers by a gossip communication protocol. The structure of a block in Fabric v1.0 is shown in Figure2. The ordering service is modular and supports a pluggable consensus mechanism. By default, a serial ordering (i.e., consensus) is achieved using an underlying Kafka/Zookeeper cluster. OSNs publish transactions to kafka topics and leverages the ordered and immutable nature of records in kafka topic to generate a unique ordered sequence of transactions in a block. A block is cut, when either a maximum number of new transactions, since the last block cut, are added added or a configured timeout since the last block cut has occurred. When any one condition is satisfied, an OSN, publishes a time-to-cut marker and cut a block of all transactions message offsets since the last time-to-cut message offset. The block is then delivered to the peer nodes. 排序服务节点（OSN）参与共识协议和“削减”交易块，该交易通过 Gossip 通信协议传递给对等节点。 Fabric v1.0 中的块结构如图所示。 排序服务是模块化的，并支持可插入的共识机制。 默认使用基础的 Kafka / Zookeeper 集群实现序列排序（即共识）。 OSN 将交易发布到 kafka topic，并利用 kafka topic 中记录的有序和不变性在一个块中生成唯一的有序交易序列。 当添加了自上次切块以来最大数量的新交易，或者自上次切块发生以来的配置超时时，该块被切掉。当满足任何一个条件时，OSN 会发布一个截止时间标记，并切掉自上次截止时间消息偏移以来所有交易消息偏移组成的块。 然后将该块传递到对等节点。 Client The client application is responsible for putting together a transaction proposal as shown in Figure2. The client submits the transaction proposal to 1-or-more peers simultaneously for collecting proposal responses with endorsements to satisfy the endorsement policy. It then broadcasts the transaction to the orderer to be included into a block and delivered to all peers for validation and commit. In Fabric v1.0, the onus is on the client to ensure that the transaction is well-formed and satisfies the endorsement policies. 如图2所示，客户应用程序负责将交易提案汇总在一起。 客户将交易提案同时提交给一个或多个对等节点，以收集带有背书的提案响应，以满足背书策略。 然后，它将交易广播给排序节点，为了打包并交付给所有对等节点来进行验证和提交。 在Fabric v1.0中，客户有责任确保交易的格式正确并满足背书策略。 B. Transaction Flow in Hyperledger Fabric Unlike other Blockchain network which employ an order-execute transaction model, the Fabric employs a simulate order-validate &amp; commit model. Figure 1 depicts the transaction flow which involves 3 steps, 1) Endorsement Phase – simulating the transaction on selective peers and collecting the state changes; 2) Ordering Phase – ordering the transactions through a consensus protocol; and 3) Validation Phase – validation followed by commit to ledger. Before transactions can be submitted on Fabric, the network needs to be bootstrapped with participating organizations, their MSPs and identities for peers. First, a channel is created on the orderer network with respective organization MSPs. Second, peers of each organization join the channel and initializes the ledger. Finally, the required chaincodes are installed on the channel. 与其他采用顺序执行交易模型的区块链网络不同，Fabric 采用模拟顺序验证和提交模型。 图1描绘了涉及三个步骤的交易流程： 1）背书阶段–在可选择的对等节点上模拟交易并收集状态变化； 2）排序阶段–通过共识协议对交易进行排序； 3）验证阶段–验证，然后提交到账本。 在可以在 Fabric 上提交交易之前，网络需要与参与组织（它们的资格服务提供商）一起自举并验证对等节点。 首先，在带有各自组织资格服务提供商的排序网络上创建通道。 其次，每个组织的对等节点加入通道并初始化账本。 最后，所需的链码被安装在通道上。 Endorsement Phase A client application using the Fabric SDK, constructs a transaction proposal to invoke a chaincode function which in-turn will perform read and/or write operations on the ledger state. The proposal is signed with the client’s credentials and the client sends it to 1-or-more endorsing peers simultaneously. The endorsement policy for the chaincode dictates the organization peers the client needs to send the proposal to for simulation. 客户端（client）使用 Fabric SDK 构造交易提议（transaction proposal） 以调用链码函数，该函数将依次对账本状态执行读取和/或写入操作。 提案已被客户端的资格证书签名，且客户端同时将提案发送给1个或多个背书节点。 链码的背书策略规定了客户端需要发送提议给模拟的组织对等节点。 First, each endorsing peer verifies that the submitter is authorized to invoke transactions on the channel. Second, the peer executes the chaincode, which can access the current ledger state on peer. The transaction results include response value, read-set and write-set. All reads read the current state of ledger, but all writes are intercepted and modify a private transaction workspace. Third, the endorsing peer calls a system chaincode called ESCC which signs this transaction response with peer’s identity and replies back to client with proposal response. Finally, the client inspects the proposal response to verify that it bears the signature of the peer. The client collects enough proposal response from different peers, verifies that the endorsements are same. Since each peer could have executed the transaction at different height in the blockchain, it is possible that the proposal response differs. In such cases, the client has to re-submit the proposal to other peers, to obtain sufficient matching responses. 首先，每个背书节点都会验证提交者是否有权调用通道上的交易。 其次，对等节点执行链码，该链码可以访问节点上当前的账本状态。交易结果包括响应值，读集和写集。所有读均读取账本的当前状态，但所有写入均会被拦截并修改私有交易工作区。 第三，背书节点调用一个称为 ESCC 的系统链码，该系统链码以节点的身份对该交易响应进行签名，并通过提案响应将其返回给客户端。 最后，客户端检查提议响应以验证它是否带有节点的签名。客户端从不同的节点那里收集到足够多的提案响应，验证背书是否相同。 由于每个节点可能在区块链中的不同高度处执行交易，因此提案响应可能会有所不同。在这种情况下，客户端必须将提案重新提交给其他节点，以获得足够的匹配响应。 Ordering Phase The client broadcasts a well-formed transaction message to the Ordering Service. The transaction will contain the read-write sets, the endorsing peer signatures and the Channel ID. The ordering service does not need to inspect the contents of the transaction to perform its operation. It receives transactions from different clients for various channels and enqueues them on a per-channel basis. It creates blocks of transactions per channel, sign the block with its identity and delivers them to peers using gossip messaging protocol. 客户端向排序服务广播格式正确的交易消息。 交易将包含读写集，背书节点签名和通道ID。 排序服务不需要检查交易的内容即可执行操作。 它接收来自不同客户的各种通道的交易，并在每个通道的基础上排队。 它创建每个通道的交易块，用其身份签名该块，并使用 gossip 通信协议将其“传递”给节点。 Validation Phase All peers, both endorsing and committing peers on a channel receive blocks from the network. The peer first verifies the Orderer’s signature on the block. Each valid block is decoded and all transactions in a block goes through VSCC validation first before performing MVCC validation. 通道上的所有对等节点（背书节点和提交节点）都从网络接收块。 首先，节点验证块上排序节点的签名。 在执行 MVCC 验证之前，每个有效块都将被解码，并且在一个块中的所有交易都将先通过 VSCC 验证。 VSCC Validation A Validation system chaincode evaluates endorsements in the transaction against the endorsement policy specified for the chaincode. If the endorsement policy is not satisfied, then that transaction is marked invalid. 验证系统链码会根据为链码指定的背书策略评估交易中的背书。 如果不符合则该交易将标记为无效。 MVCC Validation As the name implies, the Multi-Version Concurrency Control check ensures that the versions of keys read by a transaction during the endorsement phase are same as their current state in the local ledger at commit time. This is similar to a read-write conflict check done for concurrency control, and is performed sequentially on all the valid transactions in the block (as marked by VSCC validation). If the read-set versions do not match, denoting that a concurrent previous (as-in earlier in this block or before) transaction modified the data read and was since (it’s endorsement) successfully committed, the transaction is marked invalid. To ensure that no phantom reads occur, for range queries, the query is re-executed and compares the hashes of results (which is also stored as part of read-set captured during endorsement). 顾名思义，“多版本并发控制”检查确保交易在背书阶段读取的密钥版本与提交时本地账本中的当前状态相同。 这类似于为进行并发控制而进行的读写冲突检查，并且对块中的所有有效交易按顺序执行（由 VSCC 验证标记）。 如果读取的版本不匹配，表示并发的先前（在此块中较早或之前）的交易修改了读取的数据，并且是由于（背书）成功提交的，则该交易被标记为无效。 为确保不发生幻读，对于范围查询，将重新执行查询并比较结果的哈希值（也将其存储为背书期间捕获的读取集的一部分）。 Ledger Update Phase As the last step of transaction processing, the ledger is updated by appending the block to the local ledger. The StateDB, which holds the current state of all keys is updated with the write-sets of valid transactions (as marked by MVCC validation). These updates to the StateDB are performed atomically for a block of transactions and applies the updates to bring the StateDB to the state after all transaction in the block have been processed. 作为交易处理的最后一步，通过将块添加到本地账本来更新账本。 使用有效交易的写集（由 MVCC 验证标记）更新保存所有密钥当前状态的 StateDB。 对 StateDB 的这些更新是针对一个交易块自动执行的，并在处理了该块中的所有交易之后，应用更新以使 StateDB 进入状态。 C. Configuration Parameters Our goal is to study the performance of Fabric under various conditions to understand how choices of different facets of the system affect performance. However, the parameter space is wide and we limit our choices to comprehensively cover a few components and look widely at other aspects of the system so that we can identify interplay of component level choices. To this end, we choose to understand and characterize the overall performance primarily from a peer’s perspective. More specifically, we keep the Orderer, Gossip (physical network) etc. static so that it does not affect our experiments and observations. Next, we describe the five parameters considered in this study and their significance. 我们的目标是研究各种条件下 Fabric 的性能，以了解系统不同方面的选择如何影响性能。 但是，参数有很多，我们将选择范围限制为全面涵盖几个组件，并广泛查看系统的其他方面，以便我们可以识别组件级别选择的相互影响。 为此，我们选择主要从节点的角度来理解和表征整体绩效。 更具体地说，我们将排序节点，Gossip（物理网络）等保持静态，以免影响我们的实验和观察结果。 接下来，我们描述了这项研究中考虑的五个参数及其意义。 1) Block Size Transactions are batched at the orderer and delivered as a block to peers using a gossip protocol. Each peer processes one block at a time. Cryptographic processing like orderer signature verification is done per-block unlike transaction endorsement signatures verification, which is pertransaction. Varying blocksize also brings in the throughputvs-latency tradeoff and for a better picture, we study it in conjunction with the transaction arrival rate. 交易在排序节点处分批处理，并打包后使用 gossip 协议交付给对等节点。 每个对等节点一次处理一个块。 像排序节点验签这样的加密处理是按块完成的，这与交易背书验签（即每笔交易）不同。 变化的块大小还会带来吞吐量与延迟之间的权衡，为了更好地了解情况，我们结合交易到达率对其进行了研究。 2) Endorsement Policy An endorsement policy dictates how many executions of a transaction and signing need to happen before a transaction request can be submitted to the orderer so that the transaction can pass the VSCC validation phase at peers. The VSCC validation of a transaction’ endorsements require evaluation of endorsement policy expression against the collected endorsements and checking for satisfiability, which is NP-Complete. Additionally, a check includes verifying that the identity and its signature. The complexity of the endorsement policy will affect resources and the time taken to collect and evaluate it. 背书策略指示在可以将交易请求提交给排序节点之前，需要执行多少交易和签名，以便交易可以在对等节点中通过 VSCC 验证阶段。 VSCC 对交易背书的验证需要根据收集的背书和检查可满足性来评估背书策略表示，即 NP 完全。 另外，检查包括验证身份及其签名。 背书政策的复杂性将影响资源以及收集和评估它的时间。 3) Channel Channels isolate transactions from one another. Transactions submitted to different channels are ordered, delivered and processed independent of each other, albeit on same peers. Channels bring inherent parallelism to various aspects of transaction processing in the Fabric. While number of channels to use, and what channels to transact on is determined by the application and participant combinatorics, it has significant implications on platform performance and scalability. 通道将交易彼此隔离。 提交到不同通道的交易彼此独立地进行排序，交付和处理，尽管它们在同一对等节点上。 通道为结构中交易处理的各个方面带来了固有的并行性。 尽管使用的通道数量以及要进行交易的通道由应用程序和参与者组合程序确定，但它对平台性能和可扩展性具有重大影响。 4) Resource Allocation Peers run CPU-intensive signature computation and verification routines as part of system chaincodes. User chaincodes executed by endorsing peers during transaction simulation add to this mix. We vary the number of CPU cores on peer nodes to study its effect. While network characteristics are important, we assume a datacenter or high bandwidth network with very low latency for this study. 对等节点 将 CPU 密集型签名计算和验证例程作为系统链码的一部分运行。 在交易模拟过程中通过背书对等节点执行的用户链码将添加到此组合中。 我们改变对等节点上 CPU 内核的数量以研究其效果。 尽管网络特性很重要，但我们假设此研究的数据中心或高带宽网络具有极低的延迟。 5) Ledger Database Fabric supports two alternatives for key-value store, CouchDB and GoLevelDB to maintain the current state. Both are key-value stores, while GoLevelDB is an embedded database, CouchDB uses a client-server model (accessed using REST API over a secure HTTP) and supports document/JSON data-model. Fabric 支持键值存储的两种方案，即 CouchDB 和 GoLevelDB 以维护当前状态。 两者都是键值存储，而 GoLevelDB 是嵌入式数据库，而 CouchDB 使用客户端-服务器模型（通过 REST API 通过安全的 HTTP 访问），并支持 文档/JSON 数据模型。 III. PROBLEM STATEMENT The two primary goals of our work are: 我们工作的两个主要目标是： 1) Performance Benchmarking To conduct an in-depth study of Fabric core components and benchmark Fabric performance for common usage patterns. We aim to study the throughput and latency characteristics of the system when varying the configuration of parameters listed §II-C to understand the relationship between the performance metrics and parameters. Based on our observations, we aim to derive and present a few high-level guidelines, which would be valuable to developers and deployment engineers. 对 Fabric 核心组件进行深入研究，并针对常见使用模式对基准 Fabric 性能进行基准测试。 当更改 §II-C 中列出的参数配置时，我们旨在研究系统的吞吐量和延迟特性，以了解性能指标与参数之间的关系。 根据我们的观察，我们旨在推导并提出一些高级指南，这些指南对于开发人员和部署工程师而言非常有价值。 2) Optimization To identify bottlenecks using code-level instrumentation and to draw out action items to improve the overall performance of Fabric. On identifying bottlenecks, our goal is to introduce and implement optimizations to alleviate these bottlenecks. 使用代码级工具识别瓶颈并制定行动项目以提高 Fabric 的整体性能。 在确定瓶颈方面，我们的目标是引入并实施优化措施以缓解这些瓶颈。 IV. EXPERIMENTAL METHODOLOGY We study the throughput and latency as the primary performance metrics for Fabric. Throughput is the rate at which transactions are committed to ledger. Latency is the time taken from application sending the transaction proposal to the transaction commit and is made up of the following latencies: 我们将吞吐量和延迟作为 Fabric 的主要性能指标进行研究。 吞吐量是将交易提交到账本的速率。 等待时间是指从应用程序发送交易提案到提交交易所花费的时间，由以下等待时间组成： Endorsement latency – the time taken for the client to collect all proposal responses along with the endorsements. Broadcast latency – the time delay between client submitting to orderer and orderer acknowledges the client. Commit latency – the time taken for the peer to validate and commit the transaction. Ordering latency – the time transaction spent on the ordering service. As the performance of ordering service is not studied in this work, we are not presenting this latency. 背书延迟 ：客户端收集所有提案回复以及背书的时间。 广播延迟：客户端提交到排序节点和排序节点通知客户端的时间。 提交延迟：对等节点验证并提交交易所需的时间。 排序延迟：交易花费在排序服务的时间。由于本文未研究排序服务的性能，因此我们不介绍这种延迟。 Further, we define the following three latency at block level: VSCC validation latency – the time taken to validate all transactions’ endorsement signature set (in a block) against the endorsement policy. MVCC validation latency – the time taken to validate all transactions in a block by employing multi-version concurrency control as described in §II-B. Ledger update latency – the time taken to update the state database with write-set of all valid transactions in a block. 此外，我们在块级别定义了以下三个延迟： VSCC 验证延迟：根据背书策略验证所有交易的背书签名集（以块为单位）所花费的时间。 MVCC 验证等待时间：通过采用第 II-B 节所述的多版本并发控制来验证一个区块中所有交易所需的时间。 账本更新等待时间：块中所有有效交易的写集更新状态数据库所花费的时间。 Since one of the major goal of this work is to identify performance bottlenecks, our load generator spans multiple clients each stresses the system by continuously generating transactions instead of following a distribution model (say, Poisson). Each client also sends proposal requests in parallel and collates endorsements. The transactions are submitted asynchronously to achieve the specified rate without waiting for commits. However, the benchmark framework tracks commit using our tools named fetch-block to calculate throughput and latency. Further, we instrumented the Fabric source code to collect fine-grained latency such as MVCC latency and others latencies. For multi-channel experiments, all organizations and all its peers join the channel. While other combinations are possible, we believe our approach will stress test the system. 由于这项工作的主要目标之一是确定性能瓶颈，因此我们的负载生成器跨越多个客户端，每个客户端通过连续生成交易而不是遵循分发模型（例如 Poisson）来给系统施加压力。 每个客户还并行发送提案请求并收集背书。 为了达到指定的速率，交易是异步提交的，无需等待提交。 然而，基准框架使用名为 fetch-block 的工具来跟踪提交，以计算吞吐量和延迟。 此外，我们检测了 Fabric 源代码，以收集细粒度的延迟，例如 MVCC 延迟和其他延迟。 对于多通道实验，所有组织及其所有对等节点都加入了通道。 尽管其他组合也是可能的，但我们认为我们的方法将对系统进行压力测试。 A. Setup and Workloads Our test Fabric network consists of 4 organizations, each with 2 endorsing peers for a total of 8 peer nodes as depicted in Figure 3. There is 1 orderer node with a kafka-zookeeper cluster backing it. All nodes and kafka-zookeeper run on the x86 64 virtual machines in a IBM SoftLayer Datacenter. Each virtual machine is allocated 32 vCPUs of Intel(R) Xeon(R) CPU E5-2683 v3 @ 2.00GHz and 32 GB of memory. The three powerful client machines used to generate load was allocated with 56 vCPUs and 128 GB memory. Nodes are connected to the 3 Gbps Datacenter network. 如图3所示，我们的测试 Fabric 网络由 4 个组织组成，每个组织都有 2 个背书节点，总共 8 个对等节点。有 1 个带有 kafka-zookeeper 集群的排序节点。 所有节点和 kafka-zookeeper 在 IBM SoftLayer 数据中心的 x86 64 虚拟机上运行。 每个虚拟机都分配了 32 个 Intel®Xeon®CPU E5-2683 v3 vCPU @ 2.00GHz 和 32 GB 内存。 用于生成负载的三台强大的客户端计算机分配了 56 个 vCPU 和 128 GB 内存。 节点已连接到 3 Gbps 数据中心网络。 In the lack of standard benchmarks for Blockchain, we built our own benchmarks by surveying around 12 internal customer solutions built on Fabric for diverse use cases. We identified common defining patterns, data models, and requirements across the board. One of the recurrent pattern is for each chaincode invocation to operate on exactly one asset or unit of data with the identifier being passed to it. The query logic is done by higher level application layers, often without querying blockchain data. This pattern is modelled as simple writeonly transactions (1w, 3w and 5w denoting number of keys written) in our benchmark. Another common pattern is for a chaincode to read-and-write a small set of keys, like read a JSON document, update a field and write it back. We model these as read-writes of 1, 3 and 5 keys. As we have modeled our benchmark to imitate real world blockchain applications in production, we have not considered other macro benchmarks. 在缺乏区块链标准基准的情况下，我们通过调查基于 Fabric 的 12 种内部客户解决方案的不同案例，建立了自己的基准。 我们确定了通用的定义模式，数据模型和全面的要求。 循环模式之一是，每次链码调用都只对一个资产或数据单元进行操作，并将标识符传递给它。 查询逻辑由高层应用程序层完成，通常无需查询区块链数据。 在我们的基准中，此模式被建模为简单的只写交易（1w，3w 和 5w 表示写入的密钥数）。 另一种常见模式是链码读写少量密钥，例如读取 JSON文档，更新字段并将其写回。 我们将这些模型建模为 1、3和 5 键的读写。 由于我们已经建立了基准模型来模拟生产中的现实世界中的区块链应用程序，因此我们没有考虑其他宏观基准。 V. EXPERIMENTAL RESULTS In this section, we study the impact of various configurable parameters listed in §II-C on the performance of Hyperledger Fabric. The throughput and transaction latency presented in this section are averaged over multiple runs. In total, we conducted more than 1000s of experiments. 在本节中，我们研究 §II-C 中列出的各种可配置参数对 Hyperledger Fabric 性能的影响。 本节介绍的吞吐量和交易延迟是多次运行的平均值。我们总共进行了 1000 多次实验。 A. Impact of Transaction Arrival Rate and Block Size Figure 4 plots the average throughput and latency for various block sizes over different transaction arrival rates. Table II presents various transaction arrival rates and block sizes used. For other parameters, refer to Table I. 图 4 绘制了不同交易到达速率下各种块大小的平均吞吐量和延迟。 表 II 列出了使用的各种交易到达率和块大小。 有关其他参数，请参阅表 I。 Observation 1: With an increase in transaction arrival rate, the throughput increased linearly as expected till it flattened out at around 140 tps, the saturation point as shown in Figure 4. When the arrival rate was close to or above the saturation point, the latency increased significantly (i.e., from an order of 100s of ms to 10s of seconds). This is because the number of ordered transactions waiting in the VSCC queue during validation phase grew rapidly (refer to Figure 5) which affected the commit latency. However, with further increase in the arrival rate, we observed no impact on the endorsement and broadcast latency but commit latency. This is because VSCC utilized only a single vCPU and hence new transaction proposals utilized other vCPUs on the peer for simulation and endorsement. As a result, only the validation phase became a bottleneck. In this experiment, the endorsement and broadcast latency was around 12 ms and 9 ms, respectively. 如图4所示，随着交易到达率的增加，吞吐量按预期线性增长，直到达到饱和点 140 tps时才趋于平坦。 当到达率接近或高于饱和点时，延迟显着增加（即从100毫秒到10秒的数量级）。 这是因为在验证阶段在 VSCC 队列中等待的排序交易数量迅速增长（请参阅图5），这影响了提交延迟。 但是，随着到达率的进一步提高，我们发现对背书和广播延迟没有影响，但是对提交延迟有影响 。 这是因为 VSCC 仅使用单个 vCPU，因此新的交易提案使用对等节点的其他 vCPU 进行模拟和背书。 结果，只有验证阶段才成为瓶颈。 在此实验中，背书和广播延迟分别约为 12 毫秒和 9 毫秒。 Observation 2: For an arrival rate lower than the saturation point, with an increase in the block size, the latency increased. For e.g., when the arrival rate was 50 tps, with an increase in the block size from 10 to 100, the transaction latency increased 5-fold, from 242 ms to 1250 ms. The reason is that with an increase in the block size, the block creation time at the orderer increased and hence, on average, a transaction had to wait at the orderer for a little longer. For e.g., when the transaction arrival rate was 100 tps, for the block size of 50 and 100, the block creation rate was 2 and 1 block(s) per second, respectively, causing latency to double. 对于低于饱和点的到达率，随着块大小的增加，等待时间会增加。 例如，当到达速率为 50 tps 时，随着块大小从 10 增加到 100，交易延迟增加了 5 倍，从 242 毫秒增加到 1250 毫秒。 原因是随着块大小的增加，排序节点的块创建时间增加，因此，平均而言，每个交易必须在排序节点等待更长的时间。 例如，当交易到达速率为 100 tps时，对于 50 和 100 的块大小，块创建速率分别为每秒 2 个和 每秒 1 个，从而导致等待时间加倍。 Observation 3: For an arrival rate greater than the saturation point, with an increase in the block size, the latency decreased. For e.g., when the arrival rate was 150 tps, with an increase in block size from 10 to 200, the transaction latency decreased from 14 secs to 10 secs. This is because the time taken to validate and commit a block of size n was always lesser than the time taken to validate and commit m blocks each of size n/m. As a result, throughput also increased by m 3.5%. Note that the block creation rate at orderer node was always greater than the processing rate at validator irrespective of block size and arrival rate. 对于到达率大于饱和点的情况，随着块大小的增加，等待时间减少。例如，当到达率为 150 tps 时，块大小从 10增加到 200，交易延迟从 14 秒减少到 10 秒。 这是因为验证和提交大小为 n 的块所需的时间总是比验证和提交大小为 n/m 的 m 个块所需的时间短。 结果，吞吐量也增加了 3.5％。 请注意，无论块大小和到达速度如何，在排序节点上的块创建速度始终大于验证节点的处理速度。 Observation 4: For a block size, the latency increases as arrival rate increases below the block size as the threshold. The latency decreases as arrival rate increases above the block size. For lower block sizes and at higher arrival rates, blocks were created faster (rather than waiting for a block timeout) which reduced the transaction waiting time at the orderer node. In contrast, for instance, when the block size was 100 and arrival rate increased from 25 to 75 tps, the latency increased from 900 ms to 1250 ms. The reason is that with the increase in rate, the number of transactions in a block increased and so did the time taken by validation and commit phase. Note that if block size limit was not reached within a second, a block was created due to a block timeout. 对于块大小，阈值以下延迟随着到达率增加而增加。 阈值以上随着到达速率增加而减少。对于较小的块大小和较高的到达率，创建块的速度更快（而不是等待块超时），这减少了排序节点的交易等待时间。 相反，例如，当块大小为 100 并且到达速率从 25 tps 增加到 75 tps 时，延迟从 900 ms 增加到 1250 ms。 原因是随着速率的增加，一个区块中的交易数量增加了，验证和提交阶段所花费的时间也增加了。 请注意，如果在一秒钟内未达到块大小限制，则由于块超时而创建了一个块。 Observation 5: Even at the peak throughput, the resources utilization was very low. With an increase in the arrival rate from 25 to 175 tps, the avg CPU utilization merely increased from 1.4% to 6.7%. The reason is that the CPU intensive task performed during VSCC validation phase of a block (i.e., verification of signatures set against endorsement policy for each transaction) processed only one transaction at a time. Due to this serial execution, only one vCPU was utilized. 即使在峰值吞吐量下，资源利用率也很低。 随着到达速度从 25 tps 增加到 175 tps，平均 CPU 利用率仅从 1.4％ 增加到 6.7％。 原因是，在一个块的 VSCC 验证阶段（即，针对每个交易的根据背书策略进行的验签）执行的 CPU 密集型任务一次仅处理一个交易。 由于串行执行，因此仅使用了一个 vCPU。 Guideline 1: When the transaction arrival rate is expected to be lower than the saturation point, to achieve a lower transaction latency for applications, always use a lower block size. In such cases, the throughput will match the arrival rate. 当预计交易到达率低于饱和点时，要实现较低的应用程序交易延迟，请始终使用较小的块大小。 在这种情况下，吞吐量将与到达速率匹配。 Guideline 2: When the transaction arrival rate is expected to be high, to achieve a higher throughput and a lower transaction latency, always use a higher block size. 当预计交易到达率很高时，要实现更高的吞吐量和更低的交易延迟，请始终使用更大的块大小。 Action Item 1: CPU resources are under-utilized. A potential optimization would be to process multiple transactions at a time during the VSCC validation phase as shown in §VI-B. CPU资源利用不足。 潜在的优化将是在 VSCC 验证阶段一次处理多个交易，如 §VI-B 所示。 B. Impact of Endorsement Policy Figure 6 plots the throughput and latency for various endorsement policies defined using both AND/OR and NOutOf syntax over different transaction arrival rates. Table III presents various policies used in this study. Note that ‘a’, ‘b’, ‘c’ and ‘d’ denotes four different organizations. For other parameters, refer to Table I. Though the syntax (AND/OR, NOutOf) used to define the four endorsement policies are different, semantically they are same. For e.g., 3rd policy listed in both syntax denotes that any three organizations endorsement is adequate to pass the VSCC validation. 图 6 绘制了使用 AND / OR 和 NOutOf 语法定义的各种背书策略在不同交易到达率上的吞吐量和延迟。 表 III 列出了本研究中使用的各种策略。 请注意，“ a”，“ b”，“ c” 和 “ d” 表示四个不同的组织。 有关其他参数，请参阅表 I 。 尽管用于定义四个背书策略的语法（AND / OR，NOutOf）不同，但从语义上讲它们是相同的。 例如，两种语法中列出的第三个策略表示，任意三个组织的认可都足以通过 VSCC 验证。 Observation 6: A combination of a number of sub-policies and a number of crypto signatures verification impacted the performance as shown in Figure 6. The 1st and 4th AND/OR policies, having no sub-policies, performed the same as NOutOf policies due to a few signatures verification. With sub-policies, both the number of sub-policies (i.e., search space) and the number of signatures dictated the performance. For e.g., the throughput achieved with 2nd &amp; 3rd AND/OR policies was 7% &amp; 20% lesser than other policies, respectively. 如图6所示，子策略和加密签名验证的组合会影响性能。由于签名验证的原因，没有子策略的第 1 和第 4 个 AND / OR 策略的执行效果与 NOutOf 策略相同。 有子策略的情况下，子策略的数量（即搜索空间）和签名的数量都决定了性能。 例如，使用第二个和第三个AND / OR 策略实现的吞吐量分别比其他策略低 7％和20％。 Figure 7 plots the VSCC latency and the resource utilization at a peer node for various policies. With an increase in the number of signatures verification (specifically for NOutOf), the VSCC latency increased linearly from 68 ms to 137 ms. When there were sub-policies (as with 2nd and 3rd AND/OR policies), the VSCC latency increased significantly (i.e., 172 ms and 203 ms, respectively). A similar trend for resource utilization as show in Figure 7(b). Note that the block bytes increased with increase in the number of endorsements due to the number of x.509 certificates encoded in each transaction. 图 7 绘制了各种策略下的 VSCC 延迟和对等节点上的资源利用率。 随着签名验证数量的增加（特别是对于NOutOf），VSCC 延迟从 68 ms 线性增加到 137 ms。 当存在子策略时（与第 2 和第 3 AND / OR策略一样），VSCC 延迟显着增加（即分别为 172 ms 和 203 ms）。 资源利用率趋势类似，如图7（b）所示。 请注意，由于每个交易中编码的 x.509 证书数量增加，因此块字节随着背书数量的增加而增加。 There are three major CPU intensive operations during the policy validation phase (excluding the check for satisfiability) which are listed below. 1) Deserialization of identity (i.e., x.509 certificate). 2) Validation of identity with organization MSP. 3) Verification of signature on the transaction data. 在策略验证阶段有3个主要的CPU密集型操作（不包括满足性检查），如下所示。 1）身份的反序列化（即 x.509 证书）。 2）与组织 MSP 一起验证身份。 3）验证交易数据上的签名。 Hence, with an increase in the sub-policies (i.e., search space), the number of identities &amp; signatures to be validated, both CPU utilization and VSCC latency increased. It is interesting to note that the MSP identifier is not sent along with x.509 certificate. As a result, the policy evaluator has to validate each x.509 certificate with multiple organization MSPs to identify the correct one. For a 5 minutes run at an arrival rate of 150 tps, we observed 220K such validation out of which 96K validation failed that resulted in wastage of CPU and time. 因此，随着子策略（即搜索空间）、要验证的身份和签名的数量的增加， CPU 利用率和 VSCC 延迟都增加了。 有趣的是，MSP 标识符没有与 x.509 证书一起发送。 结果，策略评估者必须使用多个组织 MSP 验证每个 x.509 证书，以识别出正确的证书。 以 150 tps 的到达速度运行了 5 分钟，我们观察到 220K 这样的验证，其中 96K 验证失败，这导致 CPU 和时间的浪费。 Guideline 3: To achieve a high performance, define policies with a fewer number of sub-policies and signatures. 要获得高性能，定义策略时使用较少的子策略和签名。 Action Item 2: As the cryptography operations are CPU intensive, we can avoid certain routine operations by maintaining a cache of deserialized identity and their MSP information as shown in §VI-A. This does not introduce a security risk as identities are long-lived and separate Certificate Revocation Lists (CRLs) are maintained. 由于加密操作是 CPU 密集型操作，我们可以通过维护反序列化身份及其 MSP 信息的缓存来避免某些常规操作，如第 VI-A 节所示。这不会带来安全风险，因为身份是长期的，并且维护单独的证书吊销列表（CRL）。 C. Impact of Channels and Resource Allocation We categorize the arrival rate for different channel count into two categories; non-overloaded when the latency range was [0.4-1s] and overloaded when the latency range was [30-40s]. Figure 8 plots the average throughput and CPU utilization for these two categories. Table IV presents a various number of channels and transaction arrival rate used for this study. For other parameters, refer to Table I. All peers joined all the channels as described in §IV. 我们将不同通道数的到达率分为两类： 时延范围为[0.4-1s]时不过载，时延范围为[30-40s]时过载。 图8绘制了这两类的平均吞吐量和CPU利用率。 表IV列出了用于此研究的各种通道和交易到达率。 有关其他参数，请参阅表I。所有对等方都按照§IV中的说明加入了所有通道。 Observation 7: With the increase in the number of channels, the throughput increased and latency decreased. The resource utilization such as CPU also increased as shown in Figure 8. For e.g., with the increase in the number of channels from 1 to 16, the throughput increased from 140 tps to 832 tps (i.e., by 6× in non-overloaded case) and to 1320 tps (i.e., 9.5× in overloaded case). This is because each channel is independent of others and maintains its own chain of blocks. Hence, the validation phase and the final ledger update of multiple blocks (one per channel) executed in parallel which increased CPU utilization that resulted in higher throughput. 如图 8 所示，随着通道数的增加，系统的吞吐量增加，时延减小。CPU 等资源利用率也增加了。例如，随着信道数目从 1 增加到 16，吞吐量从 140 tps 增加到 832 tps（即，在非过载情况下增加 6 倍）或增加到 1320 tps（即，在过载情况下增加 9.5 倍）。这是因为每个通道都独立于其他通道，并维护自己的区块链。因此，多个块（每个通道一个）的验证阶段和最终账本的更新都是并行执行，这提高了 CPU 利用率，从而提高了吞吐量。 Figure 9(a) and (b) plot the throughput, endorsement &amp; commit latency for 4 and 16 channels, respectively, over a different number of allocated vCPUs but homogeneous peers. Figure 9(c) plots the absolute (instead of average) CPU utilization across all vCPUs. Table V presents a various number of vCPUs allocated, the number of channels and transaction arrival rate used. For other parameters, refer to Table I. 图9（a）和（b）分别绘制了 4 个和 16 个通道在同构节点但不同数量的 vcpu 分配上的吞吐量、背书和提交延迟。图9（c）描绘了所有 vcpu 的绝对（而不是平均）CPU 利用率。表 V 显示了分配的各种 VCPU 数、使用的通道数和交易到达率。其它参数见表 I。 Observation 8: At moderate loads, when the number of vCPUs allocated were lesser than the channel count, performance degraded. For e.g., When the number of vCPUs allocated were lesser than 16 for 16 channels, the throughput reduced significantly from 848 tps to 32 tps (by 26×) – refer to Figure 9(b). Further, both the average endorsement and commit latency exploded (from 37 ms to 21 s, and 640 ms to 49 s, respectively) due to a lot of contention on the CPU. Further, a significant number of requests got a timeout during the endorsement phase. Once a timeout occurs, we marked that transaction as failed. With an allocation of 2 vCPUs, a higher number of endorsement requests got a timeout as compared to 4 vCPUs. Thus, the endorsement and commit latency (of successful transactions) observed with 2 vCPUs were lesser than 4 vCPUs as shown in Figure 9(b). 在中等负载下，当分配的 vCPU 数量少于通道数量时，性能会下降。 例如，当分配的 vCPU 数量少于 16 个通道的 16 个时，吞吐量从 848 tps 显着降低到 32 tps（降低了26倍）–参见图9（b）。 此外，由于 CPU 上的大量争用，背书和提交的平均延时都爆炸了（分别从 37 ms到 21s 和 640 ms 到 49 s）。 此外，在背书阶段，大量签名请求超时。 一旦超时，我们将该交易标记为失败。 与 4 个 vCPU 相比，分配 2 个 vCPU 会导致更多的背书请求超时。 因此，如图9（b）所示，使用 2 个 vCPU 观察到的（成功交易）背书和提交等待时间小于 4 个 vCPU。 Due to the CPU contention, the VSCC latency also increased that affected the commit latency as shown in Figure 9(c). Increasing the vCPUs allocation increased CPU utilization and consequently performance up-to a peak where vCPUs matched the number of channels. Beyond this, additionally allocated vCPUs were idle due to the single-threaded sequential VSCC validation – refer to Figure 9(c). 由于 CPU 争用，VSCC 延迟也增加了，这影响了提交延迟，如图9（c）所示。 增加 vCPU 分配增加了 CPU 利用率，因此性能达到了 vCPU 与通道数匹配的峰值。 除此之外，由于单线程顺序 VSCC 验证，额外分配的 vCPU 处于空闲状态 – 参见图9（c）。 Figure 9(d) plot the throughput and latency for 16 channels in a heterogeneous setup. Table VI presents a various number of vCPUs allocated for different peers to enable heterogeneity, the number of channels, transaction complexity and transaction arrival rate used. For other parameters, refer to Table I. 图9（d）绘制了异构设置中 16 个通道的吞吐量和等待时间。 表 VI 列出了分配给不同节点的各种 vCPU，以实现异构性、通道数、交易复杂性和所使用的交易到达率。 有关其他参数，请参阅表 I。 Observation 9: At moderate loads, even when the number of vCPUs allocated for 2 peers out of 8 were lesser than the channel count, performance degraded. For e.g., when only 2 vCPUs were allocated for 2 peers (others with 32 vCPUs), the throughput reduced from 848 tps to 417 tps (by 2×) for write-only transactions and to 307 tps (by 2.7×) for readwrite transactions. The reasons for the reduction are twofold, endorsement requests timeout from less powerful peers and MVCC conflicts specifically for read/write transactions. Figure 10(a) plots the endorsement requests timeout, valid transactions and invalid transactions due to MVCC conflicts for readwrite transactions. With an increase in the number of less powerful peers, the endorsement requests timeout increased. Further, a higher proportion of total submitted transactions became invalid due to MVCC conflicts. The is because of the lower block commit rate at less powerful peers as compared to powerful peers. Due to the different block height at peers (refer to Figure 10(b)), there was a mismatch of key’s version in the read-set collected. As a result, MVCC conflicts occurred during the state validation which invalidated transactions. 在中等负载下，即使为 8 个中的 2 个节点分配的 vCPU 数量少于通道数，性能也会下降。例如，当仅为 2 个对等节点分配 2 个 vCPU 时（其他具有 32 个vCPU），仅写交易的吞吐量从 848 tps 减少到 417 tps（2倍），而读写操作减少到307 tps（2.7倍）。 减少的原因有两个：支持能力较弱的节点背书请求超时，以及专门针对读/写交易的 MVCC 发生冲突。 图10（a）描绘了由于读写交易的 MVCC 冲突而导致的背书请求超时，有效交易和无效交易。随着能力较弱节点的数量增加，背书请求超时也增加了。 此外，由于 MVCC 冲突，提交的交易中有较高比例变得无效。这是因为与功能强大的节点相比，功能较弱的对等节点的块提交率较低。由于对等节点的块高度不同（请参见图10（b）），因此收集的读取集中的密钥版本不匹配。结果，在状态验证期间发生了 MVCC 冲突，使交易无效。 Though we have not studied the impact of network resources, we believe that the impact would be similar to that of CPU. This is because, with a low network bandwidth, the delay in both the block and transaction delivery would increase. Even with the heterogeneous network resources for peers, we expect the impact to be similar to the one we observed with CPU. 尽管我们尚未研究网络资源的影响，但我们认为影响将与 CPU 相似。 这是因为在低网络带宽的情况下，块和交易传递的延迟都会增加。 即使使用对等节点的异构网络资源，我们预期其影响与我们在 CPU 上观察到的影响相似。 Guideline 4: To achieve higher throughput and lower latency, it is better to allocate at least one vCPU per channel. For optimal vCPU allocation, we need to determine the expected load at each channel and allocate adequate vCPUs accordingly. 为了获得更高的吞吐量和更低的延迟，最好为每个通道分配至少一个 vCPU。 为了获得最佳的 vCPU 分配，我们需要确定每个通道的预期负载，并相应地分配足够的 vCPU。 Guideline 5: To achieve higher throughput and lower latency, it is better to avoid heterogeneous peers as the performance would be dictated by less powerful peers. 为了获得更高的吞吐量和更低的延迟，最好避免异构节点，因为性能将由功能较弱的节点决定。 Action Item 3: Processing transactions within a channel and across channels can be improved to better utilize additional CPU power as shown in §VI-B. 如 §VI-B 所示，可以改进通道内和通道间的交易处理，以更好地利用额外的 CPU 功能。 D. Impact of Ledger Database Figure 11 plots the average throughput and latency over multiple transaction arrival rates for both GoLevelDB and CouchDB with different transaction complexities. Table VII presents various databases, transaction complexity and arrival rate used. For other parameters, refer to Table I. 图 11 绘制了具有不同交易复杂性的 GoLevelDB 和 CouchDB 在多个交易到达率上的平均吞吐量和延迟。 表 VII 列出了使用的各种数据库，交易复杂性和到达率。 有关其他参数，请参阅表 I。 Observation 10: The Fabric transaction throughput with GoLevelDB as state database was 3*× *greater than CouchDB. The maximum throughput achieved with GoLevelDB on a single channel was 140 tps (refer to Figure 4) while with CouchDB, it was only 50 tps (refer to Figure 11(b)). Further, with an increase in the transaction complexity, i.e., for multiple writes, the throughput with CouchDB dropped from 50 tps to 18 tps while no such impact with GoLevelDB (refer to Figure 11(a)). The reason for significant performance differences between CouchDB and GoLevelDB is that the latter is an embedded database to peer process while former is accessed using REST APIs over a secure HTTP. As a result, the endorsement latency, VSCC latency, MVCC latency and the ledger update latency was higher with CouchDB as compared to the GoLevelDB as shown in Figure 12(a) &amp; (b). With CouchDB, the VSCC latency increased compared to the GoLevelDB as the peer accessed state database using a REST API call for every transaction to retrieve the endorsement policy of the chaincode on which the transaction was simulated. Similarly, the MVCC latency also increased with CouchDB. 使用 GoLevelDB 作为状态数据库的 Fabric 交易吞吐量比 CouchDB 高 3 倍。使用 GoLevelDB 在单个通道上实现的最大吞吐量为140 tps（请参见图4），而对于CouchDB，则仅为50 tps（请参见图11（b））。 此外，随着交易复杂度的增加，即对于多次写入，CouchDB 的吞吐量从 50 tps 下降到 18 tps，而 GoLevelDB 则没有这种影响（请参见图11（a））。 CouchDB 和 GoLevelDB 之间的显着性能差异的原因是，后者是节点进程的嵌入式数据库，而前者是通过 REST API 通过安全 HTTP 访问的。 结果如图12（a）和（b）所示，与 GoLevelDB 相比，CouchDB 的背书等待时间，VSCC 等待时间，MVCC 等待时间和账本更新等待时间更高。 与 GoLevelDB 相比，使用 CouchDB 时，VSCC 延迟增加了，因为节点访问状态数据库使用 REST API 调用每个交易来检索在其上模拟交易的链码的背书策略。 同样，CouchDB 也增加了 MVCC 延迟。 Observation 11: With CouchDB, the endorsement latency and ledger update latency increased with an increase in the number of writes per transaction, i.e., from 40 ms and 240 ms with one write to 800 ms and 1200 ms with three writes, respectively, as shown in Figure 12(b) even though write-only transactions do not access the database during the endorsement phase. This is because the endorsement phase acquired a shared read lock on the whole database to provide a consistent view of data (i.e., repeatable read isolation level) to the chaincode. Similarly, the final ledger update phase acquired an exclusive write lock on the whole database. Hence, both the endorsement phase and final ledger update contended for this resource. Especially, the final ledger update with CouchDB was costlier as it had to perform the following three tasks for each key-value write in a transaction’s write-set. 如图12（b）所示，使用 CouchDB 时，背书等待时间和账本更新等待时间随着每笔交易的写入次数的增加而增加，即从一次写入的 40ms 和 240ms 增加到三次写入的 800ms 和 1200ms，即使只写交易在背书阶段也不访问数据库。 这是因为背书阶段获得了整个数据库的共享读取锁定，以便为链码提供一致的数据视图（即可重复读取隔离级别）。 同样，最后的账本更新阶段在整个数据库上获得了排他性写锁定。 因此，背书阶段和最终账本更新都为此资源竞争。 特别是，使用 CouchDB 进行的最终账本更新成本更高，因为它必须为交易的写入集中的每个键值写入执行以下三个任务。 Retrieve the key’s previous revision number (used for concurrency control within CouchDB) by issuing a GET request, if it exists in the database. Construct a document for the value (could be a JSON document or binary attachment). Update the database by submitting a PUT request. 如果数据库中存在 GET 请求，则通过发出 GET 请求来检索密钥的先前修订的版本号（用于 CouchDB 中的并发控制）。 为该值构造一个文档（可以是 JSON 文档或二进制附件）。 通过提交 PUT 请求来更新数据库。 As a result, with the increase in the number of writes per transaction, the ledger update latency increased (refer to Figure 12(b)). Due to the above three time consuming serial operations, we surmise that the committer held the lock on the database for a longer duration which increased endorsement latency. To validate our hypothesis, we performed experiments by disabling the lock acquisition on the whole database during the endorsement phase and final ledger update. The side effect of such action was only providing non-repeatable read isolation level at that chaincode. As our transaction was only writing keys, such side effect did not affect the database consistency. Figure 12(d) shows the improvement in endorsement phase. The average endorsement latency reduced from 800 ms to 40 ms, validating our hypothesis. 结果，随着每个交易的写入次数的增加，账本更新等待时间增加了（请参见图12（b））。 由于上述三个耗时的串行操作，我们推测提交者将锁锁定在数据库上的时间更长，从而增加了背书延迟。 为了验证我们的假设，我们通过在背书阶段和最终账本更新期间禁用整个数据库的锁获取来进行实验。 此类操作的副作用是在该链码上只提供了“不可重复的读取隔离级别”。 由于我们的交易只是写密钥，因此这种副作用不会影响数据库的一致性。 图12（d）显示了背书阶段的改进。 平均背书等待时间从 800ms 减少到 40ms，验证了我们的假设。 Observation 12: Only with an increase in the number of reads per transaction, the MVCC latency increased as shown in Figure 12(c). This is because with an increase in the number of items in the read set, the number of GET REST API calls to CouchDB increased during MVCC validation phase. With an increase in the number of writes, MVCC latency did not increase as shown in Figure 12(b) because it only checks whether any read keys has been modified. 如图12（c）所示，仅随着每个交易读取次数的增加，MVCC 延迟才增加。 这是因为随着读取集中项目的数量增加，在 MVCC 验证阶段，对 CouchDB 的 GET REST API 调用数量也增加了。 随着写入次数的增加，MVCC 延迟并没有增加，如图 12（b）所示，因为它仅检查是否已修改任何读取密钥。 Guideline 6: GoLevelDB is a better performant option for state database. CouchDB is a better choice if rich-query support for read-only transactions is important. When using CouchDB, design the application and transaction to read/write a fewer number of keys to accomplish a task. 对于状态数据库，GoLevelDB 是性能更好的选项。 如果对只读交易的富查询支持很重要，则 CouchDB 是更好的选择。 使用 CouchDB 时，设计应用程序和交易以读取/写入较少数量的键即可完成任务。 Action Item 4: CouchDB supports bulk read/write operations without additional transactional semantics. Using the bulk operations will reduce the lock holding duration and improve the performance as demonstrated in §VI-C. CouchDB支持批量读/写操作，而无需其他交易语义。 如 §VI-C 所示，使用批量操作将减少锁保持时间并提高性能。 Action Item 5: The usage of database such as GoLevelDB and CouchDB, without the snapshot isolation level, results in whole database lock during the endorsement and the ledger update phase. Hence, our future work is to look at ways to remove the lock and/or use a database such as PostgreSQL that supports snapshot isolation. 在没有快照隔离级别的情况下，使用数据库（例如GoLevelDB和CouchDB）会在背书和账本更新阶段导致整个数据库锁定。 因此，我们的未来工作是研究删除锁和/或使用支持快照隔离的数据库（例如 PostgreSQL）的方法。 E. Scalability and Fault Tolerant In Fabric, scalability can be measured in terms of the number of channels, number of organizations joining a channel and the number of peers per organization. From a resource consumption perspective, the endorsement policy complexity controls the scalability of network. Even with a large number of organizations or peers, if the endorsement policy requires only a few organizations signature, then the performance would be the unaffected. This is because, the transaction needs to be simulated at a fewer node in the network to collect endorsement. Scalability could also be defined in terms of number of geographically distributed nodes and latency in block dissemination among them. Number of ordering service nodes and choice of consensus protocol used among them would also affect scalability. Though these are out of scope of this study, are important aspects of network scalability. 在 Fabric 中，可扩展性可以根据通道数量，加入通道的组织数量以及每个组织的对等节点来衡量。 从资源消耗的角度来看，背书策略的复杂性控制着网络的可扩展性。 即使有大量组织或节点，如果背书策略仅需要几个组织签名，那么性能将不会受到影响。 这是因为，需要在网络中较少的节点上模拟交易来收集背书。 还可以根据地理上分散的节点的数量和它们之间的块分发中的等待时间来定义可扩展性。 排序服务节点的数量以及在其中使用的共识协议的选择也会影响可扩展性。 尽管这些超出了本研究的范围，但它们是网络可扩展性的重要方面。 Node failures are common in a distributed system and hence, it is important to study the fault tolerant capability of Fabric. In our initial and early study, we observed that node failures do not affect the performance (during non-overloaded case) as client can collect endorsement from other available nodes. With higher loads, node rejoining after a failure and syncing up the ledger due to missing blocks was observed to have large delays. This is because though the block processing rate at the rejoined node was at the peak, other nodes continues to add new blocks at the same peak processing rate. 节点故障在分布式系统中很常见，因此，研究 Fabric 的容错能力很重要。 在我们的初期和早期研究中，我们观察到节点故障不会影响性能（在非过载情况下），因为客户端可以从其他可用节点收集认可。 对于更高的负载，观察到节点在故障后重新加入并由于缺少块而同步了账本，这会产生较大的延迟。 这是因为尽管重新加入的节点处的块处理速率处于峰值，但其他节点仍继续以相同的峰值处理速率添加新块。 VI. OPTIMIZATIONS STUDIED In this section, we introduce three simple optimizations based on action items listed in §V – (1) MSP cache in §VI-A, (2) parallel VSCC validation of a block in §VI-B, and (3) bulk read/write during MVCC validation &amp; commit for CouchDB in §VI-C. For each of these optimizations, first, we study the performance improvement individually. Then, we study the improvement by combining all the three optimizations. 在本节中，我们将基于 §V 中列出的操作项目介绍三种简单的优化方法-（1）§VI-A 中的 MSP 缓存，（2）§VI-B 中的块的并行 VSCC 验证，以及（3）§VI-C 中的在 MVCC 验证和提交期间对 CouchDB 批量读/写。 对于这些优化，首先，我们分别研究性能改进。 然后我们通过结合三个优化来研究改进。 A. MSP Cache As crypto operations are very CPU intensive, in this section, we studied the efficiency of using a cache at the following two operations in the crypto module: Deserialization of identity (i.e., x.509 certificate). Validation of identity with Organization’s MSP. 由于加密操作非常占用CPU，因此在本节中，我们研究了在加密模块中的以下两个操作中使用缓存的效率： 身份反序列化（即 x.509 证书）。 使用组织的 MSP 验证身份。 To avoid deserialization of the serialized identity every time, we cached the deserialized identity using a hash map with the serialized form as key. Similarly, to avoid validating an identity with multiple MSPs every time, we used a hash map with a key as identity and value as the corresponding MSP to which the identity belongs. Further, we employed the ARC algorithm for cache replacement. During identity revocations, we invalidated cache entries appropriately. 为了避免每次都对序列化标识进行反序列化，我们使用以序列化形式作为键的哈希映射对反序列化的标识进行缓存。 同样，为避免每次都使用多个 MSP 验证身份，我们使用了一个哈希图，其中键为身份，值为身份所属的相应MSP。 此外，我们采用了 ARC 算法来替换缓存。 在身份吊销期间，我们适当地使缓存条目无效。 Figure 13 plots the impact of MSP cache on the throughput and latency for AND/OR endorsement policies over different transaction arrival rates. Table III presents various policies used along with different transaction arrival rates. We draw the attention of the reader to Figure 6(b) for comparison against the no-cache behavior. On average, the throughput increased by 3× due to MSP cache as compared to a vanilla peer. For e.g., when the endorsement policy required signature from two endorsers (defined using AND/OR syntax), the maximum throughput achieved without MSP cache was 160 tps while with cache, it increased to 540 tps. This is because the MSP cache reduced certain repetitive CPU intensive operations. 图 13 绘制了 MSP 缓存对不同交易到达率下 AND / OR 背书策略的吞吐量和延迟的影响。 表 III 列出了使用的各种策略以及不同的交易到达率。 我们提请读者注意图6（b），以与无缓存行为进行比较。 平均而言，与普通节点相比，由于 MSP 缓存，吞吐量增加了 3 倍。 例如，当背书策略需要两个背书节点的签名（使用 AND / OR 语法定义）时，不使用 MSP 缓存时实现的最大吞吐量为 160 tps，而使用缓存时则达到 540 tps。 这是因为 MSP 缓存减少了某些重复的 CPU 密集型操作。 Figure 14 and 15 plots the flame graph showing frequency of crypto operations and call stack depth of VSCC validation phase in a vanilla peer and a peer with MSP cache, respectively. As it can be observed, the number of crypto operations and call stack depth reduced significantly with the MSP cache. 图 14 和 15 绘制了火焰图，分别显示了原始对等节点和具有 MSP 缓存的对等节点中的加密操作频率和 VSCC 验证阶段的调用堆栈深度。 可以看出，使用 MSP 缓存，加密操作的数量和调用堆栈的深度大大减少了。 B. Parallel VSCC Validation of a Block The VSCC validation phase validates each transaction in a block serially against the endorsement policy. As this approach under-utilized the resources, we studied the efficiency of parallel validation, i.e., validate multiple transactions’ endorsement in parallel to utilize otherwise idle CPU and improve the overall performance. To achieve this, we created a configurable number of worker threads per channel on peer startup. Each worker thread validates one transaction’s endorsement signature set against its endorsement policy. VSCC 验证阶段根据背书策略依次验证每个交易。 由于这种方法未充分利用资源，因此我们研究了并行验证的效率，即并行验证多个交易的背书，以利用空闲的 CPU 并提高整体性能。 为此，我们在对等节点启动时为每个通道创建了可配置数量的工作线程。 每个工作线程都会根据其背书策略验证一个交易的背书签名集。 Figure 16 plots the impact of parallel VSCC on the performance and resource utilization. We categorize the arrival rate for different channel count into two categories; non-overloaded case when the latency falls in [0.1-1s] and overloaded when the latency falls in [30-40s]. For each channel, we allocated worker threads equal to the block size. The throughput and resource utilization during the non-overloaded case for one channel exploded from 130 tps to 800 tps (improved by 6.3×) for the block size of 30 and to 980 tps (7.5×) for the block size of 300. This is due to parallel validation and hence the reduction in the VSCC latency (from 300 ms to 30 ms, i.e., by 10× reduction for the block size of 30). The throughput saturated at 950 tps (for the block size of 30) &amp; 1075 tps (for the block size of 300) – refer to Figure 16(a). 图 16 绘制了并行 VSCC 对性能和资源利用率的影响。 我们将不同通道数的到达率分为两类： 延迟小于[0.1-1s]时处于非过载情况，而延迟小于[30-40s]时处于过载状态。 对于每个通道，我们分配的工作线程等于块大小。 一个通道在非过载情况下的吞吐量和资源利用率从块大小为 30 的 130 tps 激增至 800 tps（提高了6.3倍），块大小为 300 的吞吐量和资源利用率激增至 980 tps（7.5倍）。 由于并行验证，因此减少了 VSCC 延迟（从 300 毫秒减少到 30 毫秒，即对于 30 的块大小减少了 10 倍）。 吞吐量达到 950 tps（对于 30 块的块）和 1075 tps（对于 300块）达到饱和–请参见图16（a）。 Similarly, the throughput and resource utilization during the overloaded case increased to 1.5× for 16 channels to as much as 10× for 1 channel – refer to Figure 16(b). This shows that parallel VSCC validation of a block significantly increases the performance of a single channel. With an increase in the number of channels, the percentage of improvement decreased. This is because multiple channels by default result in the parallel validation of blocks (instead of transactions) and hence a few number of free vCPUs were available for parallel VSCC. 同样，过载情况下 16 通道的吞吐量和资源利用率增加 1.5 倍， 1 通道增加 10 倍–参见图16（b）。 这表明块的并行 VSCC 验证显着提高了单个通道的性能。 随着通道数量的增加，改善的百分比降低了。 这是因为默认情况下，多个通道会导致块的并行验证（而不是交易），因此，有几个可用的 vCPU 可用于并行 VSCC。 C. Bulk Read/Write During MVCC Validation &amp; Commit During the MVCC validation, with CouchDB as the state database, for each transaction in a block, for each key in the read set of the transaction, a GET REST API call to the database over a secure HTTPS retrieved the last committed version number. During the commit phase, for each valid transaction (recorded after MVCC validation) in a block, for each key in the write set of the transaction, a GET REST API call retrieved the revision numbers. Finally, for each entry in the write set, a PUT REST API call committed the document. Due to these multiple REST API calls, performance degraded significantly as demonstrated in §V-D. 在 MVCC 验证期间，以 CouchDB 作为状态数据库，对于块中的每个交易，对于交易的读取集中的每个键，通过安全 HTTPS 对该数据库的 GET REST API 调用都检索到最后提交的版本号。 在提交阶段，对于块中的每个有效交易（在 MVCC 验证后记录），对于交易的写集中的每个键，GET REST API 调用都会检索修订号。 最后，对于写集中的每个条目，都会通过 PUT REST API 调用提交文档。 由于有多个 REST API 调用，因此性能大大降低，如§V-D所示。 To cut down the number of REST API calls, CouchDB suggests using bulk operations. Hence, we used the existing BatchRetrieval API in Fabric to batch load multiple keys’ version and revision number into the cache over a single GET REST API call per block. To enhance the ledger update process, we used BatchUpdate API in Fabric to commit a batch of documents using a single PUT REST API call per block. Further, we introduced a cache in VSCC to reduce the calls to CouchDB to obtain the endorsement policy of the chaincode for each transaction. In this section, we show the efficiency of these enhancements on the overall performance. 为了减少 REST API 调用的数量，CouchDB 建议使用批量操作。 因此，我们使用 Fabric 中现有的 BatchRetrieval API 通过每个块一次 GET REST API 调用将多个密钥的版本和修订号批量加载到缓存中。 为了增强账本更新过程，我们在 Fabric 中使用 BatchUpdate API 通过每个块一个 PUT REST API 调用来提交一批文档。 此外，我们在 VSCC 中引入了缓存，以减少对 CouchDB 的调用，以获取每个交易的链码的背书策略。 在本节中，我们将展示这些增强功能对整体性能的效率。 Figure 17 plots the throughput and latency when running a CouchDB as the state database with the bulk read/write optimization. For comparison against the non-bulk read/write, refer to Figure 11(b) and Figure 12. The performance increased significantly from 50 tps to 115 tps (i.e., by 2.3×) for transactions with a single write. For multiple writes (3-w &amp; 5-w), the throughput increased from 26 tps to 100 tps (i.e., 3.8× for 3-w), and 18 tps to 90 tps (i.e., 5× for 5-w). We noticed similar improvements for read-write transactions. 图 17 绘制了运行 CouchDB 作为状态数据库时批量读/写优化的吞吐量和延迟。 为了与非批量读取/写入进行比较，请参考图11（b）和图12。对于一次写入的交易，性能从 50 tps 显着提高到 115 tps（即，提高了 2.3 倍）。 对于多次写入（ 3-w 和 5-w），吞吐量从 26 tps 增加到 100 tps（即 3-w为3-x），从 18 tps 增加到 90 tps（即 5-w 为 5 倍）。 我们注意到读写交易也有类似的改进。 Due to the bulk read/write optimization, the MVCC latency, ledger update latency and endorsement latency decreased as shown in Figure 17(c) and (d) as compared to Figure 12. The reduction in endorsement latency (by at least 3×) was because of the reduction in lock holding duration by the commit phase (by at least 8×). The MVCC latency for read-write transactions reduced (by at least 6×) due to a bulk reading of all keys in the read set of all transactions in a block. Note that the MVCC latency increased with the increase in the number of keys read in a bulk read. The ledger update latency of a block encompassing a higher number of writeonly transactions was higher. This is because, in read-write transactions, the MVCC validation phase itself loaded the required revision numbers into the cache (as the transaction read those keys before modification) which was not the case with write-only transactions. 由于批量读/写优化，图17（c）和（d）与图 12 相比，MVCC 延迟、账本更新延迟和背书延迟减少。背书延迟减少了（至少3倍） 这是因为提交阶段的锁保持时间减少了（至少减少了8倍）。 由于块中所有交易的读取集中的所有密钥都是批量读取，因此读写交易的 MVCC 延迟减少了（至少6倍）。 注意，MVCC 延迟随着批量读取中读取的键数的增加而增加。 包含更多只写交易的块的账本更新等待时间更长。 这是因为，在读写交易中，MVCC 验证阶段本身将所需的修订号加载到缓存中（因为交易在修改之前读取了这些键），而对于只写交易则不是这种情况。 D. Combinations of Optimizations Figure 18 plots the performance improvement achieved with all three optimizations combined. Table IX presents the number of VSCC worker threads per channel, block sizes, and other relavant parameters used for this study. 图 18 列出了三个优化相结合所实现的性能改进。 表 IX 列出了用于此研究的每个通道的 VSCC 工作线程数，块大小和其他相关参数。 With GoLevelDB as the state database, the single channel throughput increased to 2250 tps from 140 tps (i.e., 16× improvement) due to all three optimizations – refer to Figure 18(a) and Figure 4. Similarly, with CouchDB as the state database, the singe channel throughput increased to 700 tps from 50 tps (i.e., 14× improvement) – refer to Figure 18(b) and Figure 11. With an increase in the block size, when CouchDB was the state database, we observed a lower total latency due to the reduction in the number of bulk REST API call to CouchDB (i.e, for 500 transactions, only 2 bulk REST API calls, one read call during MVCC phase and one write during commit phase, were issued when the block size was 500 as compared to 10 bulk REST API calls for a block size of 100). As a result, our guideline 1 &amp; 2 are not applicable for CouchDB with bulk read/write optimizations. 使用 GoLevelDB 作为状态数据库，由于三个优化，单通道吞吐量从 140 tps 增加到了 2250 tps（即提高了16倍）–参见图18（a）和图4。类似地，使用 CouchDB 作为状态数据库 ，单通道吞吐量从 50 tps 增加到 700 tps（即提高了14倍）–参见图18（b）和图11。当 CouchDB 是状态数据库时，由于减少了对 CouchDB 的批量 REST API 调用的数量而导致的总延迟，随着块大小的增加，我们观察到更低的吞吐量（对于 500 个交易，当块大小为 500 时，仅发出 2 个批量 REST API 调用，在MVCC阶段进行一次读调用，在提交阶段进行一次写操作，而对于块大小为 100 时进行 10 次批量 REST API 调用） 。 因此，我们的准则 1 和 2 不适用于具有批量读/写优化功能的 CouchDB。 Further, for 8 and 16 channels, the throughput increased to 2700 tps from 1025 tps and 1321 tps, respectively as shown in Figure 19(a). With a simpler endorsement policy, i.e., 1st AND/OR policy, the single channel throughput also increased to 2700 tps (with GoLevelDB) as shown in Figure 19(b). 此外，对于 8 和 16 通道，吞吐量分别从 1025 tps 和 1321 tps 增加到 2700 tps，如图19（a）所示。 使用更简单的背书策略（即第一个 AND / OR 策略），单通道吞吐量也增加到了 2700 tps（使用 GoLevelDB），如图19（b）所示。 Even with a throughput of 2700 tps, the average CPU utilization of a peer was only 60% and the network utilization of a peer was 1680 Mbps (send) and 240 Mbps (receive). This is because the sum of MVCC latency and ledger update latency (less CPU intensive tasks) was almost same or higher than the VSCC latency (as shown in Figure 18(c) and (d)). Due to these sequential phases, vCPUs were underutilized. One potential optimization would be to pipeline the VSCC and MVCC validation phase. 即使吞吐量为 2700 tps，对等节点的平均 CPU 利用率也仅为 60％，网络利用率为1680 Mbps（发送）和 240 Mbps（接收）。 这是因为 MVCC 延迟和账本更新延迟的总和（较少的 CPU 密集型任务）与 VSCC 延迟几乎相同或更高（如图18（c）和（d）所示）。 由于这些顺序的阶段，vCPU 未被充分利用。 一种潜在的优化方法是管道 VSCC 和 MVCC 验证阶段。 VII. RELATED WORK There has been considerable interest in the scalability and performance characteristics of public blockchain networks and specifically the limiting factor of the consensus protocol and its security implications [31], [23]. 人们对公共区块链网络的可扩展性和性能特征，特别是共识协议的限制因素及其安全性有着相当大的兴趣。 Also for public blockchains, [19] have looked at quantifying throughput, latency, bootstrap time and cost per transaction for the Bitcoin network based on publicly available data. 同样对于公共区块链，[19] 已经研究了基于可公开获得的数据来量化比特币网络的吞吐量，等待时间，自举时间和每笔交易成本。 BlockBench [22] was one of the first to look at permissioned blockchain. They present a framework for comparing performance of different blockchain platforms, namely, Ethereum, Parity and Hyperledger Fabric using a set of micro and macro benchmarks. Similar to [19] they generalize consensus, data, execution and application as 4 layers of blockchain and use the benchmarks to exercise them. They measure the overall performance in terms of throughput, latency and scalability of the platforms and draw conclusions across the 3 platforms. However, they studied the performance of Fabric v0.6, with v1.0 version bringing in a complete re-design, their observations do not hold relevance and needs re-study. BlockBench [22] 是最早研究许可区块链的人之一。 他们提出了一个框架，用于使用一组微观和宏观基准来比较不同区块链平台（以太坊，Parity 和 Hyperledger Fabric）的性能。 与 [19] 相似，他们将共识，数据，执行和应用概括为4层区块链，并使用基准对其进行了实践。 他们根据平台的吞吐量，延迟和可伸缩性来衡量整体性能，并在这三个平台上得出结论。 但是，他们研究了 Fabric v0.6 的性能，而 v1.0 版本带来了完整的重新设计，他们的观察结果没有任何意义，需要重新研究。 [16] presents the design and the new architecture of Fabric, delving in-depth into its design considerations and modularity. It presents the performance of a single Bitcoin like crypto currency application on Fabric, called Fabcoin, which uses a customized VSCC to validate the Fabcoin specific transactions and avoid complex endorsements and channels. Further, they used CLI command to emulate clients, which is not realistic, instead of using a SDK [6], [8], [10]. Our work differs from theirs in that, we do a comprehensive study for different workloads keeping Fabric’s modularity and application in multiple domains in focus. [16] 介绍了 Fabric 的设计和新架构，深入研究了其设计考虑因素和模块化。 它展示了 Fabric 上单个比特币（如加密货币）应用程序的性能，称为 Fabcoin，该应用程序使用定制的 VSCC 来验证 Fabcoin 特定交易并避免复杂的认可和通道。 此外，他们使用 CLI 命令来模拟客户端，这是不现实的，而不是使用 SDK [6]，[8]，[10]。 我们的工作与他们的不同之处在于，我们针对不同的工作负载进行了全面的研究，以确保Fabric的模块化和在多个领域中的应用为重点。 A note to the reader, [16] used Fabric v1.1-preview release, which incorporates all our optimizations and other additional functionalities over v1.0. However, being a minor version update much of the core functionality remains the same and our observations hold true for v1.1 and future versions based on the new architecture of Fabric. 给读者的说明，[16] 使用 Fabric v1.1-preview 版本，该版本合并了我们在 v1.0 上的所有优化和其他附加功能。 但是，作为次要版本更新，大部分核心功能保持不变，并且我们的观察对于基于 Fabric 的新体系结构的 v1.1 和将来版本仍然适用。 VIII. CONCLUSION &amp; FUTURE WORK In this paper, we conducted a comprehensive empirical study to understand the performance of Hyperledger Fabric, a permissioned blockchain platform, by varying values assigned to configurable parameters such as block size, endorsement policy, channels, resource allocation, and state database choices. As a result of our study, we provided six valuable guidelines on configuring these parameters and also identified three major performance bottlenecks. Hence, we introduced and studied three simple optimizations such as MSP cache, parallel VSCC validation, and bulk read/write during MVCC validation &amp; commit phase to improve the singe channel performance by 16×. Further, these three optimizations have been successfully adopted in Fabric v1.1 在本文中，我们进行了一项全面的实证研究，以了解通过更改分配给可配置参数（例如区块大小，背书策略，通道，资源分配和状态数据库选择）的值来了解许可的区块链平台 Hyperledger Fabric 的性能。 作为我们研究的结果，我们提供了六种有关配置这些参数的有价值的指南，并且确定了三个主要的性能瓶颈。 因此，我们引入并研究了三种简单的优化方法，例如 MSP 缓存，并行 VSCC 验证以及 MVCC 验证和提交阶段期间的批量读/写，以将单通道性能提高 16 倍。 此外，这三个优化已在 Fabric v1.1 中成功采用 As a part of future work, we will study the scalability and fault tolerant capability of Fabric by using different blockchain topologies such as different number of organizations and different number of nodes per organization. Further, we plan to quantify the impact of various consensus algorithms and number of nodes in the ordering service on the performance of different workloads. In our study, we assumed that the network is not a bottleneck. However, in the real world setup, nodes can be geographically distributed and hence, the network might play a role. In addition, the arrival rates in real world production system would be following certain distributions. Hence, we will study the performance of Fabric in Wide Area Network (WAN) with different arrival rate distributions. 作为未来工作的一部分，我们将通过使用不同的区块链拓扑来研 究Fabric 的可扩展性和容错能力，例如不同的组织数量和每个组织的节点数量。 此外，我们计划量化订购服务中各种共识算法和节点数对不同工作负载性能的影响。 在我们的研究中，我们假设网络不是瓶颈。 但是，在现实世界中，节点可以在地理位置上分布，因此网络可能会发挥作用。 另外，实际生产系统中的到达率将遵循某些分布。 因此，我们将研究具有不同到达速率分布的广域网（WAN）中光纤的性能。 IX. ACKNOWLEDGEMENTS We wish to acknowledge our following colleagues for their valuable assistance to our work. Our proposed optimizations were successfully adopted to Fabric, thanks to fabric developers who took care of submitting patches to Fabric v1.1. Angelo De Carlo (MSP Cache), Alessandro Sorniotti (Parallel Validation). Thanks to David Enyeart, Chris Elder, Manish Sethi for their proposal on Bulk Read from CouchDB. We would like to thank Yacov Manevich for his consistent help. 我们谨感谢以下同事为我们的工作提供的宝贵帮助。 我们的建议优化已成功地被 Fabric 采纳，这要归功于 Fabric开发人员负责向 Fabric v1.1 提交补丁。 Angelo De Carlo（MSP缓存），Alessandro Sorniotti（并行验证）。 感谢 David Enyeart，Chris Elder 和 Manish Sethi 提出的有关 CouchDB 批量读取的建议。 我们要感谢 Yacov Manevich 的一贯帮助。","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://ziiyan.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"精读","slug":"精读","permalink":"http://ziiyan.github.io/tags/%E7%B2%BE%E8%AF%BB/"}]},{"title":"阿里AE技术部-一面","slug":"阿里巴巴-AE技术部-一面凉经","date":"2020-04-02T13:40:50.000Z","updated":"2020-07-27T09:29:29.952Z","comments":true,"path":"2020/04/02/阿里巴巴-AE技术部-一面凉经/","link":"","permalink":"http://ziiyan.github.io/2020/04/02/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-AE%E6%8A%80%E6%9C%AF%E9%83%A8-%E4%B8%80%E9%9D%A2%E5%87%89%E7%BB%8F/","excerpt":"","text":"30 分钟凉经 为什么选前端 你认为前端需要什么能力 介绍一下项目 卡片和线装饰，线是用 svg 图片，高亮点沿线移动，用 kute.js 动画库 不用 svg 的话可以用什么？ canvas 当时为什么不用 不会画…… 项目这边应该是给了很不好的印象了，最后有跟我提到技术选型的问题 项目在你接手之前和之后有什么不同吗？有没有做什么优化 没有…… css position 的取值 static absolute relative fixed static 和 fixed 有什么区别？ fixed 是相对于浏览器窗口定位的，static 我没用过不是太了解 css 选择器 权重叠加，important 最高，id 选择器第二 事件冒泡和事件捕获的场景 冒泡是点击的元素沿着 DOM 树一级级向上直到 Document，捕获相反 场景想不到，举了一个之前做项目的例子，currentTarget，onmousedown.stop 项目用什么框架？打包原理清楚吗？webpack 之类的有配置过吗 Vue webpack 了解过，根据入口去找相关依赖，然后依赖导入的时候会用到 loader 配置了一个，就是让 .map 文件不打包出来，这样最终的包会小一点 这一块其实没听太清楚，电话声音有点小，大概意思就是只是用了脚手架提供的功能，内置的东西没有去深入了解，不知道整个构建流程 感觉面试官是用 react 的，我说 vue 之后就没什么兴趣问了 图片懒加载怎么做的 这个不清楚 说一下 cookie sessionStorage 标签之间不共享，localstorage 永久存储， cookie 可以设置过期时间所以项目用了 cookie 跨域 平时一般是 CORS，还有就是 jsonp，jsonp 是利用 html 标签的 src 属性没有浏览器安全的限制，用回调函数实现跨域 CORS 有配置过吗 没有，都是后端配的 有没有做过服务端 写过 sdk，应该不算服务端吧 有什么补充的吗 之前调 bug 的时候用到 setTimeout(0)，就顺便学到了事件循环机制和 js 运行机制，后来回顾的时候知道 vue 里有个 nextTick，算是误打误撞实现了 nextTick 和 setTimeout 有什么区别 nextTick 是让回调函数在下一次页面渲染之后再去执行，setTimeout 只是实现 nextTick 的一种方式，也可以用 Promise 实现，这个会判断浏览器的支持情况 我以为这边会顺着问一下事件循环机制和js运行机制，没想到问了个 nextTick 最后我是问对我今后的学习有什么建议？ 系统学一下前端基础，不要是做项目做到了才去学。在做项目的时候要了解一下业界比较流行的做法，前端更新比较快，注意性能上的一些优化。 可能是看我做了项目吧，大多数问题都是从项目入手的，我项目也做的不太好，应该说没整理好，没讲清楚也没体现技术，这也和我平时做项目能用就行的想法有关系。 确实对旧项目没有做过优化，做新功能的时候技术选型也有问题，就是他说的项目用到了才匆匆忙忙去学。 准备面试的时候都是在看 js 基础相关的，比较奇怪的是问了好多优化的东西，js 反而一点没问，后面又说我基础不太好（虽然确实是不太好），以为一面会问很多基础，没想到都没怎么问 其实面着面着就知道自己凉了，总觉得对面已经招够了，也不太有兴趣问下去的感觉","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ziiyan.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"SpringBoot","slug":"SpringBoot入门","date":"2020-04-02T06:11:47.000Z","updated":"2020-04-02T06:12:11.228Z","comments":true,"path":"2020/04/02/SpringBoot入门/","link":"","permalink":"http://ziiyan.github.io/2020/04/02/SpringBoot%E5%85%A5%E9%97%A8/","excerpt":"","text":"Spring Boot 入门Srping Boot 简介 简化 Spring 应用开发的一个框架； 整个 Spring 技术栈的一个大集合； J2EE 开发的一站式解决方案； 微服务微服务：架构风格（微服务化） 一个应用应该是一组小型服务；可以通过 HTTP 的方式进行互通； 每一个功能元素最终都是一个可独立替换和独立升级的软件单元； Hello World 探究POM文件父项目1234567891011121314 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt;// 它的父项目是（cmd+鼠标左键点击 spring-boot-starter-parent 查看） &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt; &lt;/parent&gt;// 真正管理 Spring Boot 应用里所有依赖版本 启动器spring-boot-starter-web spring-boot-starter：SpringBoot 场景启动器 Spring Boot 将所有的功能场景都抽取出来，做成一个个启动器，只需要在项目引入这些启动器相关场景都所有依赖都会导入进来，要什么功能就导入什么启动器 spring-boot-starter-web：帮我们导入了 web 模块正常运行所依赖的组件 主程序类，主入口类123456@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; @SpringBootApplication：说明这个类是主配置类，运行该类的 main 方法启动 SpringBoot 应用 123456789101112131415@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;) @SpringBootConfiguration：SpringBoot 的配置类 标注在某个类上，表示这是一个 SpringBoot 的配置类 @Configuration：配置类上标注这个注解 @Component：说明这也是一个spring的组件 @EnableAutoConfiguration：自动配置 @AutoConfigurationPackage：自动配置包 @Import({Registrar.class}) Spring 的底层注解，给容器中导入一个组件：导入的组件由 Registrar.class 指定 将主配置类（@SpringBootApplication标注的类）的所在包以及下面所有子包里面的所有组件扫描到 Spring 容器 @Import({AutoConfigurationImportSelector.class})：自动配置导入选择 导入哪些组件的选择器 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； 会给容器导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； META-INF/spring.factories：自动配置的核心文件 结论：Springboot 所有自动配置都是在启动的时候扫描并加载 spring.factories 所有的自动配置类都在这里面，但不一定生效，要判断条件是否成立，只要导入了对应的 start，就有对应的启动器了，有了启动器，我们自动装配就会生效，然后就配置成功 springboot 在启动的时候，从类路径下 /META-INF/spring.factories 获取指定的值 将这些自动配置的类导入容器，自动配置就会生效，帮我们进行自动配置 整合 javaEE，解决方案和自动配置的东西都在 spring-boot-autoconfigure-2.2.0.RELEASE.jar 这个包下 它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器 容器中也会存在非常多的 xxxAutoConfiguration 的文件（@Bean），就是这些类给容器中导入了这个场景需要的所有组件；并自动配置，@Configuration，JavaConfig 有了自动配置类，就免去了手动配置 使用 Spring Initialize 快速创建 Spring Boot 项目默认生成的 Spring Boot 项目 主程序已经生成好了，只需要编写自己的逻辑 resources 文件夹中目录结构 static：保存所有的静态资源；js css images templates：保存所有的模版页面；（Spring Boot 默认 jar 包使用嵌入式的 Tomcat，默认不支持 JSP 页面）；可以使用模版引擎 application.properties：SpringBoot 应用的配置文件：可以修改端口等 #配置文件 application.properties 语法结构：key=value application.yml（推荐） 语法结构：key:空格value Yaml 可以直接给实体类赋值 @ConfigurationProperties(prefix = “xxx”) JSR-303 校验 @validated 数据校验 配置文件位置及优先级 file: ./config/ file: ./ classpath: /config/ classpath:/ 自动装配原理 SpringBoot 启动会加载大量的自动配置类 看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中 在看这个自动配置类中到底配置了哪些组件（需要的组件有的话就不用手动配置了） 给容器中添加组件的时候，会从 properties 类中回去某些属性，只需要在配置文件中指定这些属性的值即可 xxxAutoConfiguration 自动配置类：给容器中添加组件 xxxProperties：封装配置文件中相关属性 SpringBoot Web 开发静态资源 在 springboot 中，可以使用以下方式处理静态资源 webjars public、static、/**、resources 优先级：resources &gt; static &gt; public 模版引擎12345678&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt;&lt;/dependency&gt; 前后端分离还有用吗这个？ SpringMVC 配置原理 在 Srpingboot 中，有非常多的 xxxConfiguration 帮助我们进行扩展配置","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://ziiyan.github.io/tags/Java/"}]},{"title":"图解HTTP","slug":"图解HTTP","date":"2020-04-01T12:50:07.000Z","updated":"2020-04-03T08:58:41.557Z","comments":true,"path":"2020/04/01/图解HTTP/","link":"","permalink":"http://ziiyan.github.io/2020/04/01/%E5%9B%BE%E8%A7%A3HTTP/","excerpt":"","text":"第一章 了解 Web 及网络基础使用 HTTP 协议访问 WebWeb 是建立在 HTTP 协议上通信的 HTTP 的诞生最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的 WWW（World Wide Web，万维网） HTML：把 SGML 作为页面的文本标记语言 HTTP：文档传递协议 URL：指定文档所在位置 WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。 现在则用来表示这一系列的集合，也可简称为 Web。 网络基础 TCP/IPHTTP 是 TCP/IP 协议族的一个子集 应用层 FTP、DNS、HTTP HTTP 数据 传输层 TCP、UDP TCP首部（HTTP数据） 网络层 IP 数据包 IP首部（TCP首部（HTTP数据）） 链路层 硬件 以太网首部（IP首部（TCP首部（HTTP数据））） IP 协议（负责传输） 作用：把各种数据包传送给对方 IP 地址 —ARP地址解析协议—&gt; MAC 地址 路由选择 TCP 协议（确保可靠性） 作用：提供可靠的字节流服务 字节流服务：为了方便传输，将大块数据分割成报文段（segment）为单位的数据包进行管理 可靠的传输服务：能够确认数据最终是否送达到对方 三次握手策略 发送端首先发送一个带有 SYN 标志的数据包给对方 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息 发送端再回传一个带 ACK 标志的数据包 DNS 服务（负责域名解析） 作用：域名 &lt;===&gt; IP 地址 各种协议与 HTTP 协议的关系 DNS 解析域名，得到对应 IP 地址 HTTP 协议生成 HTTP 请求报文 TCP 将请求报文分割成报文段 IP 协议路由寻址，一边中转一边传送 TCP 收到报文段，重组报文段 HTTP 队收到的请求进行处理 URI 和 URL URI（Uniform Resource Locator）统一资源标识符 URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。 第二章 简单的 HTTP 协议 HTTP 协议用于客户端和服务器端之间的通信 通过请求和相应的交换达成通信，必须先有请求才有响应 请求报文 请求方法 请求 URI 协议版本 可选的请求首部字段 内容实体 响应报文 协议版本 状态码（用以解释状态码的原因短语） 可选的响应首部字段 实体主体 HTTP 是不保存状态的协议 HTTP 是无状态协议，不保留之前一切的请求或响应报文的信息 为了实现期望的保持状态功能，引入 Cookie 技术 请求 URI 定位资源1234GET http:hackr.jp&#x2F;index.html HTTP&#x2F;1.1GET &#x2F;index.html HTTP&#x2F;1.1Host: hackr.jp 不是请求具体资源，而是针对服务器端本身的请求 * 代替 URI 1OPTIONS * HTTP&#x2F;1.1 HTTP 方法 GET：获取资源 请求访问已被 URI 识别的资源，资源经过服务器解析后返回 POST：传输实体主体 PUT：传输文件 请求报文主体中包含文件内容，保存到请求 URI 指定的位置 PUT 方法自身不带验证机制，任何人都可以上传，为了安全一般都不用 HEAD：获得报文首部 类似 GET，不返回报文主体，用于确认 URI 的有效性及资源更新的日期 DELETE：删除文件 按请求 URI 删除指定的资源 不带验证机制 OPTIONS（1.1）：询问支持的方法 查询针对请求 URI 指定的资源支持的方法 TRACE（1.1）：追踪路径 让 Web 服务前端将之前的请求通信环回给客户端 确认请求连接过程中发生的一系列操作 容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，不常用 CONNECT（1.1）：要求用隧道协议连接代理 SSL（Secure Sockets Layer，安全套阶层） TLS（Transport Layer Security，传输层安全） TCP 通信，使用以上两个协议加密 持久连接节省通信量HTTP/1.0 每进行一次 HTTP 通信就要断开一次 TCP 连接；一个网页包含很多资源，TCP 连接建立和断开会增加通信量的开销 keep-aliveHTTP/1.1 中，只要任意一端没有明确提出断开连接，就保持 TCP 连接状态 管线化从前发送请求后需等待并收到响应才能发送下一个请求 管线化技术出现后，不用等待响应就可以直接发送下一个请求，即能做到同时并行发送多个请求 Cookie通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态 Cookie 会根据从服务器端发送端响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去 第三章 HTTP 报文内的 HTTP 信息HTTP 报文本身是由多行数据构成的字符串文本 请求报文 响应报文 请求行 状态行 报 请求首部字段 响应首部字段 文 通用首部字段 通用首部字段 实体首部字段 实体首部字段 首 其他 其他 部 （空行） （空行） 报文主体 报文主体 报文主体和实体主体的差异 报文（message）：是 HTTP 通信中的基本单位，由 8 位组字节流组成，通过 HTTP 通信传输 实体（enentity）：作为请求或响应的有效载荷数据（补充项）被传输，内容由实体首部和实体主体组成 实体首部是报文首部的一部分（看上面的表格） 一般情况下，实体主体等于报文主体。传输过程中，为了提升传输速率，会对报文主体进行编码，这样报文主体就和实体主体不同了。 内容编码（压缩传输） 内容编码指明应用在实体内容上的编码格式。客户端接收并负责解码。 常用的内容编码 gzip（GNU zip） compress（UNIX 系统的标准压缩） deflate（zlib） identity（不进行编码） 分块传输编码在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。 通过把数据分割成多块，能够让浏览器逐步显示页面。 这种把实体主体分块的功能称为分块传输编码。 多部分对象集合（发送多种数据） multipart/form-data：Web表单文件上传 multipart/byteranges：状态码 206，响应报文包含多个范围的内容 使用多部分对象集合时，需要在首部字段加上 Content-type 使用 boundary 字符串来划分多部分对象集合指明的各类实体 范围请求（断点重传） 从之前下载的中断处恢复下载，仅下载指定的实体范围，称为范围请求 首部字段 Range 来指定资源的 byte 范围 针对范围请求，响应会返回状态码为 206 的响应报文 如果是多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 如果无法响应范围请求，会返回 200 和完整的实体内容 内容协商内容协商机制指客户端和服务器端就响应的资源内容进行交涉，提供最合适的资源 基准：语言、字符集、编码方式等 Accept Accept-Charset Accept-Encoding Accept-Language Content-Language 内容协商技术类型 服务器驱动协商 以请求的首部字段为参考，在服务器端自动处理，不一定筛出最优内容 客户端驱动协商 用户从浏览器显示的可选项列表中手动选择 利用 js 脚本在 Web 页面上进行选择 透明协商 第四章 返回结果的 HTTP 状态码 状态码的指责是当客户端向服务器端发送请求时，描述返回的请求结果 类别 原因短语 1xx Informational 接收的请求正在处理 2xx Success 请求正常处理完毕 3xx Redirection 需要进行附加操作以完成请求 4xx Client Error 服务器无法处理请求 5xx Server Error 服务器处理请求出错 2xx 成功 200 OK 204 No Content 206 Partial Content 3xx 重定向 301 Moved Permanently 永久性重定向，建议用户修改书签 302 Found 临时性重定向，希望用户（本次）能使用新的 URI 访问 303 See Other 请求对应的资源存在另一个 URI，且明确用 GET 访问 304 Not Modified 客户端发送附带条件的请求时，服务器端允许请求访问资源 If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since 307 Temporary Redirect 临时重定向 4xx 客户端错误 400 Bad Request 报文中存在语法错误 401 Unauthorized 发送的请求需要有通过 HTTP 认证的认证信息 403 Forbidden 该状态码表明对请求资源的访问呗服务器拒绝了 404 Not Found 服务器上无法找到请求的资源 5xx 服务器错误 500 Internal Server Error 服务器端在执行请求时发生了错误 503 Service Unavailable 超负载或停机维护，无法处理请求 第五章 与 HTTP 协作的 Web 服务器 通信数据转发程序 代理 转发功能的应用程序，不改变 URI 好处 利用缓存技术减少网络带宽的流量 组织内部针对特定网站的访问控制 获取访问日志 分类 缓存代理 透明代理：不对报文做任何加工 网关 转发其他服务器通信数据的服务器 好处 利用网关可以由 HTTP 请求转化为其他协议通信 隧道 按要求建立一条与其他服务器的通信线路，使用 SSL 等加密手段进行通信 目的 确保通信安全 隧道本身不去解析 HTTP 请求 缓存 缓存是指代理服务器或客户端本地磁盘内保存的资源副本 利用缓存可减少对源服务器的访问，节省了通信流量和通信时间 缓存过期后，会向源服务器确认资源的有效性 若缓存失效，浏览器会再次请求新资源 第六章 HTTP 首部报文首部HTTP 请求报文 报文首部 请求行：方法、URI、HTTP 版本 HTTP 首部字段 请求首部字段 通用首部字段 实体首部字段 其他 空行 报文主体 HTTP 响应报文 报文首部 状态行：HTTP 版本、状态码 HTTP 首部字段 响应首部字段 通用首部字段 实体首部字段 其他 空行 报文主体 HTTP 首部字段 首部字段名：字段值 1Content-Type: text&#x2F;html 分类 通用首部字段 请求首部字段 响应首部字段 实体首部字段 非 HTTP/1.1 首部字段 Cookie Set-Cookie Content-Disposition 通用首部字段 Cache-Control：控制缓存行为 Connection：控制不再转发给代理的首部字段；管理持久连接 Date：创建 HTTP 报文的日期和时间 Pragma：向后兼容；要求所有的中间服务器不返回缓存的资源 Trailer：报文主体后记录了哪些首部字段 Transfer-Encoding：传输时的编码方式 Upgrade：检测 HTTP 协议及其他协议是否可使用更高的版本进行通信 Via：追踪传输路径 Warning：缓存相关问题的警告 请求首部字段 Accept：用户代理支持的媒体类型及优先级 Accept-Charset：用户代理支持的字符集及优先级 Accept-Encoding：用户代理支持的内容编码及优先级 gzip compress deflate identity Accept-Language：用户代理支持的自然语言集及优先级 Authorization： Expect：期望出现的某种特定行为 From：电子邮件地址 Host：请求的资源所处的互联网主机名和端口号；如果未设置主机名发送空 If-xxx：条件请求，判断为真才执行 IF-Match：字段值跟 ETag 值匹配一致时才接受请求 If-Modified-Since：字段值（日期）之后资源更新，接受请求 If-None-Match：字段值跟 ETag 值不一致时才接受请求 If-Range：字段值（ETag或时间）和请求资源（ETag 值或时间）相一致时，作为范围请求处理，否则返回全体资源 响应字段首部 Accept-Ranges Age ETag：实体资源的唯一标识，中英文是同一个 强 ETag：细微变化都会改变 弱 ETag：只用于提示资源是否相同，资源发生根本改变产生差异时才改变 ETag 值 Location Proxy-Authenticate Retry-After Server Vary 实体首部字段 Allow Content-Encoding Content-Language Content-Length Content-Location Content-MD5 Content-Range Content-Type Expires：资源失效的日期 Last-Modified：资源最终修改的时间 为 Cookie服务的首部字段 首部字段名 说明 首部类型 Set-Cookie 开始状态管理所使用的 Cookie 信息 响应首部字段 COokie 服务器接收到的 Cookie 信息 请求首部字段 第七章 确保 Web 安全的 HTTPSHTTP 的缺点 明文，内容会被窃听 不验证身份，会被伪装 无法验证完整性，可能被篡改 未加密协议都会存在这类问题 明文 TCP/IP 是可能被窃听的网络 抓包工具 加密处理防止被窃听 通信的加密 SSL TLS 内容的加密 验证身份 任何人都可以发起请求，服务器收到请求都会返回响应 查明对手的证书：SSL 完整性 遭遇篡改，MITM 中间人攻击 防止篡改 MD5 和 SHA-1等散列值校验 数字签名 HTTPS = HTTP + 加密 + 认证 + 完整性保护 公钥加密，私钥解密 公钥加密与共享密钥加密相比，处理速度要慢 HTTPS 采用混合加密机制 使用公钥加密方式交换共享密钥 之后的通信使用共享密钥加密 证书证明公钥的有效性 第八章 确认访问用户身份的认证BASIC 认证（基本认证） 请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Reuired，返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式（BASIC）及 Request-URI 安全域字符串（realm） 接收到状态码 401 的客户端，需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（：）连接后，再经过 Base64 编码处理。 收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。 DIGEST 认证（摘要认证） 请求的资源需要 DIGEST 认证时，服务器会随状态码 401 Authorization Reuired，返回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce） 接收到状态码 401 的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息，包括 username、realm、nonce、uri、response 字段。 realm、nonce 是从服务端得到 username 是 realm 限定范围内可进行认证等用户名 uri 即 Request-URI response 存放经过 MD5 运算后的密码字符串，形成响应码 收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。 SSL 客户端认证客户端事先安装证书 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。 服务器验证客户端证书，验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。 双因素认证 证书认证 -&gt; 认证客户端计算机 表单认证 -&gt; 认证用户本人的行为 基于表单认证 一般用 Cookie 来管理 Session 通过服务器端的 web 应用，将客户端发送过来的用户 ID 和密码与之前登录过的信息做匹配来进行认证的 客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS 通信来进行 HTML 表单画面的显示和用户输入数据的发送。 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID。 客户端接收到从服务端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。 第九章 基于 HTTP 的功能追加协议HTTP 的瓶颈 一条连接上只可发送一个请求 请求只能从客户端开始，客户端不可以接收响应意外的指令 请求/响应首部未经压缩就发送。首部信息越多延迟越大 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。 可任意选择数据压缩格式。非强制压缩发送。 Ajax Asynchronous JavaScript and XML 有效利用 JavaScript 和 DOM 的操作，达到局部 Web 页面替换加载的异步通信手段 和以前的同步通信相比，只更新一部分页面，传输的数据量减少 Ajax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 的调用就能和服务器进行 HTTP 通信 Comet Comet 先将响应挂起，当服务器端后更新再返回。模拟服务器端向客户端推送的功能。 内容实时更新，为了维持连接会消耗更多的资源 SPDY 没有完全改写 HTTP 协议 在 TCP/IP 的应用层与传输层之间通过新加会话层的形式运作 为了安全规定使用 SSL 好处 多路复用流 赋予请求优先级 压缩 HTTP 首部 推送功能 服务器提示功能 缺点 单个域名的通信多路服用，一个 Web 网址上使用多个域名下的资源，改善效果有限 WebSocket Web 浏览器与 Web 服务器之间全双工通信标准 建立在 HTTP 基础上，发起方仍是客户端，一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方可以直接向对方发送报文。 特点 推送功能 WebSocket 首部信息很小，减少通信量 为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次握手。 握手·请求 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，达到握手的目的。 Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值 Sec-WebSocket-Protocol 字段内记录使用的子协议 握手·响应 返回状态码 101 Switching Protocols Sec-WebSocket-Accept 字段值是由握手请求中的 Sec-WebSocket-Key 的自动值生成的 HTTP/2.0 目标是改善用户在使用 Web 时的速度体验 Web 服务器管理文件的 WebDAV Web-based Distributed Authoring and Versioning 可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统 第十章 构建 Web 内容的技术 HTML（HyperText Markup Language） CSS（Cascading Style Sheets） JavaScript JSON（JavaScript Object Notation） 第十一章 Web 的攻击技术 HTTP 不具备必要的安全功能 HTTP 请求可以在客户端自由地修改 在报文内加载攻击代码 URL 查询字段或表单、HTTP 首部、Cookie 等途径 针对 Web 应用的攻击模式 以服务器为目标的主动攻击 把攻击代码传入的攻击模式 代表 SQL 注入攻击 OS 命令注入攻击 以服务器为目标的被动攻击 利用圈套策略执行攻击代码的攻击模式 诱使用户触发已经设置好的陷阱，陷阱会自动发送已嵌入攻击代码的 HTTP 请求 当用户不知不觉中招后，用户的浏览器或邮件客户端救护触发这个陷阱 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码 执行完攻击代码，存在安全漏洞的 Web 应用会成为攻击者的跳板，可能导致用户所持的 Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果 代表 XSS 跨站脚本攻击 跨站点请求伪造 因输入值转义不完全引发的安全漏洞 XSS 跨站脚本攻击 在 html 中注入 js 代码使得用户在表单中输入的账户密码会发送到攻击者的网站 SQL 注入攻击 针对数据库，传入非法的 SQL 让服务器执行，可能导致非法浏览和篡改 OS 命令注入攻击 通过 Web 应用，执行非法的操作系统命令 HTTP 首部注入攻击 攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击 比如 Cookie 信息、重定向 URL 目录遍历攻击 对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的 远程文件包含漏洞 当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当以来文件，让脚本读取之后，就可以运行任意脚本的一种攻击 因设置或设计上的缺陷引发的安全漏洞 强制浏览 不正确的错误消息处理 开放重定向 因会话管理疏忽引发的安全漏洞 会话劫持 攻击者通过某种手段拿到用户的会话 ID，并非法使用此会话 ID 伪装成用户 会话固定攻击 跨站点请求伪造 攻击者通过设置好的陷阱 其他安全漏洞 密码破解 点击劫持 利用透明按钮覆盖在 Web 页面上，让用户点击，又称界面伪装 DoS 攻击 让运行中的服务呈停止状态的攻击 后门程序","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://ziiyan.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"排序","slug":"排序","date":"2020-03-30T05:24:43.000Z","updated":"2020-07-27T09:31:04.028Z","comments":true,"path":"2020/03/30/排序/","link":"","permalink":"http://ziiyan.github.io/2020/03/30/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"快排12345678910111213141516171819202122function quickSort (arr, left = 0, right = arr.length -1) &#123; if (left &gt;= right) &#123; return &#125; let i = left; let j = right; const baseVal = arr[j]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[i] &lt;= baseVal) &#123; i++; &#125; arr[j] = arr[i]; while (j &gt; i &amp;&amp; arr[j] &gt;= baseVal) &#123; j--; &#125; arr[i] = arr[j]; &#125; arr[j] = baseVal; quickSort(arr, left, j-1); quickSort(arr, j+1, right); return arr;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://ziiyan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"JS运行机制","slug":"JS运行机制","date":"2020-03-29T13:58:24.000Z","updated":"2020-04-01T03:16:36.674Z","comments":true,"path":"2020/03/29/JS运行机制/","link":"","permalink":"http://ziiyan.github.io/2020/03/29/JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/","excerpt":"","text":"https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA 区分进程和线程 进程是 cpu 资源分配的最小单位，线程是 cpu 调度的最小单位。 一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。 进程在创建、切换和销毁时开销比较大，而线程比较小。 进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。 浏览器是多进程的 浏览器是多进程的 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存） 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程 在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了（所以每一个Tab标签对应一个进程并不一定是绝对的） 浏览器都包含哪些进程？ Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有： 负责浏览器界面显示，与用户交互。如前进，后退等 负责各个页面的管理，创建和销毁其他进程 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上 网络资源的管理，下载等 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程：最多一个，用于3D绘制等 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的） 默认每个Tab页面一个进程，互不影响。主要作用为 页面渲染，脚本执行，事件处理等 浏览器多进程的优势 避免单个page crash影响整个浏览器 避免第三方插件crash影响整个浏览器 多进程充分利用多核优势 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性 重点是浏览器内核（渲染进程） 页面的渲染，JS的执行，事件的循环，都在这个渲染进程内进行 浏览器的渲染进程是多线程的 GUI渲染线程 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行 GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞 事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发器线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步 http 请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 Browser进程和浏览器内核（Renderer进程）的通信过程 Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程 Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘） 最后Render进程将结果传递给Browser进程 Browser进程接收到结果并将结果绘制出来 梳理浏览器内核中线程之间的关系GUI渲染线程与JS引擎线程互斥 由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行 JS阻塞页面加载 JS如果执行时间过长就会阻塞页面。 譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。 所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 WebWorker，JS的多线程？ 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM） JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据） WebWorker与SharedWorker WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。 SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次 简单梳理下浏览器渲染流程 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程-浏览器渲染流程开始 浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤： 解析html建立dom树 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树） 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上 渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了。 ![image-20200330102718586](/Users/wuziyan/Library/Application Support/typora-user-images/image-20200330102718586.png) load事件与DOMContentLoaded事件的先后 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成) 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。（渲染完毕了） 所以，顺序是：DOMContentLoaded -&gt; load css加载是否会阻塞dom树渲染？css是由单独的下载线程异步下载的。 css加载不会阻塞DOM树解析（异步加载时DOM照常构建） 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息） 普通图层和复合图层 浏览器渲染的图层一般包含两大类：普通图层以及复合图层 普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中） 其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层 GPU中，各个复合图层是单独绘制的，所以互不影响 如何变成复合图层（硬件加速）将该元素变成一个复合图层，就是传说中的硬件加速技术 absolute和硬件加速的区别可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。 （浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的） 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图） 复合图层的作用？一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能 但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡 从Event Loop谈JS的运行机制 JS分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 事件循环机制进一步补充 上图大致描述就是： 主线程运行时会产生执行栈，栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕） 而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调 如此循环 注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件 单独说说定时器 上述事件循环机制的核心是：JS引擎线程和事件触发线程 当使用setTimeout或setInterval时，需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中 setTimeout而不是setInterval 用setTimeout模拟定期计时和直接用setInterval是有区别的 因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差（误差多少与代码执行时间有关） 而setInterval则是每次都精确的隔一段时间推入一个事件 （但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了） 而且setInterval有一些比较致命的问题就是： 累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔。就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间） 譬如像iOS的webview,或者Safari等浏览器中都有一个特点，在滚动的时候是不执行JS的，如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误（这一块后续有补充，setInterval自带的优化，不会重复添加回调） 而且把浏览器最小化显示等操作时，setInterval并不是不执行程序，它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时 所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame 事件循环进阶：macrotask与microtask Promise里有了一个一个新的概念：microtask JS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task 区别： macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行） 每一个task会从头到尾将这个任务执行完毕，不会执行其它 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task-&gt;渲染-&gt;task-&gt;...） microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务 也就是说，在当前task任务后，下一个task之前，在渲染之前 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前） 分别什么样的场景会形成macrotask和microtask呢？ macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask） microtask：Promise，process.nextTick等 再根据线程来理解下： macrotask中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护 microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护 （这点由自己理解+推测得出，因为它是在主线程下无缝执行的） 所以，总结下运行机制： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ziiyan.github.io/tags/JavaScript/"}]},{"title":"面试准备：防抖 & 节流","slug":"面试准备：防抖 & 节流","date":"2020-03-28T13:55:35.000Z","updated":"2020-08-06T01:40:53.039Z","comments":true,"path":"2020/03/28/面试准备：防抖 & 节流/","link":"","permalink":"http://ziiyan.github.io/2020/03/28/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9A%E9%98%B2%E6%8A%96%20&%20%E8%8A%82%E6%B5%81/","excerpt":"","text":"https://www.cnblogs.com/Antwan-Dmy/p/10714445.html 1、防抖 debounce 防止抖动，避免把一次事件误认为多次 场景 连续点击按钮导致发送多次相同请求 调整浏览器窗口大小，监听事件 实时文本编辑器，无更改一秒后再保存 防抖重在清零 clearTimeout(timer) 123456789function debounce(fn, ms) &#123; let timer = null; return (...args) =&gt; &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn(...args); &#125;, ms); &#125;&#125; 2、节流 throttle 节省水流，控制事件发生的频率，限制流量 场景 scroll 事件，每隔一秒计算一次位置 浏览器播放事件，每隔一秒一算一次进度 input 框实时搜索，每隔一秒发送一次请求（也可以防抖，看需求） 节流重在加锁 timer=timeout 12345678910function throttle(fn, ms) &#123; let timer = null; return (...args) =&gt; &#123; if (timer) &#123; return &#125; timer = setTimeout(() =&gt; &#123; f(...args) timer = null; &#125;, ms) &#125;&#125; reference 2019 面试准备 - JS 防抖与节流 (超级 重要!!!!!) 【滴滴】什么是防抖和节流，他们的应用场景有哪些","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ziiyan.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"http://ziiyan.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"module","slug":"23-24-module","date":"2020-03-28T10:51:28.000Z","updated":"2020-03-28T11:51:05.145Z","comments":true,"path":"2020/03/28/23-24-module/","link":"","permalink":"http://ziiyan.github.io/2020/03/28/23-24-module/","excerpt":"","text":"Module 的语法概述 CommonJS 模块就是对象，输入时必须查找对象属性 12345678// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入 12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载 这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高 这也导致了没法引用 ES6 模块本身，因为它不是对象。 严格模式 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;; 限制 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this export 命令 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取 如果希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。重命名后，可以用不同的名字输出两次 export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值 export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷 import 命令 import命令要使用as关键字，将输入的变量重命名 import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口 如果是对象，属性可修改，但不建议这样做 import命令具有提升效果，会提升到整个模块的头部，首先执行 本质是，import命令是编译阶段执行的，在代码运行之前 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构 模块的整体加载 import * (as xxx) from &#39;...&#39; export default 命令 export default xxx 不需要大括号，import xxx from &#39;...&#39; 也不需要大括号 export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字 export 与 import 的复合写法12345export &#123; foo, bar &#125; from 'my_module';// 可以简单理解为import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;; 写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，当前模块不能直接使用foo和bar import() import和export命令只能在模块的顶层，不能在代码块之中 有利于编译器提高效率，但也导致无法在运行时加载模块 ES2020 提案引入 import() 函数支持动态加载模块 Module 的加载实现浏览器加载传统方法 浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到&lt;script&gt;标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间 如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载 &lt;script&gt; 标签打开 defer 或 async 属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令 defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。 一句话，defer是“渲染完再执行”，async是“下载完就执行”。 另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的 加载规则 浏览器加载 ES6 模块，也使用 &lt;script&gt; 标签，但是要加入 type=&quot;module&quot; 属性 module 属性都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了``标签的defer属性 ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 一旦输出一个值，模块内部的变化就影响不到这个值 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值 ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"原型 & 原型链","slug":"原型-原型链","date":"2020-03-25T07:19:10.000Z","updated":"2020-07-27T09:30:21.278Z","comments":true,"path":"2020/03/25/原型-原型链/","link":"","permalink":"http://ziiyan.github.io/2020/03/25/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"原文：https://mengera88.github.io/2017/06/06/javascript%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3%EF%BC%9A%E6%90%9E%E6%B8%85%E6%A5%9A%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ziiyan.github.io/tags/JavaScript/"}]},{"title":"Promise 学习笔记","slug":"Promise","date":"2020-03-25T04:33:36.000Z","updated":"2020-07-27T09:29:59.164Z","comments":true,"path":"2020/03/25/Promise/","link":"","permalink":"http://ziiyan.github.io/2020/03/25/Promise/","excerpt":"","text":"原文：https://mengera88.github.io/2017/05/18/Promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ 极简雏形12345678910111213141516function Promise(fn) &#123; var value = null, callbacks = []; this.then = function(onFulfilled) &#123; callbacks.push(onFulfilled); &#125;; function resolve(value) &#123; callbacks.forEach(function (callback) &#123; callback(value); &#125;); &#125; fn(resolve);&#125; 代码逻辑 调用 then 方法，将想要在 Promise 异步操作成功时执行的回调放入 callbacks 队列 就是注册回调函数，观察者模式 创建 Promise 实例时传入的函数 fn 会被赋予一个函数类型的参数，即 resolve resolve 接收一个参数 value，代表异步操作的返回结果 当异步操作执行成功后，用户会调用 resolve 方法。真实操作是将 callbacks 队列中的回调一一执行 代码分析 new Promise 时，传给 promise 的函数发送异步请求 接着调用 promise 对象的 then 属性，注册请求成功的回调函数 当异步请求发送成功时，调用 resolve(results.id) 方法，该方法执行 then 方法注册的回调数组 支持链式调用1234567891011121314151617function Promise(fn) &#123; var value = null, callbacks = []; this.then = function(onFulfilled) &#123; callbacks.push(onFulfilled);==&gt; return this; &#125;; function resolve(value) &#123; callbacks.forEach(function (callback) &#123; callback(value); &#125;); &#125; fn(resolve);&#125; 加入延时时机 保证 resolve 执行之前，then 方法已经注册完所有的回调 12345678910111213141516171819function Promise(fn) &#123; var value = null, callbacks = []; this.then = function(onFulfilled) &#123; callbacks.push(onFulfilled); return this; &#125;; function resolve(value) &#123;==&gt; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; callback(value); &#125;);==&gt; &#125;, 0) &#125; fn(resolve);&#125; 代码逻辑 利用 setTimeout 机制，将 resolve 中执行回调的逻辑放置到任务队列末尾，保证执行 resolve 中的代码时，then 方法的回调函数已经注册完成 问题 在 Promise 异步操作成功之后才调用 then 注册的回调不会执行 加入状态 即加入 pending -&gt; fulfilled 或 pending -&gt; rejected 1234567891011121314151617181920212223242526function Promise(fn) &#123; var value = null, callbacks = [],==&gt; state = 'pending'; this.then = function(onFulfilled) &#123;==&gt; if (state === 'pending') &#123; callbacks.push(onFulfilled); return this;==&gt; &#125;==&gt; onFulfilled(value);==&gt; return this; &#125;; function resolve(newValue) &#123;==&gt; value = newValue;==&gt; state = 'fulfilled'; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; callback(value); &#125;); &#125;, 0) &#125; fn(resolve);&#125; 代码逻辑 resolve 执行时，将状态设置为 fultilled，之后调用then 添加的新回调都会立即执行，不需要加入 callbacks 队列 链式 Promise 如果 then 函数里面注册的仍是 Promise，只要在then方法里面return一个promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function Promise(fn) &#123; var state = 'pending', value = null, callbacks = []; this.then = function(onFulfilled) &#123;&gt; return new Promise(function (resolve) &#123;&gt; handle(&#123;&gt; onFulfilled: onFulfilled || null,&gt; resolve: resolve&gt; &#125;);&gt; &#125;); &#125;; &gt; function handle(callback) &#123; if (state === 'pending') &#123; callbacks.push(callback); return; &#125;&gt; // 如果 then 中没有传递任何东西&gt; if (!callback.onFultilled) &#123;&gt; callback.resolve(value);&gt; return;&gt; &#125;&gt; var ret = callback.onFulfilled(value);&gt; callback.resolve(ret); &#125; function resolve(newValue) &#123;&gt; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123;&gt; var then = newValue.then;&gt; if (typeof then === 'function') &#123;&gt; then.call(newValue, resolve);&gt; return;&gt; &#125;&gt; &#125; value = newValue; state = 'fulfilled'; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; handle(callback); &#125;); &#125;, 0) &#125; fn(resolve);&#125; 代码逻辑 then 方法中，创建并返回了新的 Promise 实例 串行 Promise 的基础，并且支持链式调用 handle 方法是 Promise 内部的方法，then 方法传入的行参 onFulfilled 以及创建新 Promise 实例时传入的 resolve 均被 push 到当前 promise 的 callbacks 队列中 这是衔接当前 Promise 实例和后邻 promise 的关键 失败处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function Promise(fn) &#123; var state = 'pending', value = null, callbacks = []; this.then = function(onFulfilled) &#123; return new Promise(function (resolve) &#123; handle(&#123; onFulfilled: onFulfilled || null,&gt; onRejected: onRejected || null, resolve: resolve,&gt; reject: reject &#125;); &#125;); &#125;; function handle(callback) &#123; if (state === 'pending') &#123; callbacks.push(callback); return; &#125; // 如果 then 中没有传递任何东西 if (!callback.onFultilled) &#123; callback.resolve(value); return; &#125;&gt; var cb = state === 'fullfilled' ? callback.onFulfilled : callback.onRejected;&gt; if (cb === null) &#123;&gt; cb = state === 'fulfilled' ? callback.resolve : callback.reject;&gt; cb(value);&gt; return;&gt; &#125; var ret = cb(value); callback.resolve(ret); &#125; function resolve(newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then; if (typeof then === 'function') &#123; then.call(newValue, resolve); return; &#125; &#125; state = 'fulfilled'; value = newValue;&gt; execute(); &#125; &gt; function reject(reason) &#123;&gt; state = 'rejected';&gt; value = reason;&gt; execute();&gt; &#125; function execute() &#123; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; handle(callback); &#125;); &#125;, 0) &#125; fn(resolve);&#125; 抽离 resolve 和 reject 公共部分作为 execute 异常处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function Promise(fn) &#123; var state = 'pending', value = null, callbacks = []; this.then = function(onFulfilled) &#123; return new Promise(function (resolve) &#123; handle(&#123; onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve: resolve, reject: reject &#125;); &#125;); &#125;; function handle(callback) &#123; if (state === 'pending') &#123; callbacks.push(callback); return; &#125; // 如果 then 中没有传递任何东西 if (!callback.onFultilled) &#123; callback.resolve(value); return; &#125; var cb = state === 'fullfilled' ? callback.onFulfilled : callback.onRejected; if (cb === null) &#123; cb = state === 'fulfilled' ? callback.resolve : callback.reject; cb(value); return; &#125;&gt; try &#123; var ret = cb(value); callback.resolve(ret);&gt; &#125; catch (e) &#123;&gt; callback.reject(e);&gt; &#125; &#125; function resolve(newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then; if (typeof then === 'function') &#123; then.call(newValue, resolve); return; &#125; &#125; state = 'fulfilled'; value = newValue; execute(); &#125; function reject(reason) &#123; state = 'rejected'; value = reason; execute(); &#125; function execute() &#123; setTimeout(function() &#123; callbacks.forEach(function (callback) &#123; handle(callback); &#125;); &#125;, 0) &#125; fn(resolve);&#125; 总结 promise里面的then函数仅仅是注册了后续需要执行的代码 真正的执行是在resolve方法里面执行的 Promise 主要使用了设计模式中的观察者模式： 通过 Promise.prototype.then 和 Promise.prototype.catch 方法将观察者方法注册到被观察者 Promise 对象中，同时返回一个新的 Promise 对象，以便可以链式调用。 被观察者管理内部 pending、fulfilled 和 rejected 的状态转变，同时通过构造函数中传递的 resolve 和 reject 方法以主动触发状态转变和通知观察者。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ziiyan.github.io/tags/JavaScript/"}]},{"title":"Class的基本语法和继承","slug":"21-22-Class的基本语法和继承","date":"2020-03-24T13:43:45.000Z","updated":"2020-03-28T10:51:04.619Z","comments":true,"path":"2020/03/24/21-22-Class的基本语法和继承/","link":"","permalink":"http://ziiyan.github.io/2020/03/24/21-22-Class%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E7%BB%A7%E6%89%BF/","excerpt":"","text":"Class 的基本语法简介类的由来 js 中生成实例对象的传统方法是通过构造函数 12345678function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ',' + this.y + ')';&#125;;var p = new Point(1, 2); Es6 为了接近传统语言，引入了 Class，作为对象的模版。 通过 class 关键字，可以定义类 Es6 的 clss 看作一个语法糖，大部分功能 es5 都可以做到，只是让写法更像面向对象编程的语法 12345678910class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ',' + this.y + ')'; &#125;&#125; ES5 的构造函数 Point，对应 ES6 的 Point 类的构造方法 constructor 类的数据类型就是函数，类本身就指向构造函数 12345class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true 使用的时候，直接用 new 命令，跟构造函数一样 类的所有方法都定义在类的prototype属性上面 123456789101112131415161718class Point &#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; 在类的实例上调用方法，就是调用原型上的方法 1234class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 类的方法都是定义在 prototype 对象上面所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法 12345678910class Point &#123; constructor() &#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString() &#123;&#125;, toValue() &#123;&#125;&#125;); prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的 1Point.prototype.constructor === Point 类的内部所有定义的方法，都是不可枚举的（non-enumerable），这与 ES5 的行为不一致 12345678910111213141516171819202122232425262728class Point &#123; constructor(x, y) &#123; // ... &#125; toString() &#123; // ... &#125;&#125;Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"]// ES5 的写法可枚举var Point = function (x, y) &#123; // ...&#125;;Point.prototype.toString = function() &#123; // ...&#125;;Object.keys(Point.prototype)// [\"toString\"]Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"] constructor 方法 constructor 方法都是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法 一个类必须有 constructor 方法，如果没有显示定义，一个空的 constructor 方法会被默认添加 constructor 方法默认返回实例对象（即 this），可以手动指定返回另外一个对象 12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行 类的实例 必须用 new 生成 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上） 12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 类的所有实例共享一个原型对象，可以通过实例的__proto__属性为“类”添加方法 __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。 getter 和 setter 与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' 存值函数和取值函数是定义在属性的描述对象上面，这与 ES5 完全一致 属性表达式12345678910111213let methodName = 'getArea';class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125;// Square类的方法名getArea，是从表达式得到的 Class 表达式 与函数一样，类也可以使用表达式的形式定义 123456789const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;;// 类的名字是Me，但是Me只在 Class 的内部可用，指代当前类// 在 Class 外部，这个类只能用 MyClass 引用// 内部不用 Me 可以省略const MyClass = class &#123; /* ... */ &#125;; 立即执行的 Class 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // \"张三\" 注意点 严格模式 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式 类不存在变量提升 name 属性的值是类名 Generator 方法 如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数 this 类的方法内部如果含有this，它默认指向类的实例 1234567891011121314class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property 'print' of undefined// this会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是undefined），从而导致找不到print方法而报错 解决办法 1234567// 构造方法中绑定`this`，这样就不会找不到`print`方法了class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; 123456789// 箭头函数class Obj &#123; constructor() &#123; this.getThis = () =&gt; this; &#125;&#125;const myObj = new Obj();myObj.getThis() === myObj // true 1234567891011121314151617181920// 使用Proxy，获取方法的时候，自动绑定thisfunction selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== 'function') &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); 静态方法 类相当于实例的原型，所有在类中定义的方法，都会被实例继承 如果在一个方法前加上 static 关键字，表示该方法不会被实例继承，而是通过类来调用，称为“静态方法” 如果静态方法包含this关键字，这个this指的是类，而不是实例 静态方法可以与非静态方法重名 12345678910111213class Foo &#123; static bar() &#123; this.baz(); &#125; static baz() &#123; console.log('hello'); &#125; baz() &#123; console.log('world'); &#125;&#125;Foo.bar() // hello 父类的静态方法，可以被子类继承 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // 'hello' 静态方法也是可以从super对象上调用的 12345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod() // \"hello, too\" 实例属性和新写法 实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层 123456789class IncreasingCounter &#123; constructor() &#123; this._count = 0; &#125;&#125;// 等同于class IncreasingCounter &#123; _count = 0;&#125; 静态属性 静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性 12345678910// 老写法class Foo &#123; // ...&#125;Foo.prop = 1;// 新写法（提案）class Foo &#123; static prop = 1;&#125; 私有方法和私有属性 私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问 这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现 现有的解决方案 命名上加以区别 不保险，在类的外部还是可以调用 12345678910class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125;&#125; 将私有方法移出模块，因为模块内部的所有方法都是对外可见的 12345678class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125;&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值 Reflect.ownKeys() 可以拿到 123456789101112const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125;&#125;; 提案 属性名之前，使用#表示 new.target 属性 用在构造函数之中，返回new命令作用于的那个构造函数 如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined 因此这个属性可以用来确定构造函数是怎么调用的 子类继承父类时，new.target会返回子类 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类 在函数外部，使用new.target会报错 Class 的继承简介 通过extends关键字实现继承 ES5 通过修改原型链实现继承 1234567891011class Point &#123;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; super关键字，它在这里表示父类的构造函数，用来新建父类的this对象 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 Object.getPrototypeOf() Object.getPrototypeOf方法可以用来从子类上获取父类 可以使用这个方法判断，一个类是否继承了另一个类 12Object.getPrototypeOf(ColorPoint) === Point// true super 关键字 super作为函数调用时，代表父类的构造函数，只能用在子类的构造函数中 ES6 要求，子类的构造函数必须执行一次super函数 12345678910class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;// super虽然代表了父类A的构造函数，但是返回的是子类B的实例// 即super内部的this指的是B的实例// super()在这里相当于A.prototype.constructor.call(this)。 super作为对象时 在普通方法中，指向父类的原型对象 定义在父类实例上的方法或属性无法通过 super 调用 ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例 在静态方法中，指向父类 在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例 使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错 类的 prototype 属性和 __proto__ 属性 大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链 子类的__proto__属性，表示构造函数的继承，总是指向父类 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性 作为一个对象，子类（B）的原型（__proto__属性）是父类（A） 作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例 实例的 __proto__ 属性 子类实例的 __proto__ 属性的__proto__ 属性，指向父类实例的 __proto__ 属性。子类的原型，是父类的原型 原生构造函数的继承 Boolean() Number() String() Array() Date() Function() RegExp() Error() Object() Mixin 模式的实现 Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口 1234567const a = &#123; a: 'a'&#125;;const b = &#123; b: 'b'&#125;;const c = &#123;...a, ...b&#125;;","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"async函数","slug":"20-async函数","date":"2020-03-24T13:15:56.000Z","updated":"2020-03-24T13:42:57.181Z","comments":true,"path":"2020/03/24/20-async函数/","link":"","permalink":"http://ziiyan.github.io/2020/03/24/20-async%E5%87%BD%E6%95%B0/","excerpt":"","text":"async 函数含义 async 使异步操作变得更加方便，Generator 的语法糖 将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await async 对 Generator 函数的改进： 内置执行器，会自动执行 Generator 需要 co 模块才能自动执行 或者调用 next 手动执行 更好的语义 更广的适用性 await 后面可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，会自动转成立即 resolved 的 Promise 对象） 返回值是 Promise async 可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖 基本用法 async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数 当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句 语法 返回 Promise 对象 async 函数内部 return 语句返回值，会成为 then 方法回调函数的参数 async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态 Promise 对象的状态变化 async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变 除非 return 或抛出错误 也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数 await 命令 如果 await 后面是一个 thenable 对象（定义了 then 方法的对象），会将其同等于 Promise 对象 任何一个 await 语句后面的 Promise 对象变为 reject 状态，整个 async 函数都会中断执行 可以在 async 内部进行错误处理，catch 错误就不会影响后续执行 注意点 最好把 await 命令放在 try...catch 代码块中 多个 await 命令后面的异步操作，如果不存在继发关系，最好同时触发，比较不耗时 let [foo, bar] = await Promise.all([getFoo(), getBar()]); // 或 let fooPromise = getFoo(); let barPromise = getBar(); let foo = await fooPromise; let bar = await barPromise; &lt;!--￼0--&gt; 顶层 await 语法提案 借用 await 解决模块异步加载的问题","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"Vue 常考知识点","slug":"Vue基础","date":"2020-03-24T10:54:30.000Z","updated":"2020-03-24T12:58:10.190Z","comments":true,"path":"2020/03/24/Vue基础/","link":"","permalink":"http://ziiyan.github.io/2020/03/24/Vue%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Vue 常考知识点生命周期 beforeCreate ：获取不到 props 或者 data 中的数据的，因为这些数据的初始化都在 initState 中。 created ：可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。 beforeMount ：开始创建 VDOM，组件中如果有子组件的话，会递归挂载子组件 mounted ：将 VDOM 渲染为真实 DOM 并且渲染数据 beforeUpdate ：数据更新前 updated：数据更新后 keep-alive 独有的生命周期，分别为 activated 和 deactivated 用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。 beforeDestroy ：适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件 destroyed：所有子组件都销毁完毕后才会执行 组件通信父子组件通信 props、emit 访问 $parent 或者 $children 对象 兄弟组件通信 通过查找父组件中的子组件实现，也就是 this.$parent.$children 在 $children 中可以通过组件 name 查询到需要的组件实例 跨多层级组件通信任意组件 Vuex computed 和 watch 区别 computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。 v-show 与 v-if 区别 v-show 只是在 display: none 和 display: block 之间切换。 无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。 所以总的来说 v-show 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。 v-if 的话就得说到 Vue 底层的编译了。 当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。 并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。 编译过程 通过正则表达式将模版解析为 AST（Abstract Syntax Tree，抽象语法树） 优化 AST：对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功 将 AST 转换为 render 函数：遍历整个 AST，根据不同的条件生成不同的代码","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://ziiyan.github.io/tags/Vue/"}]},{"title":"React和Vue","slug":"React和Vue","date":"2020-03-24T09:53:27.000Z","updated":"2020-03-24T15:55:37.419Z","comments":true,"path":"2020/03/24/React和Vue/","link":"","permalink":"http://ziiyan.github.io/2020/03/24/React%E5%92%8CVue/","excerpt":"","text":"内容转自掘金小册《前端面试之道》 React 和 VueMVVM不管是 React 还是 Vue，它们都不是 MVVM 框架，只是借鉴 MVVM 的思路 View ：用户看到的视图 Model：本地数据和数据库中的数据 传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。 ViewModel：只关心数据和业务的处理，不关心 View 如何处理数据 Binnder（隐式）：实现了 View 和 ViewModel 的绑定 精髓：通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象 Virtual DOMJS 模拟 DOM 操作 DOM 很慢，相较于 DOM 来说，操作 JS 对象会快很多，可以通过 JS 来模拟 DOM 12345678910const ul = &#123; tag: 'ul', props: &#123; class: 'list' &#125;, children: &#123; tag: 'li', children: '1' &#125;&#125; 上述代码对应的 DOM 就是 123&lt;ul class='list'&gt; &lt;li&gt;1&lt;/li&gt;&lt;/ul&gt; Virtual DOM 的 diff 算法 通过 JS 来模拟 DOM 并且渲染对应的 DOM 只是第一步，难点在于如何判断新旧两个 JS 对象的最小差异并且实现局部更新 DOM。 Virtual DOM 只会对同一个层级的元素进行对比 深度优先遍历，每遍历到一个节点就把该节点和新的的树进行对比，如果有差异的话就记录到一个对象里 key 作为唯一表示 差异类型 替换掉原来的节点 移动、删除、新增子节点 修改了节点的属性 对于文本节点，文本内容可能会改变 把差异应用到真正的DOM树上 对 DOM 树也进行深度优先的遍历，遍历的时候从保存差异的对象中找出当前遍历的节点差异，然后进行 DOM 操作 总结1234567891011121314151617181920212223// 1\\. 构建虚拟DOMvar tree = el('div', &#123;'id': 'container'&#125;, [ el('h1', &#123;style: 'color: blue'&#125;, ['simple virtal dom']), el('p', ['Hello, virtual-dom']), el('ul', [el('li')])])// 2\\. 通过虚拟DOM构建真正的DOMvar root = tree.render()document.body.appendChild(root)// 3\\. 生成新的虚拟DOMvar newTree = el('div', &#123;'id': 'container'&#125;, [ el('h1', &#123;style: 'color: red'&#125;, ['simple virtal dom']), el('p', ['Hello, virtual-dom']), el('ul', [el('li'), el('li')])])// 4\\. 比较两棵虚拟DOM树的不同var patches = diff(tree, newTree)// 5\\. 在真正的DOM元素上应用变更patch(root, patches) 路由原理 监听 URL 的变化，然后匹配路由规则，显示相应的页面 Hash 模式 www.test.com/#/ 就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 www.test.com。 History 模式 History 模式是 HTML5 新推出的功能，主要使用 history.pushState 和 history.replaceState 改变 URL。 通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。 对比 Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串 Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候。 Vue 和 React 之间的区别 v-model setState JSX","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://ziiyan.github.io/tags/Vue/"},{"name":"React","slug":"React","permalink":"http://ziiyan.github.io/tags/React/"}]},{"title":"深入响应式原理","slug":"深入响应式原理","date":"2020-03-24T08:58:28.000Z","updated":"2020-03-24T12:54:25.895Z","comments":true,"path":"2020/03/24/深入响应式原理/","link":"","permalink":"http://ziiyan.github.io/2020/03/24/%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"在简历上写了熟悉 Vue（并不），只好临时抱佛脚…… https://cn.vuejs.org/v2/guide/reactivity.html 深入响应式原理 Vue 最独特的特性之一，是其非侵入性的响应式系统。 数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新，这使得状态管理非常简单直接。 不过理解其工作原理同样重要，这样你可以避开一些常见的问题。 如何追踪变化 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 先来看看这个Object.defineProperty，查阅 MDN： Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 直接在 Object 构造器对象上调用此方法，而不是实例。 123456789var o = &#123; a:0 &#125;Object.defineProperties(o, &#123; \"b\": &#123; get: function () &#123; return this.a + 1; &#125; &#125;, \"c\": &#123; set: function (x) &#123; this.a = x / 2; &#125; &#125;&#125;);o.c = 10 // Runs the setter, which assigns 10 / 2 (5) to the 'a' propertyconsole.log(o.b) // Runs the getter, which yields a + 1 or 6 其实很简单，就是修改 object 对象的方法嘛，注意这不是实例的方法，而是构造器的。 Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。 这里是 shim 是什么呢？shim 可以将新的 API 引入到旧的环境中，而且仅靠就环境中已有的手段实现。所以这里的意思是说，Object.defineProperty 这个方法是无法引入到旧的环境的，所以不支持低版本浏览器。 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在属性被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面。 每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。 检测变化的注意事项 受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性。 1Vue.set(vm.someObject, 'b', 2) 有时你可能需要为已有对象赋值多个新属性，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新属性不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象。 1this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 1Object.assign(target, ...sources) 声明响应式属性 由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明所有根级响应式属性，哪怕只是一个空值。 异步更新队列 Vue 在更新 DOM 时是异步执行的。 只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。 如果同一个 watcher 被多次触发，只会被推入到队列中一次。 这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。 感觉这种处理类似于防抖，提升性能。 然后，在下一个的事件循环 “tick” 中，Vue 刷新队列并执行实际 (已去重的) 工作。 Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 Promise.then： ES6 MutationObserver：接口提供了监视对DOM树所做更改的能力。它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分。 setImmediate：非标准。 例如，当你设置 vm.someData = &#39;new value&#39;，该组件不会立即重新渲染。 当刷新队列时，组件会在下一个事件循环 “tick” 中更新。 多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。 虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。 为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。 简单实现 Observe，给对象的属性添加 setter/getter 事件 12345678910111213141516171819202122232425262728293031323334var data = &#123; name: 'aaa'&#125;observe(data)let name = data.namedata.name = 'bbb'function observe(obj) &#123; // 判断类型 if (!obj || typeof obj !== 'object') &#123; return &#125; Object.keys(obj).forEach(key =&gt; &#123; defineReactive(obj, key, obj[key]) &#125;)&#125;function defineReactive(obj, key, val) &#123; // 递归子属性 observe(val) Object.defineProperty(obj, key, &#123; // 可枚举 enumerable: true, // 可配置 configurable: true, // 自定义函数 get: function reactiveGetter() &#123; console.log('get value') return val &#125;, set: function reactiveSetter(newVal) &#123; console.log('change value') val = newVal &#125; &#125;)&#125; Dep，用于解耦属性的依赖手机和派发更新操作 1234567891011121314151617class Dep &#123; constructor() &#123; this.subs = [] &#125; // 添加依赖 addSub(sub) &#123; this.subs.push(sub) &#125; // 更新 notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125;// 全局属性，通过该属性配置 WatcherDep.target = null Watcher，触发依赖收集时的操作 12345678910111213141516171819class Watcher &#123; constructor(obj, key, cb) &#123; // 将 Dep.target 指向自己 // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 Dep.target = this this.cb = cb this.obj = obj this.key = key this.value = obj[key] Dep.target = null &#125; update() &#123; // 获得新值 this.value = this.obj[this.key] // 调用 update 方法更新 Dom this.cb(this.value) &#125;&#125; 改造 defineReactive，添加依赖收集和派发更新相关代码 12345678910111213141516171819202122232425function defineReactive(obj, key, val) &#123; // 递归子属性 observe(val) let dp = new Dep() Object.defineProperty(obj, key, &#123; // 可枚举 enumerable: true, // 可配置 configurable: true, // 自定义函数 get: function reactiveGetter() &#123; console.log('get value') if (Dep.target) &#123; dp.addSub(Dep.target) &#125; return val &#125;, set: function reactiveSetter(newVal) &#123; console.log('change value') val = newVal dp.notify() &#125; &#125;)&#125;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://ziiyan.github.io/tags/Vue/"}]},{"title":"Vue渲染时机","slug":"Vue渲染时机","date":"2020-03-24T04:39:49.000Z","updated":"2020-03-31T07:58:00.323Z","comments":true,"path":"2020/03/24/Vue渲染时机/","link":"","permalink":"http://ziiyan.github.io/2020/03/24/Vue%E6%B8%B2%E6%9F%93%E6%97%B6%E6%9C%BA/","excerpt":"","text":"​ 最近在改样式时碰到一个很神奇的bug：qrcode 生成一个二维码，绘制在对应的 canvas 标签中，bug 是二维码不显示。代码总共三行，qrcode 的回调 error 是空的，说明至少二维码的创建到绘制是没有错误的。 ​ 查看分支记录，发现了一些相关修改：二维码码是放在一个弹窗中的，以前的弹窗是用绝对定位移出可视区域，实际上弹窗是一直存在的。因为设计的需求换成了 AntD，这个弹窗也换成了 modal 组件，只有在点击个人信息的时候才显示。 Modal 组件渲染时机 项目采用的都是同步引入的方式，父子组件渲染顺序如下： 加载渲染过程 父 beforeCreate父 created父 beforeMount子 beforeCreate子 created子 beforeMount子 mounted父 mounted 更新过程 父 beforeUpdate子 beforeUpdate子 updated父 updated 生命周期介绍：https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90 Bug 分析流程 现在在 mouted 里面加入绘制二维码的代码 document.getElementById(‘canvas’) 获取到的元素为空 qrcode 报错，这里主要是用来生成二维码的 userInfo.pri_Key 还没获取到值 在 watch 里面加入绘制二维码的代码，监听的是控制弹窗是否显示的变量 document.getElementById(‘canvas’) 获取到的元素为空 userInfo.pri_Key 有值，qrcode 不报错了 很显然，问题就在为什么这个 canvas 标签一直获取不到，那什么时候才能获取到呢？ Click 点击显示 modal，要到子组件 updated 时才能获取到标签 也就是说在 updated 里面才更新 DOM，watch 里面是不更新的 官网里面关于 updated 的描述 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。 但我们知道，watch 里 DOM 还没更新，我们如何在 watch 里面修改 canvas 呢？ 如果你希望等到整个视图都重绘完毕，可以在 updated 里使用 vm.$nextTick nextTick 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。 显然，这就是我们需要的方法了。 等待 DOM 更新，可以得到 canvas 标签 调用 qrcode 库创建二维码并会绘制到 canvas 上 将绘制二维码的代码封装一层 nextTick document.getElementById(‘canvas’) 可以正常获取到元素，二维码正常显示 异步更新队列 Vue 在更新 DOM 时是异步执行的。 只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。 如果同一个 watcher 被多次触发，只会被推入到队列中一次。 这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。 然后，在下一个的事件循环 “tick” 中，Vue 刷新队列并执行实际 (已去重的) 工作。 Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 之前误打误撞使用了 setTimeout(fn, 0)，实际上恰好实现了异步队列 如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。 虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。 为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。 总结 moda 组件在 mounted 时并不会渲染到页面上 在控制 modal 显示变量为 true 之后，直到 updated 阶段才更新 DOM watch 当中有关 DOM 的操作，要利用 nextTick 延迟到 DOM 渲染之后执行","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://ziiyan.github.io/tags/Vue/"},{"name":"浏览器","slug":"浏览器","permalink":"http://ziiyan.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"0.1+0.2!==0.3","slug":"0.1+0.2!==0.3","date":"2020-03-23T14:29:23.000Z","updated":"2020-03-23T14:29:23.835Z","comments":true,"path":"2020/03/23/0.1+0.2!==0.3/","link":"","permalink":"http://ziiyan.github.io/2020/03/23/0.1+0.2!==0.3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"axios","slug":"axios","date":"2020-03-23T06:21:08.000Z","updated":"2020-03-24T15:55:45.775Z","comments":true,"path":"2020/03/23/axios/","link":"","permalink":"http://ziiyan.github.io/2020/03/23/axios/","excerpt":"","text":"","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://ziiyan.github.io/tags/Vue/"}]},{"title":"Iterator和for...of循环","slug":"17-Iterator和for-of循环","date":"2020-03-22T06:38:06.000Z","updated":"2020-03-22T13:01:08.877Z","comments":true,"path":"2020/03/22/17-Iterator和for-of循环/","link":"","permalink":"http://ziiyan.github.io/2020/03/22/17-Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"Iterator 和 for…of 循环Iterator（遍历器）的概念 JS 原来表示”集合”的是数组 Array 和对象 Object，ES6 添加了 Map 和 Set Iterator 是一种接口，任何数据结构只要部署 Iterator 接口，就可以完成便利操作（即依次处理该数据结构的所有成员） Iterator 作用： 为各种数据结构提供统一的、简便的访问接口 使数据结构的成员能够按某种次序排列 ES6 创造了新的遍历命令 for...of 遍历过程 创建指针对象，指向当前数据结构的起始位置 遍历对象本质上是一个指针对象 js 有指针的概念？ 第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员 不断调用指针对象的 next 方法，直到它指向数据结构的结束位置 每次调用 next 返回一个包含 value he done 两个属性的对象。 value 属性是当前成员的值 done 属性是一个布尔值，表示遍历是否结束 123456789101112131415var it = makeIterator(['a', 'b']);it.next();it.next();it.next();function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125; &#125; &#125;&#125; 默认 Iterator 接口 当使用 for...of 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口 ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要有 Symbol.iterator 属性，就认为是可遍历的 Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生产函数 执行这个函数，就会返回一个遍历器 属性名 Symbol.iterator 是一个表达式，返回 Symbol 对象的 iterator 属性 123456789101112const obj = &#123; [Symbol.iterator]: function () &#123; return &#123; next: function() &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;; 原生具备 Iterator 接口的数据结构： Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。 调用 Iterator 接口的场合 数组和 Set 结构进行解构赋值时，默认调用 Symbol.iterator 方法 扩展运算符 ... 部署了 Iterator 接口的数据结构都能用扩展运算符 yield* 后面跟的是一个可遍历的解构，它会调用该结构的遍历器接口 数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，都调用了遍历器 for … of Array.from() Map(), Set(), WeakMap(), WeakSet() Promise.all() Promise.race() Iterator 接口与 Generator 函数 Symbol.iterator 方法的最简单实现 1234567891011121314151617181920212223let myIterable = &#123; [Symbol.iterator]: function* () &#123; yield 1; yield 2; yield 3; &#125;&#125;[...myIterable] // [1, 2, 3]// 或let obj = &#123; * [Symbol.iterator]() &#123; yield 'hello'; yield 'world'; &#125;&#125;;for (let x of obj) &#123; console.log(x);&#125;// \"hello\"// \"world\" for…of 循环 数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员 也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法 for...of循环可以使用的范围 数组 Set Map 某些类似数组的对象 arguments对象 DOM NodeList 对象 Generator 对象 字符串","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"Set和Map数据结构","slug":"13-Set和Map数据结构","date":"2020-03-22T05:34:01.000Z","updated":"2020-03-22T15:55:15.358Z","comments":true,"path":"2020/03/22/13-Set和Map数据结构/","link":"","permalink":"http://ziiyan.github.io/2020/03/22/13-Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"Set 和 Map 数据结构Set基本用法 类似于数组，但成员的值都是唯一的 不会发生类型转换，所以 5 和 “5” 不同 两个 NaN 是相等的，这和 === 不同 两个对象总是不想等 Set 构造函数可以接受一个数组（或具有 iterable 接口的其他数据结构）作为参数 123456789const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));// 等价于const s = new Set([2, 3, 5, 4, 5, 2, 2]);for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 Array.from 可以将 Set 结构转为数组 Set 实例的属性和方法 属性 Set.prototype.constructor 构造函数 Set.prototype.size 返回 Set 实例的成员总数 方法 操作方法 Set.prototype.add(value) 添加某个值，返回 Set 结构本身 Set.prototype.delete(value) 删除某个值，返回布尔表示是否成功 Set.prototype.has(value) 返回布尔值，表示是否为 Set 成员 Set.prototype.clear(value)清空，没有返回值 遍历方法 Set.prototype.keys() 返回键名，遍历器对象 Set.prototype.values() 返回键值，遍历器对象 Set 结构没有键名，只有键值（或者说键名键值都是同一个值），所以 keys 方法和 values 方法一样 Set.prototype.entries() 返回键值对，遍历器对象 Set.prototype.forEach() 使用回调函数遍历每个成员 WeakSet 类似 Set 成员只能是对象 弱引用，垃圾回收机制不考虑 WeakSet 的引用，可能会随时被清空 不可遍历 Map基本用法 类似于对象，是键值对的集合 对象的键只能是字符串，Map 的键不限制类型 Map 构造函数可接受数组，数组成员表示一个键值对（任何具有 Iterator 接口，且每个成员都是一个双元素的数组的数据结构，例如 Set 和 Map） 12345678910111213const map = new Map([ ['name', 'zhangsan'], ['title', 'Author']])// 实际上执行const items = [ ['name', 'zhangsan'], ['title', 'Author']]const map = new Map();items.forEach( ([key, value]) =&gt; map.set(key, value)) 多次赋值一个键，会覆盖 读取一个未知的键，返回 undefined 对于对象，地址相同 Map 结构才视为同一个键 对于简单类型，值严格相等 === 就是一个键 1234const map = new Map();map.set(['a'], 555);map.get(['a']) // undefined// ['a'] 是实例，这里两个实例 ['a'] 内存地址不同 实例的属性和操作方法 属性 size 方法 操作方法 Map.prototype.set(key, value) 返回当前 Map 对象，可以采用链式写法 Map.prototype.get(key) Map.prototype.has(key) Map.prototype.delete(key) Map.prototype.clear(key) 遍历方法 Map.prototype.keys() Map.prototype.values() Map.prototype.entries() Map.prototype.forEach() Map 本身没有 map 和 filter 方法，需要结合数组 与其他数据结构的互相转换 Map -&gt; 数组 [...map] 数组 -&gt; Map new Map(array) Map -&gt; 对象 对象 -&gt; Map Map -&gt; JSON JSON -&gt; Map WeakMap 类似 Map 键名只能对象（除了 null） 指向的对象不计入垃圾回收机制","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"Generator函数的语法","slug":"18-Generator函数的语法","date":"2020-03-21T09:18:23.000Z","updated":"2020-03-22T13:40:13.754Z","comments":true,"path":"2020/03/21/18-Generator函数的语法/","link":"","permalink":"http://ziiyan.github.io/2020/03/21/18-Generator%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Generator 函数的语法简介基本概念 异步编程解决方案，语法行为与传统函数完全不同 理解 语法上，Generator 函数是一个状态机，封装了多个内部状态 执行 Generator 函数会返回一个遍历器对象 遍历器对象可以依次遍历 Generator 函数内部的每一个状态 形式上，Generator 函数是一个普通函数 两个特征 function 关键字与函数名之间有一个星号，星号位置和空格位置的先后关系没有规定 函数体内部使用 yield 表达式，定义不同的内部状态 123456789function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;// 三个状态var hw = helloWorldGenerator();// 调用 调用 Generator 函数后，该函数并不执行，返回一个指向内部状态的指针对象（iterator Object） 调用遍历器对象的 next 方法，使得指针移向下一个状态 也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句） 换言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，next 方法恢复执行 next 返回一个对象 属性 value 是当前 yield 表达式的值 属性 done 表示遍历是否结束 12345678hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; yield 表达式 next 方法的运行逻辑 遇到 yield 表达式，就暂停执行，并将紧跟在 yield 后面的表达式的值作为对象的 value 属性返回 下次调用 yield 时，再继续往下执行，直到遇到下一个 yield 表达式 如果没有遇到新的表达式，就一直运行到 return，并将 return 语句后面的表达式的值作为对象的 value 属性 如果没有return 语句，则返回对象的 value 属性值为 undefined yield 表达式后面的表达式，只有调用 next 方法、内部指针指向该语句时才会执行 给 JavaScript 提供了手动惰性求值的语法功能 不用 yield 的情况下，Generator 就是一个单纯的暂缓执行函数 yield 只能用在 Generator 函数里面，其它地方会报错 yield 如果用在另一个表达式中，必须放在括号里面 yield 用做函数参数或放在赋值表达式右边，不用括号 next 方法的参数 这节没看懂 yield 表达式本身没有返回值，或者说总是返回 undefined next 方法可以带一个参数，该参数会被当作上一个 yield 表达式的返回值 for…of 循环 for...of 循环自动遍历 Generator 函数运行时生成的 Iterator 对象，此时不需要调用 next 方法 斐波那契 123456789101112function* fibonacci() &#123; let [prev, curr] = [0, 1]; for (;;) &#123; yield curr; [prev, curr] = [curr, prev + curr]; &#125;&#125;for (let n of fibonacci()) &#123; if (n &gt; 1000) break; console.log(n);&#125; Generator.prototype.throw() throw 方法可以在函数体外抛出错误，在函数体内捕获 前提是必须进行过一次 next 方法 捕获后会自动执行一次 next 方法，不影响下次遍历 如果 Generator 函数内部没有部署 try...catch 代码块，那么错误会被外部的 try...catch 代码块捕获 如果都没有，那么程序将报错，直接中断执行 Generator.prototype.return() 返回给定的值，并终结遍历 Generator 函数 next()、throw()、return() 的共同点 作用都是让 Generator 函数恢复执行，使用不同的语句替换 yield 表达式 next() 是将 yield 表达式替换成一个值 throw() 是将 yield 表达式替换成一个 throw 语句 return() 是将 yield 表达式替换成一个 return 语句 yield* 表达式 在一个 Generator 函数里面执行另一个 Generator 函数 1234567891011121314151617181920212223242526272829303132333435function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; yield 'a'; yield 'b'; yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; for (let v of foo()) &#123; yield v; &#125; yield 'y';&#125;for (let v of bar()) &#123; console.log(v);&#125;// \"x\"// \"a\"// \"b\"// \"y\" 从语法角度看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，就会执行这个遍历器 任何数据结构只要有 Iterator 接口，就可以被yield*遍历 作为对象属性的 Generator 函数1234567891011let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;;// 等价于let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;;","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"Promise对象","slug":"16-Promise对象","date":"2020-03-21T05:22:36.000Z","updated":"2020-03-21T07:45:54.122Z","comments":true,"path":"2020/03/21/16-Promise对象/","link":"","permalink":"http://ziiyan.github.io/2020/03/21/16-Promise%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"Promise 对象Promise 的含义 异步编程的一种解决方案，比传统的解决方案更合理和更强大 传统的解决方案：回调函数和事件 Promise 简单说就是一个容器，保存着某个未来才会结束的事件（通常是一个异步操作）的结果 从语法上说，Promise 是一个对象，可以获取异步操作的消息 特点： 对象状态不受外界影响 Promise 对象代表一个异步操作，有三种状态 pending 进行中 fulfilled 已成功 rejected 已失败 只有异步操作的结果才能改变状态 一旦状态改变，就不会再改变，任何时候都可以得到这个结果 状态改变只有两种可能 pending -&gt; fulfilled pending -&gt; rejected 缺点： 无法取消。一旦新建就会立即执行，无法中途取消 如果不设置回调函数，内部抛出的错误无法反应到外部 处于 pending 状态的时候，无法得知进度 如果事件不断地反复发生， Stream 模式是比 Promise 更好的选择 基本用法 创建 Promise 实例 12345678const promise = new Promise(function(resolve, reject) &#123; // ... if (/* 成功 */) &#123; resolve(value); // 将 Promise 对象的状态 pending -&gt; fulfilled &#125; else &#123; reject(error); // 将 Promise 对象的状态 pending -&gt; rejected &#125;&#125;); 回调函数 12345promise.then(function(value)&#123; // success&#125;, function(error)&#123; // failure&#125;); 调用 resolve 或 reject 并不会终结 Promise 的参数函数的执行 立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 2// 1 一般来说，resolve 或 reject 之后 Promise 的使命就完成了，后续操作应该放到 then 里 所以可以 return resolve() 或 return reject() Promise.prototype.then() then 方法的返回值是一个新的 Promise 实例，因此可以采用链式写法 1234567getJSON(\"/post/1.json\").then(function(post)&#123; return getJSON(post.commentURL);&#125;).then(function(comments)&#123; console.log(...)&#125;, function(err)&#123; console.log(...)&#125;); 箭头函数写法 123456getJSON(\"/post/1.json\").then( post =&gt; getJSON(post.commentURL);).then( comments =&gt; console.log(...), err =&gt; console.log(...)); Promise.prototype.catch() Promise.prototype.catch() 是 .then(null, rejection) 或 .then(undefined, rejection) 的别名，用于指定发生错误的回调函数 一般来说，不要用 then 的第二个参数，直接用 catch，可以捕获第一个参数的执行错误 12345getJSON('/posts.json').then(function(post)&#123; // ...&#125;).catch (function(error) &#123; // 处理 getJOSN 和 前一个回调函数运行时发生的错误&#125;); reject 方法的作用等于抛出错误 如果 Promise 状态已经变成 resulved 再抛出错误是无效的 Promise 对象的错误具有”冒泡”性质，会一直向后传递，知道被捕获为止 也就是说，错误总是会被下一个 catch 语句捕获 如果没有使用 carch 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码 Node 有一个 unhandledRejection 事件（计划废除），专门监听未捕获的 reject 错误 catch 返回值也是 Promise 对象，还可以接 then ，也可以抛出错误被下一个 catch 捕获 Promise.prototype.finally() 无论 Promise 最后状态如何，都会执行的操作，不接收参数 本质上是 then 方法的特例（then 中两种情况代码一样） 1234567Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;; finally 方法总是返回原来的值 Promise.prototype.all() 将多个 Promise 实例包装成一个新的 Promise 实例 参数可以不是数组，但必须具有 Iterator 接口，且每个成员都是 Promise 实例 1const p = Promise.all([p1, p2, p3]); p 的状态由 p1, p2, p3 决定 都为 fulfilled，p 为 fulfilled 返回值组成数组，传递给 p 的回调函数 任一 rejected，p 为 rejected 第一个被 reject 的实例的返回值，传递给 p 的回调函数 如果 p1, p2, p3 自己定义了 catch，则会执行 catch，状态变成 catch 返回的 resolve 如果没定义 catch 才会调用 Promise.all() 的 catch 方法 Promise.prototype.race() 将多个 Promise 实例包装成一个新的 Promise 实例 1const p = Promise.race([p1, p2, p3]); 只要 p1, p2, p3 任一改变状态，p 就跟着改变 率先改变的 Promise 实例的返回值，传递给 p 的回调函数 Promise.prototype.allSettled() 接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例 所有参数实例都返回结果，包装实例才会结束 返回新的 Promise 实例，状态总是 fulfilled 监听函数接收到的参数是对象数组，每个对象分别对应 allSettled 的参数 对象属性 status, value, reason Promise.prototype.any() 接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例 任一 fulfilled ，包装实例就 fulfilled 全部 rejectd ，包装实例才 rejectd Promise.prototype.resolve() 将现有对象转为 Promise 对象 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) 参数分 4 种情况 Promise 实例 不做任何修改 thenable 对象（具有 then 方法的对象） 转为 Promise 对象，立即执行 then 不是 thenable 对象（其它对象或不是对象） 返回一个新的 Promise 对象，状态 resolved 不带参数 直接返回一个 resolved 的Promise 对象 立即 resolve 的 Promise 对象，在本轮”事件循环”的结束时执行，不是在下一轮”事件循环”开始时 Promise.prototype.reject() 返回一个新的 Promise 实例，状态为 rejected 参数会原封不动作为 reject 理由，和 resolve 处理不同 应用 加载图片 Generator 函数与 Promise 结合 Promise.try() 同步函数同步执行，异步函数异步执行 模拟 try 代码块","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"Symbol","slug":"12-Symbol","date":"2020-03-18T13:15:15.000Z","updated":"2020-03-18T15:18:13.926Z","comments":true,"path":"2020/03/18/12-Symbol/","link":"","permalink":"http://ziiyan.github.io/2020/03/18/12-Symbol/","excerpt":"","text":"Symbol概述 ES5 的对象属性名都是字符串，容易造成属性名冲突 原始数据类型 Symbol 表示独一无二的值 通过 Symbol 函数生成 不能使用 new 命令 可以接受参数，作为变量的描述，用来区分 如果参数是对象，先调用该对象的 toString 方法 12let s = Symbol();typeof s // \"symbol\" 现在，对象的属性名可以有两种类型 字符串 Symbol 类型 Symbol 值不能与其他类型的值进行运算，会报错 可以转为字符串和布尔值(true)，但不能转为数值 Symbol.prototype.description 创建 Symbol 的时候，可以添加一个描述 读取描述需要将 Symbol 显式转为字符串 ES2019 提供 description 属性，返回 Symbol 描述 作为属性名的 Symbol1234567891011121314151617let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法let a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // \"Hello!\" Symbol 值作为对象属性名时，不能用点运算符，因为点运算符后面总是字符串 要放在方括号中定义 12345const mySymbol = Symbol();const a = &#123;&#125;;a.mySymbol = 'Hello';a[mySymbol] // undefineda['mySymbol'] // 'Hello' Symbol 值作为属性名时，该属性是公开属性，不是私有属性 实例：消除魔术字符串 魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。 等于哪个值并不重要，只要确保不会跟其他属性的值冲突即可，就很适合改用 Symbol 值 属性名的遍历 Symbol 作为属性名，遍历对象的时候不会出现在for...in、for...of循环中 可以利用这个特性，为对象定义非私有、只希望内部使用的方法 不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回 Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名 该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值 Reflect.ownKeys(object)方法可以返回所有类型的键名，包括常规键名和 Symbol 键名 Symbol.for()，Symbol.keyFor() Symbol.for(&#39;string&#39;) 检查是否有以 string 作为名称的 Symbol 值，有则返回，没有则新建，并注册到全局 Symbol()写法没有登记机制 Symbol.keyFor(变量名)方法返回一个已登记的 Symbol 类型值的key 实例：模块的 Singleton 模式 Singleton 模式（单例模式）指的是调用一个类，任何时候返回到都是同一个实例 内置的 Symbol 值 Symbol.hasInstance 指向一个内部方法 当其他对象使用instanceof运算符，会调用这个方法 比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo) Symbol.isConcatSpreadable 等于一个布尔值 表示该对象用于Array.prototype.concat()时，是否可以展开 Symbol.species 指向一个构造函数，创建衍生对象时使用该属性 Symbol.match 指向一个函数 如果该属性存在，调用它并返回方法的返回值 Symbol.replace 指向一个方法 当该对象被String.prototype.replace方法调用时，会返回该方法的返回值 Symbol.search 指向一个方法 当该对象被String.prototype.search方法调用时，会返回该方法的返回值 Symbol.split 指向一个方法 当该对象被String.prototype.split方法调用时，会返回该方法的返回值 Symbol.iterator Symbol.toPrimitive Symbol.toStringTag SYmbol.unscopables","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"函数的扩展","slug":"8-函数的扩展","date":"2020-03-18T13:15:15.000Z","updated":"2020-03-21T05:07:25.429Z","comments":true,"path":"2020/03/18/8-函数的扩展/","link":"","permalink":"http://ziiyan.github.io/2020/03/18/8-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/","excerpt":"","text":"函数的扩展函数参数的默认值基本用法1234function Point（x = 0, y = 0) &#123; this.x = x; this.y = y;&#125; 参数默认值是惰性求值，每次重新计算 与解构赋值默认值结合使用函数的 length 属性 返回没有指定默认值的参数个数 rest 参数 ...变量名 不需要使用 arguments 对象 arguments 是类数组 rest 是真的数组 name 属性 返回函数名 箭头函数注意点 函数体内的 this 对象，是定义时所在的对象，而不是使用时所在的对象 箭头函数没有自己的 this ，引用外层的 this 不可以当作构造函数，不可以使用 new 命令 不可以使用 arguments 对象，可以用 rest 参数 不可以使用 yield 命令，因此不能用做 Generator 函数 尾调用优化什么是尾调用 某个函数的最后一步是调用另一个函数 尾调用优化 函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 只有 Safari 支持 尾递归 尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 斐波那契 12345678910function Fibonacci(n) &#123; if (n &lt;= 1) return 1; return Fibonacci(n-1) + Fibonacci(n-2);&#125;// 尾递归function Fibonacci2 (n, ac1 = 1, ac2 = 1) &#123; if (n &lt;= 1) return ac2; return Fibonacci2 (n-1, ac2, ac1 + ac2);&#125; ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存 递归函数的改写 把所有用到的内部变量改写成函数的参数 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。 严格模式 ES6 的尾调用优化只在严格模式下开启 函数参数的尾逗号 ES6 中函数最后一个参数后有逗号不会报错 Function.prototype.toString() toString()方法返回函数代码本身，以前会省略注释和空格 catch 命令的参数省略 以前 catch 命令后面必须跟参数，ES6 可以省略","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"字符串的扩展","slug":"4-5-字符串","date":"2020-03-16T16:43:37.000Z","updated":"2020-03-16T16:44:05.910Z","comments":true,"path":"2020/03/17/4-5-字符串/","link":"","permalink":"http://ziiyan.github.io/2020/03/17/4-5-%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串的扩展字符的 Unicode 表示法 ES6 加强了对 Unicode 的支持，允许采用 \\uxxxx 形式表示一个字符，xxxx 表示字符的 Unicode 码点 限制码点在 \\u0000 ~ \\uFFFF 之间的字符，超出范围必须用两个双字节的形式表示 1234567\"\\uD842\\uDFB7\"// \"𠮷\"\"\\u20BB7\"// \" 7\"// JavaScript 会理解成 \\u20BB+7// \\u20BB 不可打印，输出空格 只要将码点放入大括号，就能正确解读 12\"\\u&#123;20BB7&#125;\"// \"𠮷\" 对编码仍然是一窍不通…… 字符串的遍历器接口 ES6 对字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 for...of 循环便利 除了遍历字符串，遍历器最大的优点是可以识别大于 0xFFFF 的码点 直接输入 U+2028 和 U+2029 JavaScript 字符串允许直接输入字符，以及输入字符的转义形式 1'中' === '\\u4e2d' 规定不能在字符串里直接使用，只能用转义形式 U+005C：反斜杠 U+000D：回车 U+2028：行分隔符 U+2029：段分隔符 U+000A：换行符 JSON 允许使用 U+2028、U+2029 JSON.parse() 解析这两个会报错 为了兼容 JSON，ES2019 支持直接输入这两个 JSON.stringify() 的改造 根据标准，JSON 数据必须是 UTF-8 编码，但是现在的 JSON.stringify() 有可能返回不符合 UTF-8 标准的字符串 UTF-8 标准规定，0xD800 到 0xDFFF 之间的码点必须配对使用 JSON.stringify() 可能返回 0xD800 到 0xDFFF 之间的单个码点 为了确保返回的是合法的 UTF-8 字符，如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理 模板字符串 增强版的字符串，用反引号（`）标识 可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入 ${变量} 12let name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 反引号需要反斜杠转义 保留空格和缩进，可以用 trim() 方法消除 如果变量的值不是字符串，将按照一般的规则转为字符串 比如，大括号中是一个对象，将默认调用对象的toString方法 标签模板 模版字符串跟在一个函数名后面，该函数将被调用来处理这个模版字符串 123alert`hello`// 等同于alert(['hello']) 标签模版其实不是模版，而是函数调用的一种特殊形式 “标签” 指的是函数，跟在后面的模版字符串是参数 如果有参数，函数会依次受到多个参数 12345678910function tag(stringArr, ...values) &#123; // ...&#125;let a = 5;let b = 10;tag`Hello $&#123;a + b&#125; world $&#123;a + b&#125;`;//等同于tag(['Hello ', ' world ', ''], 15, 50); 作用 过滤 HTML 字符串，防止用户输入恶意内容 多语言转换 嵌入其他语言 模版处理函数的第一个参数（模版字符串数组），还有一个 raw 属性，保存的是转义后的原字符串 模板字符串的限制 标签模板可以内嵌别的语言，默认将字符串转义，导致报错 ES2018 放松了对标签模版里面字符串转义的限制 遇到不合法的字符串转义，返回 undefined raw 属性上仍可以得到原始字符串 不是标签模版仍然会报错 字符串的新增方法String.fromCodePoint() ES5 提供 String.fromCharCode() 方法从 Unicode 码点返回对应字符，不能识别大于 0xFFFF 的字符 ES6 提供 String.fromCodePoint() 可识别大于 0xFFFF 的字符 多个参数会被合并成一个字符串返回 fromCodePoint 方法定义在 String 对象上 codePointAt 方法定义在字符串的实例对象上 String.raw() 替换所有变量，并对斜杠进行转义 实现 12345678910String.raw = function (strings, ...values) &#123; let output = ''; let index; for (index = 0; index &lt; values.length; index++) &#123; output += strings.raw[index] + values[index]; &#125; output += strings.raw[index] return output;&#125; 实例方法：codePointAt() JavaScript 内部，字符以 UTF-16 的格式存储，每个字符固定 2 字节 大于 0xFFFF 的字符需要 4 个字节存储，JavaScript 会认为它们是两个字符，字符串长度为 2 ES5 charCodeAt() 只能 2 个字节 2 个字节处理 ES6 codePointAt() 能够正确处理 4 个字节 codePointAt() 返回的码点是十进制的，toString(16) 转为十六进制 实例方法：normalize() 合成符号 实例方法：includes(), startsWith(), endsWith() ES5 indexOf 可以确定一个字符串是否包含在另一个字符串中 ES6 includes(&#39;subString&#39;, n) 返回布尔值，表示是否找到了参数字符串 startsWith(&#39;subString&#39;, n) 返回布尔值，表示参数字符串是否在原字符串的头部 endsWith(&#39;subString&#39;, n) 返回布尔值，表示参数字符串是否在原字符串的尾部 实例方法：repeat(n) 返回一个新字符串，重复 n 次 小数取整，负数/Infinity 报错 实例方法：padStart(n, ‘string’), padEnd(n, ‘string’) 补全长度 长度 n 用来补全的字符串 string 实例方法：trimStart(), trimEnd() 消除空格 不修改原始字符 实例方法：matchAll() matchAll()返回一个正则表达式在当前字符串的所有匹配 详见 6-正则的扩展","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"变量的解构赋值","slug":"3-变量的解构赋值","date":"2020-03-15T13:28:01.000Z","updated":"2020-03-15T13:28:30.708Z","comments":true,"path":"2020/03/15/3-变量的解构赋值/","link":"","permalink":"http://ziiyan.github.io/2020/03/15/3-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/","excerpt":"","text":"变量的解构赋值 ES6 允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，被称为解构 数组的解构赋值基本用法1let [a, b, c] = [1, 2, 3]; 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值 12345// 嵌套的例子let [head, ...detail] = [1, 2, 3, 4];// head = 1, detail = [2, 3, 4]let [x, y, ...z] = ['a'];// x = 'a', y = undefined, z = [] 如果解构不成功，变量的值就等于 undefined 12let [foo] = [];let [bar, foo] = [1]; 不完全解构，只匹配一部分 1234let [x, y] = [1, 2, 3];// x = 1, y = 2let [a, [b], d] = [1, [2, 3], 4];// a = 1, b = 2, d = 4 如果等号右边不是数组（严格的说，不是可遍历的结构，参见第 17 章 - Iterator），会报错 12345678// 转为对象后不具备 Iterator 接口let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;// 本身不具备 Iterator 接口let [foo] = &#123;&#125;; 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值 默认值 解构赋值允许指定默认值 1234let [foo = true] = [];// foo = truelet [x, y = 'b'] = ['a'];// x = 'a', y = 'b' ES6 内部使用严格相等运算符判断一个位置是否有值，只有当一个数组成员严格等于 undefined 默认值才会生效 1234let [x = 1] = [undefined];// x = 1let [x = 1] = [null];// x = null 如果默认值是一个表达式，则是惰性求值，也就是只有在用到的时候才会求值。 12345678910111213141516function f() &#123; console.log('aaa');&#125;let [x = f()] = [1];// x = 1, 函数 f 不会执行// 等价于let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125;// [1] 是只含元素 1 的数组// [1][0] 表示取该数组第一位，也就是元素 1// let array = [1];// let x = array[0]; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明 1234let [x = 1, y = x] = [];// x = 1, y = 1let [x = y, y = 1] = [];// 报错 对象的解构赋值基本用法12let &#123; foo, bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;// foo = 'aaa', bar = 'bbb' 数组的元素是按次序排列的，变量的取值由位置决定 对象的属性没有次序，变量必须与属性同名才能赋值 12let &#123; baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;// baz = undefined 对象的解构赋值可以很方便的将现有对象的方法赋值到某个变量 123let &#123; log, sin, cos &#125; = Math;const &#123; log &#125; = console;log('hello'); 如果变量名与属性名不一致，写法如下 123456let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb'&#125;;// baz = 'aaa'let obj = &#123; first: 'hello', last = 'world' &#125;;let &#123; first: f, last: l &#125; = obj// f = 'hello', l = 'world' 说明对象的解构赋值是下面形式的简写（参见第 10 章 - 对象的扩展） 1let &#123; foo: foo, bar: bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋值给对应变量 真正被赋值的是后者，而不是前者 前者是匹配的模式，后者才是变量 嵌套 12345678910111213const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;// line = 1// start = Object &#123;line: 1, column: 5&#125;// loc = Object &#123; start: Object &#125; 对象的解构赋值可以取到继承的属性 123456const obj1 = &#123;&#125;;const obj2 = &#123; foo: 'bar' &#125;;Object.setPrototypeOf(obj1, obj2);const &#123; foo &#125; = obj1;// foo = 'bar' 默认值 生效条件是对象的属性值严格等于 undefined 注意点 如果要将一个已经声明的变量用于解构赋值 123456789// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// js 引擎会将 &#123;x&#125; 理解为一个代码块，从而发生语法错误// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;);// 放在圆括号里即可正确执行 解构赋值允许等号左边的模式中不放任何变量名 123(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []); 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构 123let arr = [1, 2, 3];let &#123;0: first, [arr.length = 1]: last&#125; = arr;// first = 1, last = 3 字符串的解构赋值 字符串在解构赋值时被转换成一个类似数组的对象 12345const [a, b, c, d, e] = 'hello';// a = 'h', b = 'e', C = 'c', d = 'l', e = 'o'let &#123; length: len &#125; = 'hello';// len = 5 数值和布尔值的解构赋值 数值和布尔值在解构赋值时被转为对象 12345let &#123; toString: s &#125; = 123;// s === Number.prototype.toString =&gt; truelet &#123; toString: s &#125; = true;// s === Boolean.prototype.toString =&gt; true 数组和布尔值的包装对象都有 toString 属性，因此变量 s 都能取到值 解构赋值的规则：只要等号右边的值不是对象或数组，就先将其转为对象 由于 undefined 和 null 无法转为对象，所以它们无法进行解构赋值，会报错 ##函数参数的解构赋值 12345678910111213141516171819202122232425function add([x, y]) &#123; return x + y;&#125;add([1, 2]);// 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [3, 7]function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;);// [3, 8]move(&#123;&#125;);// [0, 0]move();// [0, 0]function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 圆括号问题 对于编译器来说，一个式子到底是模式还是表达式，只有在解析到（或解析不到）等号才能知道 如果模式中出现圆括号怎么处理？ 只要有可能导致解构的歧义，就不得使用圆括号 尽量不要在模式中放置圆括号 不能使用圆括号的情况 变量声明语句 函数参数 赋值语句的模式 可以使用圆括号的情况 赋值语句的非模式部分 用途 交换变量的值 1234let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值 函数参数的定义 提取 JSON 数据 函数参数的默认值 遍历 Map 解构 123456789101112131415con s t map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + ' is ' + value);&#125;for (let [key] of map) &#123; // ...&#125;for (let [, value] of map) &#123; // ...&#125; 输入模块的指定方法 1const &#123; SourceMapCounsumer, SourceNode &#125; = require(\"source-map\");","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"let 和 const 命令","slug":"2-let-和-const-命令","date":"2020-03-15T10:18:51.000Z","updated":"2020-03-15T13:28:24.507Z","comments":true,"path":"2020/03/15/2-let-和-const-命令/","link":"","permalink":"http://ziiyan.github.io/2020/03/15/2-let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4/","excerpt":"","text":"let 和 const 命令let 命令基本用法 let 声明的变量值在 let 命令坐在的代码块内有效 12345678var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i); &#125;;&#125;a[6](); // 10// var 声明的 i 在全局有效，最终所有的 i 都指向同一个 i，也就是最后一轮循环时 i 的值 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function() &#123; console.log(i); &#125;;&#125;a[6](); // 6 for 循环变量是一个父作用域，循环体是一个子作用域 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 不存在变量提升 var 声明会出现”变量提升”现象，即变量可以在声明之前使用，值为 undefined let 改变了语法行为，声明之前使用会报错 暂时性死区 块级作用域内存在 let 或 const 命令，它所声明的变量就”绑定(binding)”这个区域，不受外部影响 12345var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 暂时性死区的本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明 let 不允许在相同作用域内重复声明同一个变量 123456789101112131415// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; var a = 10; let a = 1;&#125;// 不报错function func() &#123; var a = 10; var a = 1;&#125; 块级作用域为什么需要块级作用域？ES5 只有全局作用域和函数作用域，可能会导致： 内层变量可能会覆盖外层变量 用来计数的循环变量泄露为全局变量 块级作用域与函数声明 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 ES6 明确允许在块级作用域之中声明函数，且函数声明语句的行为类似于 let，在块级作用域外不可引用 但为了兼容，浏览器在实现时，函数声明的行为可以类似于 var，即会提升到全局作用域或函数作用域的头部 const 命令基本用法 const 声明一个只读的常量，一旦声明，常量的值就不能改变 由于不能改变，声明时就必须初始化，否则报错 本质 csont 实际上保证的是变量指向的那个内存地址所保存的数据不得改动 对于简单类型（数值、字符串、布尔值）的数据，变量指向的地址保存值，等同于常量 对于符合类型（对象、数组）的数据，变量指向的地址保存指针，指针再指向实际数据，这里只能保证指针不变，但不能保证实际数据不变 如果想将对象冻结，可以使用 Object.freeze() 方法 ES6 声明变量的六种方法 ES5 var function ES6 新增 let const import class 顶层对象的属性 顶层对象 浏览器：window Node：global ES5 之中，顶层对象的属性和全局变量等价 ES6 规定 var、function 声明的全局变量，依旧是顶层对象的属性 let、const、class 声明的全局变量，不属于顶层对象的属性 globalThis 对象 顶层对象提供全局环境（即全局作用域） 各个实现不一致 浏览器：window 浏览器和 Web Worker：self Node：global 为了兼容，一般使用 this ，但有限制 全局环境中，this 会返回顶层对象。但 Node 模块和 ES6 模块中，this 返回当前模块 函数里面的 this，如果函数不是作为对象的方法运行，this 指向顶层对象。严格模式下 undefined new Function(&#39;return this&#39;)() 返回全局对象。如果浏览器用了 CSP（内容安全策略），则该方法无法使用 ES2020 引入 globalThis 作为顶层对象，指向全局环境下的 this","categories":[],"tags":[{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"}]},{"title":"第二十二章 高级技巧","slug":"第22章-高级技巧","date":"2020-03-14T09:27:55.000Z","updated":"2020-03-15T13:23:23.408Z","comments":true,"path":"2020/03/14/第22章-高级技巧/","link":"","permalink":"http://ziiyan.github.io/2020/03/14/%E7%AC%AC22%E7%AB%A0-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/","excerpt":"","text":"第二十二章 高级技巧高级函数安全的类型检测Object.toString() 方法返回一个 [object NativeConstructorName] 格式的字符串。每个类内部都有一个 [[Class]] 属性，指定了上述字符串中的构造函数名。 12Object.prototype.toString.call(value);// \"[object Array]\" 开发人员定义的构造函数返回 object Object。 作用域安全的构造函数 当 new 调用构造函数时，构造函数内用到的 this 对象会指向新创建的对象实例。 如果不用 new，this 会映射到全局对象 widow 上，导致属性被添加到全局。 解决：构造函数内部检查 this 对象是否正确 123456789function Person(name, age, job) &#123; if (this instanceof Person) &#123; this.name = name; this.age = age; this.job = job; &#125; else &#123; return new Person(name, age, job); &#125;&#125; 惰性载入函数函数执行的分支只执行一次 函数被调用时处理 第一次调用时用合适函数覆盖原来的函数 例如检查浏览器是否支持某功能，执行一次就行 在声明时就指定适当函数 加载时损失性能，执行时不会 函数绑定 bind()创建一个函数，可以在特定的 this 环境中以指定参数调用另一个函数。 12345678910111213141516171819202122232425var handler = &#123; message: \"Event handled\", handleClick: function (event) &#123; alert(this.message); &#125;&#125;;var btn = document.getElementById(\"my-btn\");EventUtil.addHandler(btn, \"click\", handler.handleClick);// 由于没有保存 handler.handleClick() 的执行环境// this 指向 DOM 按钮而非 handler// 本来应该显示 “Event handled”，会显示 undefined// 使用闭包解决：EventUtil.addHandler(btn, \"click\", function(event) &#123; handler.handleClick(event);&#125;)// bind() 可以将函数绑定到指定环境的函数function bind(fn, context) &#123; return function() &#123; return fn.apply(context, arguments); &#125;&#125;EventUtil.addHandler(btn, \"click\", bind(handler,handleClick, handler)); 函数柯里化 用于创建已经设置好了一个或多个参数的函数 基本方法和函数绑定一样：使用一个闭包返回一个函数 区别在于：函数被调用时，返回的函数还需要设置一些传入的参数 12345678function curry(fn, context) &#123; var args = Array.prototype.slice.call(arguments, 2); return function() &#123; var innerArgs = Array.prototype.slice.all(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(context, finalArgs); &#125;;&#125; 防篡改对象一旦把对象定义为防篡改，就无法撤销了 Object.preventExtensions() 不可扩展对象 无法添加新属性和方法 已有成员可以修改/删除 Object.seal() 密封对象 不可扩展 不能删除 可以修改 Object.freeze() 冻结对象 不可扩展 密封 [[Writable]] 设置为 false，若定义 [[Set]] 属性可写 高级定时器 定时器不是线程 Javascript 运行于单线程环境中 定时器是计划代码在未来的某个时间执行，执行时机不能保证 因为在页面的生命周期中，不同时间可能有其他代码在控制 Javascript 进程 在页面下载完后的代码运行、事件处理程序、Ajax 回调函数都必须使用同样的线程来执行 浏览器负责进行排序，指派某段代码在某个时间点运行的优先级 除了主 JavaScript 执行进程外，还有一个需要在进程下一次空闲时执行的代码队列 没有任何代码是立即执行的，但一旦进程空闲则尽快执行 定时器时间过去时，将代码插入队列末尾 若队列不空，则仍需等待 若主 JavaScript 执行进程正在执行，也仍需等待 重复的定时器当使用 setInterval() 仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中 某些间隔会被跳过 多个定时器的代码执行之间的间隔可能会比预期小 解决：链式 setTimeout() 1234setTimeout(function()&#123; // …… setTimeout(arguments.callee, interval);&#125;, interval); Yielding Processes如果代码运行超过特定的时间或者特定语句数量就不会让它继续执行 展开循环前，思考： 该处理是否必须同步完成？ 数据是否必须按顺序完成？ 如果答案都为否，可以使用数组分块技术 为要处理的项目创建一个队列，使用定时器取出下一个要处理的项目，再设置另一个定时器 123456789function chunk(array, process, context) &#123; setTimeout(function() &#123; var item = array.shift(); process.call(context, item); if (array.length &gt; 0) &#123; setTimeout(arguments.callee, 100); &#125; &#125;, 100);&#125; 函数节流 throttle DOM 操作比非 DOM 交互需要更多的内存和 CPU 时间 连续尝试进行过多的 DOM 相关操作可能会导致浏览器挂起，甚至崩溃。例如 onresize 调整浏览器大小 防止连续触发，使用定时器进行节流 基本思想 某些代码不可以在没有间断的情况连续重复执行 第一次调用函数时，创建一个定时器，在指定的时间间隔之后运行代码 第二次调用函数时，清除前一次的定时器，并设置另一个 如果前一次的定时器已经执行，这个操作无意义 如果前一次的定时器还未执行，就是替换新定时器 目的是只有在执行函数的请求停止了一段时间之后才执行 1234567891011121314151617var processor = &#123; timeoutId: null, // 实际进行处理的方法 performPorcessing: function () &#123; // …… &#125;, // 初始处理调用的方法 process: function () &#123; clearTimeout(this.timeoutId); var that = this; this.timeoutId = setTimeout(function() &#123; that.performProcessing(); &#125;, 100); &#125;&#125;;// 尝试开始执行processor.process(); 简化的 throttle()函数 123456function throttle(method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function() &#123; method.call(context); &#125;, 100);&#125; 自定义事件 事件是 Javascript 与浏览器交互的主要途径 事件是观察者模式，一种创建松散耦合代码的技术 观察者模式有两类对象组成 主体 发布事件 不知道观察者的存在，独立运行 观察者 通过订阅事件来观察主体 知道主体并能注册事件的回调函数（事件处理程序） 拖放 创建一个绝对定位的元素，使其可以用鼠标移动","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第二十三章 离线应用与客户端存储","slug":"第23章-离线应用与客户端存储","date":"2020-03-14T09:27:55.000Z","updated":"2020-03-15T13:23:34.568Z","comments":true,"path":"2020/03/14/第23章-离线应用与客户端存储/","link":"","permalink":"http://ziiyan.github.io/2020/03/14/%E7%AC%AC23%E7%AB%A0-%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/","excerpt":"","text":"第二十三章 离线应用与客户端存储离线 Web 应用：设备不能上网的情况下仍然可以运行的应用 离线检测 navigator.onLine 属性 应用缓存 应用缓存 appache 从浏览器的缓存中分出一块缓存区 使用一个描述文件(manifest file)，列出要下载和缓存的资源 将描述文件与页面关联起来，可以在 html 中的 manifest 属性指定文件路径 applicationCache 对象 数据存储HTTP Cookie 要求服务器对任意 HTTP 请求发送 Set-Cookie HTTP 作为响应的一部分，其中包含会话信息 如： HTTP/1.1 200 OK Content-type: text / html Set-Cookie: name = value Other-header: other-header-value 限制 Cookie 在性质上是绑定在特定的域名下的 当设定了一个 cookie 后，再给创建它的域名发送请求时，都会包含这个 cookie 确保 cookie 中的信息只能让批准的接受者访问，而无法被其他域访问 构成 名称：不区分大小写（实践最好区分），经过 URL 编码 值：URL 编码 域：有效域 路径：对于指定的路径，应该向服务器发送 cookie 若指定 http://www.wrox.com/books/，就不会给 http://www.wrox.com 发送 cookie 失效时间：cookie 何时应该被删除的时间戳 安全标志：指定后之后 SSL 连接时才发送到服务器 JS 中的 cookie BOM 的 document.cookie 属性 子 cookie 存放在单个 cookie 中的更小段的数据 使用 cookie 值来存储多个名称值对 如 name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5 查询字符串的格式进行格式化 所有的 cookie 都会由浏览器作为请求头发送，所以在 cookie 中存储大量信息会影响到特定域的请求性能 Web 存储机制 Web Storage 的两个主要目标 提供一种在 cookie 之外存储会话数据的途径 提供一种存储大量可以跨会话存在的数据的机制 Storage 类型 只能存储字符串 提供最大的存储空间 clear() getItem(name) key(index) removeItem(name) setItem(name, value) sessionStorage 对象 Storage 的一个实例 存储特定于某个会话的数据，只保持到浏览器关闭 如果浏览器支持，崩溃重启可以继续使用 可以跨越页面刷新而存在 存储在 sessionStorage 的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制 globalStorage 对象 不是 Storage 实例，globalStorage[“xxx.com”] 才是 Storage 的实例 跨越会话存储数据，有特定的访问限制 如果不删除，或者用户未清除浏览器缓存，存储在 globalStorage 属性中的数据会一直保留在磁盘上 合在客户端存储文档或者长期保存用户偏好设置 localStorage 对象 Storage 实例，用法与 sessionStorage 相同 取代 globalStorage，不用设置规则 同域名、同协议、同端口 保留到通过 JavaScript 删除或者是用户清除浏览器缓存 storage 事件 修改 Storage 对象会在文档上触发 storage 事件 IndexedDB 浏览器中保存结构化数据的一种数据库 替代被废弃的 Web SQL Database API 创建一套 API，方便保存和读取 JavaScript 对象，同时还支持查询及搜索 异步 做为全局对象 windows.indexedDB，具体名称根据浏览器不同 数据库 用对象保存数据，而不是用表来保存 一个 IndexedDB 数据库，就是一组位于相同命名空间下的对象的集合 indexDB.open() 创建/打开 返回 IDBRequest 对象 onerror onsuccess 对象存储空间 可以把这里的对象存储空间(object storge)想象成表，把其中保存的对象想象成表中的记录 add() put() 事务 读取或修改数据都要通过事务来组织所有操作 使用事务可以直接通过已知的键检索单个对象 使用游标查询 需要检索多个对象的情况下，需要在事务内 部创建游标 与传统数据库查询不同 游标不提前收集结果 游标指针会先指向结果中的第一项，在接到查找下一项的指令时指向下一项 键范围设定游标方向","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第二十一章 Ajax与Comet","slug":"第21章-Ajax与Comet","date":"2020-03-12T16:20:44.000Z","updated":"2020-03-12T17:37:40.044Z","comments":true,"path":"2020/03/13/第21章-Ajax与Comet/","link":"","permalink":"http://ziiyan.github.io/2020/03/13/%E7%AC%AC21%E7%AB%A0-Ajax%E4%B8%8EComet/","excerpt":"","text":"AJAX - Asynchronous JavaScript + XML 向服务器请求额外的数据而无须卸载页面 核心是 XMLHttpRequest 对象，简称 XHR 使用 XHR 对象取得新数据，通过 DOM 将新数据插入页面 XMLHttpRequest 对象1var xhr = new XMLHttpRequest(); XHR的用法 open(请求类型, URL, 是否异步) get / post 相对于当前页面 / 绝对路径 Boolean send(请求主体) 无内容则传入 null 收到响应后，自动填充 XHR 对象的属性 responseText 做为响应主体 responseXML “text/xml” 或 “application/xml” status 响应的 HTTP 状态 200 成功，responseText 就绪 304 资源未修改，可使用缓存 statusText HTTP 状态的说明 readyState 异步请求的活动阶段 0 位初始化 1 启动 2 发送 3 接收 4 完成 值每次改变都触发 readystatechange 事件 收到响应前调用 abort() 取消异步请求 HTTP头部信息XHR 提供操作请求头部和响应头部信息的方法 默认情况，发送 XHR 请求的同时还会发送以下头部信息 Accept：浏览器能够处理的内容类型 Accept-Charset：浏览器能够显示的字符集 Accept-Encoding：浏览器能够处理的压缩编码 Accept-Language：浏览器当前设置的语言 Connection：浏览器与服务器之间连接的类型 Cookie：当前页面设置的任何 Cookie Host：发出请求的页面所在的域 Referer：发出请求的页面的 URI User-Agent：浏览器的用户代理字符串 setRequestHeader(头部字段名称，头部字段值) 设置自定义的请求头部信息 open 之后 send 之前 getRequestHeader(头部字段名称) getAllResponseHeaders() GET 请求每个参数的名称和值必须使用 encodeURIComponent() 编码才能放到 URL 末尾，所有名-值对都由 &amp; 分隔 POST 请求serialize() 格式化数据 XMLHttpRequest 2 级 FormData 序列化表单 12var data = new FormData();data.append(键, 值); 超时设定 timeout属性 open 之后 send 之前设定，请求在等待响应多少毫秒之后停止 触发 timeout 事件，调用 ontimeout 事件处理程序 overrideMimeType() 方法 重写 XHR 响应的 MIME 类型，send 之前调用 进度事件 loadstart：接收到响应数据的第一个字节时触发 progress：接收响应期间不断地触发 error：请求发生错误时触发 abort：在因为调用 abort() 方法而终止连接时触发 load：在接收到完整的响应数据时触发 loaded：在通信完成或者触发 error、abort 或 load 事件后触发 跨资源共享 CORS基本思想：使用自定义的 HTTP 头部让浏览器与服务器进行沟通 发送：Origin：http://www... 接收：Access-Control-Allow-Origin：http://www... 在 XHR 对象的 open 中传入绝对 URL 可以请求跨域，：限制 不能使用 setRequestHeader() 设置自定义头部 不能发送和接收 cookie 调用 getAllResponseHeaders() 会返回空字符串 Preflighted Requests 透明服务器验证机制 发送 Origin：与简单的请求相同 Access-Control-Request-Method:请求自身使用的方法 Access-Control-Request-Headers:(可选)自定义的头部信息，多个头部以逗号分隔 接收 Access-Control-Allow-Origin：与简单的请求相同 Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔 Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔 Access-Control-Max-Age：应该将这个 Preflight 请求缓存多长时间(以秒表示) 带凭据的请求 默认跨源请求不提供凭据（cookie、HTTP 认证及客户端 SSL 证明） 将 withCredentials 属性设置为 true 可以指定某个请求应该发送凭据 响应：Access-Control-Allow-Credentials: true 跨浏览器的 CROS 所有浏览器都支持简单的（非 Preflight 和不带凭据的）请求 其他跨域技术 图像 Ping &lt;img&gt; 标签 只能发送 GET 请求 无法访问服务器的响应文本 JSONP - JSON with padding 包含两部分：回调函数和数据 通过 &lt;script&gt; 元素使用 能直接访问响应文本 从其他域中加载代码执行，不安全 很难确定 JSONP 请求是否成功 Comet 服务器推送 长轮询：浏览器发送请求，服务器保持连接，直到有数据发送才发送数据。浏览器收到数据后关闭连接，再重新发起新请求 HTTP 流：浏览器发送请求，服务器保持连接，周期性地向浏览器发送数据 SSE 服务器发送事件 围绕只读 Comet 交互推出的 API 或者模式 Web Socket 单独的持久连接上提供全双工、双向通信 SSE 与 Web Socket Web Socket 需要服务器支持，双向通信 SSE 不需要服务器支持，一般单向，结合 XHR 可以双向 安全 要求以 SSL 连接来访问可以通过 XHR 请求的资源 要求每一次请求都要附带经过响应算法计算得到的验证码 以下措施对防范 CSRF（Cross-Saite Request Forgery）攻击不起作用 要求发送 POST 而不是 GET —— 容易改变 检查来源 URL 以确定 是否可信 —— 容易伪造 基于 cookie 信息进行验证 ——容易伪造","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第二十章 JSON","slug":"第20章-JSON","date":"2020-03-11T16:11:48.000Z","updated":"2020-03-11T16:46:22.699Z","comments":true,"path":"2020/03/12/第20章-JSON/","link":"","permalink":"http://ziiyan.github.io/2020/03/12/%E7%AC%AC20%E7%AB%A0-JSON/","excerpt":"","text":"JSON 是一种数据格式，不是编程语言 语法 简单值 字符串 数组 布尔值 null 复杂数据类型 对象 无序的键值对 数组 有序的值的列表 可以通过数值索引访问 简单值JSON 字符串必须使用双引号，JavaScript 字符串可以单引号 1\"Hello world!\" 对象123&#123; \"属性\": \"值\"&#125; 属性必须加双引号 值可以是简单值/复杂类型 数组1[25, \"hi\", true] } 解析与序列化JSON 对象 stringify() js 对象序列化为 JSON 字符串 函数及原型成员会被忽略 值为 undefined 的属性也会被跳过 parse() JSON 字符串解析为 js 值 序列化选项 JSON.stringify() 参数 过滤器 数组 函数 replacer 选项 是否在 JSON 字符串中保留缩进 过滤结果 如果过滤器参数是数组，那么 stringily() 的结果中将只包含数组中列出的属性 如果是函数：该函数接收两个参数（属性名，属性值），根据属性名进行自定义序列化 12345678910111213141516171819var book = &#123; \"title\": \"Professional JavaScript\", \"authors\": [ \"Nicholas C. Zakas\" ], edition: 3, year: 2011&#125;; // js 对象var jsonText = JSON.stringify(book, function(key, value) &#123; switch(key)&#123; case \"authors\": return value.join(\",\") case \"year\": return 5000; case \"edition\": return undefined; default: return value; &#125;&#125;);// &#123;\"title\":\"Professional JavaScript\",\"authors\":\"Nicholas C. Zakas\",\"year\":5000&#125; 字符串缩进 数字：空格数，最大缩进空格数 10 字符串：缩进字符，不是用空格，最长10 toJSON() 方法Date 对象自带，也可以自定义 做为函数过滤器的补充 stringify() 执行顺序 如果存在 toJSON() 能取得有效值就调用 否则返回对象本身 如果提供了过滤器（第2个参数） 应用过滤器，传入的值是 1 返回的值 对 2 返回的每个值进行相应的序列化 如果提供第 3 个参数，执行相应的格式化 解析选项 JSON.parse() 参数 还原函数 reviver 在每个键值对上调用 接收两个参数（属性即键，值） 返回 undefined 表示删除相应的键","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第十七章 错误处理与调试","slug":"第17章-错误处理与调试","date":"2020-03-09T16:10:00.000Z","updated":"2020-03-09T16:57:53.341Z","comments":true,"path":"2020/03/10/第17章-错误处理与调试/","link":"","permalink":"http://ziiyan.github.io/2020/03/10/%E7%AC%AC17%E7%AB%A0-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95/","excerpt":"","text":"错误处理try-catch 语句1234567try &#123; // 可能会导致错误的代码&#125; catch(error) &#123; // 在错误发生时怎么处理 console.log(error.message) // 所有浏览器都支持 message 属性&#125; finally 子句 无论 try 或 catch，都会执行 finally 如果 try 或 catch 中有 return，会被忽略 因为一定要执行 finally 错误类型 Error 基类型，其它都继承这个 主要用于自定义 EvalError 没有把 eval() 当成函数调用，抛出异常 eval() 函数在第五章 RangeError 数值超出响应范围 ReferenceError 找不到对象 SyntaxError 传入语法错误的 JavaScript 给 eval() TypeError 变量中保存着意外的类型 访问不存在的方法 执行特定于类型的操作时，变量类型不符合要求 URIError encodeURI()、decodeURI() 时 URI 格式不正确 抛出错误throw 操作符 捕获错误的目的在于避免浏览器以默认方式处理它们 抛出错误的目的在于提供错误发生具体原因的消息 错误（error）事件没有通过 try-catch 处理的错误会触发 window 对象的 error 事件 常见的错误类型 类型转换错误 === !== if for while 数据类型错误 typeof instanceof 通信错误 encodeURIComponent() 调试技术 error(message) info(message) log(message) warn(message) 抛出错误 throw assert(条件, 如果条件不为 true 抛出的错误) 可以代替 if 语句","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第十四章 表单脚本","slug":"第14章-表单脚本","date":"2020-03-07T06:05:31.000Z","updated":"2020-03-15T13:22:39.406Z","comments":true,"path":"2020/03/07/第14章-表单脚本/","link":"","permalink":"http://ziiyan.github.io/2020/03/07/%E7%AC%AC14%E7%AB%A0-%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC/","excerpt":"","text":"第十四章 表单脚本表单的基本知识HTML 中，&lt;form&gt; 元素 Javascript 中，HTMLFormElement类型，继承 HTMLElement acceptCharset 服务器能够处理的字符集 accept-charset action 接受请求的 URL action elements 表单中所有控件集合 HTMLCollection enctype 请求的编码类型 enctype length 表单中控件的数量 method 要发送的HTTP请求类型 get/post method name 表单名称 name reset() 将所有表单域重置为默认值 submit() 提交表单 target 用于发送和接受响应窗口的名称 target 提交表单 &lt;input&gt; 和 &lt;button&gt; 都可以定义提交按钮，type = submit 即可 提交表单时，浏览器将请求发送给服务器之前触发 submit 事件，这样就有机会验证表单数据。 提交表单最大的问题是重复提交表单 第一次提交后禁用按钮 利用 onsubmit 事件处理程序 取消后续的表单提交操作 重置表单 &lt;input&gt; 或 &lt;button&gt; 中 type = reset，单击即可重置 表单字段每个表单都有 elements 属性，内容是所有表单元素的集合。集合是一个有序列表，包含表单中所有字段。 共有的表单字段属性 disabled form name readOnly tabIndex type value 共有的表单字段方法 focus() blur() autofocus 页面加载时自动获得焦点 共有的表单字段事件 blur change focus blur 和 change 先后顺序在各浏览器中不同 文本框脚本&lt;input&gt;、&lt;textarea&gt; 处理文本框时最好不要使用 DOM 方法（setAttribute） 选择文本select() 方法获得焦点时选择其所有文本 选择事件 取得选择的文本 selectionStart 数值，开头位置 selectionEnd 数值，结尾位置 选择部分文本 setSelectionRange() 过滤输入 屏蔽字符 操作剪贴板 剪贴板事件 beforecopy copy beforecut cut beforepaste paste clipboardData 对象 getData() setData() clearData() 自动切换焦点tabForward() HTML5 约束验证 API 必填字段 required 属性 其它输入类型 email url 数值范围 min max 输入模式 pattern 检测有效性 checkValidity() validity 禁用验证 novalidate 选择框脚本&lt;select&gt;、&lt;option&gt; add(newOption, relOption) multiple options 控件中所有 &lt;option&gt; 元素的 HTMLCollection，每个元素都是 HTMLOptionElement 对象 index label selected text value remove(index) selectedIndex size 表单序列化 表单提交期间，浏览器怎样将数据发送给服务器？ 对表单字段的名称和值进行 URL 编码，使用 &amp; 分隔 不发送禁用的表单字段 只发送勾选的复选框和单选按钮 不发送 type 为 reset 和 button 的按钮 多选选择框中的每个选中的值单独一个条目 在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。 &lt;select&gt; 元素的值，就是选中的 &lt;option&gt; 元素的 value 特性的值 富文本编辑WYSIWYG（What You See Is What You Get） 在页面中嵌入一个包含空 HTML 页面的 iframe 通过设置 designMode 属性，可以编辑，编辑的对象是该页面 body 元素的 HTML 代码","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第十六章 HTMl5 脚本编程","slug":"第16章-HTMl5脚本编程","date":"2020-03-07T06:05:31.000Z","updated":"2020-03-15T13:22:52.227Z","comments":true,"path":"2020/03/07/第16章-HTMl5脚本编程/","link":"","permalink":"http://ziiyan.github.io/2020/03/07/%E7%AC%AC16%E7%AB%A0-HTMl5%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/","excerpt":"","text":"第十六章 HTML5 脚本编程跨文档消息传递 XDM来自不同域的页面间传递消息 postMessage(消息，域) 发送【消息】给【域】中的 &lt;iframe&gt; 元素 接收到 XDM 消息时，会触发 window 对象的 message 事件，异步，有延迟 onmessage data origin source 原生拖放拖放事件 dragstart 按下鼠标触发 drag 拖动期间持续触发 dragend 拖动停止时触发，无论放置目标是否有效 当被拖动到一个有效的放置目标上 dragenter 拖动到放置目标上 dragover 放置目标范围内移动持续触发 dragleave 拖出放置目标范围 或 drop 放到放置目标中 自定义放置目标元素默认不允许放置，修改为可放置： 123456789var droptarget = document.getElementById(\"droptarget\");EventUtil.addHandler(droptarget, \"dragover\", function(event) &#123; EventUtil.preventDefault(event);&#125;);EventUtil.addHandler(droptarget, \"dragenter\", function(event) &#123; EventUtil.preventDefault(event);&#125;) dataTransfet 对象用于从被拖动元素向放置目标传递字符串格式的数据 getData() setData() 保存在 dataTransfer 对象中的数据只能在 drop 事件中被读取 dropEffect 被拖动元素能执行的放置行为 none move copy link effectAllowed 允许拖动元素的哪种 dropEffect uninitialized none copy link move copyLink copyMove linkMove all 可拖动默认情况下，图像、链接、文本可拖动 其它元素可以手动设置 draggable 属性为 ture 媒体元素&lt;audio&gt;、&lt;video&gt; 必须 src 指向要加载的媒体 属性表示媒体的当前状态 事件触发事件，监听属性变化，可能是播放结果，也可能是操作结果 历史状态管理history 对象","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第十三章 事件","slug":"第13章-事件","date":"2020-03-04T16:52:46.000Z","updated":"2020-03-04T16:53:27.439Z","comments":true,"path":"2020/03/05/第13章-事件/","link":"","permalink":"http://ziiyan.github.io/2020/03/05/%E7%AC%AC13%E7%AB%A0-%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"第十三章 事件js 和 html 之间的交互是通过事件实现的，事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器来预定事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式的模型，支持 js 和 html+css 之间的松散耦合。 事件流事件流描述的是从页面中接收事件的顺序 事件冒泡按照 DOM 树逐级向上，在每一级节点上都会发生，直到 document 事件捕获顺序与事件冒泡相反 DOM 事件流“DOM2 级事件”规定的事件流包括三个阶段： 事件捕获阶段 Document 到 目标元素的上一级 处于目标阶段 事件在目标元素上发生，事件处理被看成冒泡的一部分 事件冒泡阶段 目标元素 到 Document DOM2 规定捕获阶段不设计目标，但浏览器实现时都会出发事件对象上的事件 事件处理程序 事件就是某种动作，如 click、load、mouseovre 事件处理程序（事件侦听器）就是响应事件的函数，以 on 开头，onclick、onload 等 HTML 事件处理程序1234&lt;input onclick=\"showMessage()\"&gt;&lt;script&gt; function showMessage() &#123;……&#125;&lt;/script&gt; 如果用户在页面解析事件处理程序之前点击元素，会引发错误 扩展作用域链在不同浏览器中会导致不同结果 HTML 与 JavaScript 代码紧密耦合 DOM0 级事件处理程序将一个函数赋值给事件处理程序属性 12var btn = document.getElementById(\"myBtn\");btn.onclick = function () &#123;……&#125; 代码运行之前不会指定事件处理程序，可能导致点击无效 事件处理程序是在元素的作用域中运行的，this 引用当前元素 null 即删除 DOM2 级事件处理程序 addEventListener(a, b, c) removeEventListener(a, b, c) a 要处理的事件名 b 作为事件处理程序的函数 c 一个布尔值 true 捕获阶段调用事件处理程序 false 冒泡阶段调用事件处理程序 ☑️12var btn = document.getElementById(\"myBtn\");btn.addEventListener(\"click\", function() &#123;&#125;, false&#125; 事件处理程序是在元素的作用域中运行的，this 引用当前元素 存在多个事件处理程序会按照添加顺序触发 addEventListener()添加的事件处理程序只能使用 removeEventListener()来移除 addEventListener() 添加的匿名函数无法移除 IE 事件处理程序 attachEvent(a, b) detachEvent(a, b) a 事件处理程序名称 b 事件处理程序函数 只支持冒泡 事件处理程序的作用域是全局 存在多个事件处理程序会按照添加顺序相反的顺序触发 跨浏览器的事件处理程序关注冒泡阶段 addHandler(a, b, c) EventUtil(a, b, c) a 要操作的元素 b 事件名称 c 事件处理程序 事件对象在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与时间有关的信息 DOM 中的事件对象兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中 event.preventDefault() 阻止特定事件的默认行为，如链接到默认行为是导航到 href event.stopPropagation() 停止事件在 DOM 层次中的传播（捕获或冒泡） event.eventPhase 确定事件当前正位于事件流的哪个阶段 捕获 1 处于目标 2 冒泡 3 事件处理器执行期间 event 对象才会存在，执行完就销毁 IE 中的事件对象跨浏览器的事件对象事件类型UI事件不一定与用户操作有关 load 当页面完全加载后在 window 上触发，当图像加载完毕时在元素上面触发 unload 当页面完全卸载后在 window 上触发（页面切换时） resize 浏览器窗口调整大小时 window 上触发，通过 js 或 body 元素中 onresize 指定事件处理程序 scroll window 对象上发生，表示页面中相应元素的变化 焦点事件获得或失去焦点时触发 document.hasFocus() document.activeElement blur 元素失去焦点时触发，不冒泡 focus 获得焦点时触发，不冒泡 focusin 获得焦点时，冒泡 focusout 失去焦点时，冒泡 鼠标与滚轮事件 click 单击或回车 dblclick 双击 mousedown 按下任意鼠标按钮 mouseup 释放鼠标按钮 mouseenter 光标从外部首次移动到元素范围之内，不冒泡，移动到后代元素上不会触发 mouseleave 元素上的光标移动到元素范围之外，不冒泡，移动到后代元素不触发 mousemove 光标在元素内部移动时重复触发 mouseout 鼠标位于一个元素上方，移入另一个元素时触发。另一个元素可能是原来元素的外部或子元素 mouseover 光标位于一个元素外部，首次移入另一个元素边界之内 客户区坐标位置 event.clientX event.clientY 页面坐标位置 event.pageX event.pageY 屏幕坐标位置 event.screenX event.screenY 修改键 click + 键盘 -&gt; 属性（Boolean） Shift shiftKey Ctrl ctrlKey Alt altKey Meta(Windows/Cmd) metaKey 相关元素 针对 moseover、mouseout relatedTarget 属性 鼠标按钮 针对 mousedown、mouseup button 属性 0 主鼠标 1 滚轮 2 次鼠标 鼠标滚轮事件 mousewheel 冒泡 wheelDelta 属性 键盘与文本事件 keydown 任意键 keypress 字符键 keyup 释放案件 event.keyCode 键码，ASCII 小写字母相同 event.charCode 字符编码，针对 keypress 变动事件 删除节点 插入节点 HTML5 事件 contextmenu 冒泡 beforeunload DOMContentLoaded readystatechange uninitialized loading loaded interactive complete pageshow pagehide hashchange 设备事件智能手机和平板电脑 触摸与手势内存和性能添加到页面上 的事件处理程序数量将直接关系到页面的整体运行性能 函数对象占用内存 指定事件处理程序导致的 DOM 访问 事件委托利用事件冒泡，只指定一个事件处理程序 移除事件处理程序将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的 JavaScript 代码之间就 会建立一个连接。连接越多，页面执行起来就越慢。 模拟事件js 触发事件 DOM 中的事件模拟 document.createEvent() UIEvents MouseEvents MutationsEvents HTMLEvents 模拟鼠标 模拟键盘 模拟其他 IE 中","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第十章 DOM & 第十一章 DOM 扩展 & 第十二章 DOM2 和 DOM3","slug":"第10-12章-DOM相关","date":"2020-03-03T17:33:09.000Z","updated":"2020-03-15T13:21:59.338Z","comments":true,"path":"2020/03/04/第10-12章-DOM相关/","link":"","permalink":"http://ziiyan.github.io/2020/03/04/%E7%AC%AC10-12%E7%AB%A0-DOM%E7%9B%B8%E5%85%B3/","excerpt":"","text":"第十章 DOM 针对 HTML 和 XML 文档的一个 API 节点层次 文档元素是最外层元素，每个文档只有一个文档元素，HTML 中是 html Node 类型 js 所有节点类型都继承自 Node 类型 nodeType 值为 node 的类型常量（12种） 元素节点 Node.ELEMENT_NODE(1) 文本节点 Node.TEXT_NODE(3) nodeName 和 nodeValue 属性 nodeName 元素标签名 nodeValue 元素的值 节点关系 hashChildNodes() ownerDocument 指向文档节点（最外层节点） 操作节点 appendChild(newNode) childNodes 列表末尾添加一个节点 如果 newNode 已经存在 DOM 树中，会移动位置，而不是新建 insertBefore(NewNode, Node) 将 NewNode 插入到 Node 前面的位置 replaceChild(NewNode, Node) removeChild(Node)以上方法通过父节点调用 以下方法所有节点都有 cloneNode(Boolean) true 深复制，整个子节点树 false 浅复制，节点本身 返回的节点属于文档，但没有父节点 normalize() 处理文档节点 Document 类型浏览器中 document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，是 window 对象的一个属性 nodeType = 9 nodeName = “#document” nodeValue = null parentNode = null ownerDocument = null 子节点可能是一个 DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction 或 Comment 文档的子节点 document.documentElement 始终指向 HTML 页面中的 html 元素 document.body 指向 body 元素 document.doctype 文档信息浏览器专供属性，存在 HTTP 头部 document.title document.URL document.domain document.referrer 查找元素 document.getElementById() 多个元素相同 id 则返回第一个 document.getElementsByTagName() 返回 NodeList，HTML 文档中返回 HTMLCollection 对象 document.getElementsByName() 返回 HTMLCollection 对象 特殊集合 document.anchors document.forms document.images document.links 带 href 特性的 a 元素 文档写入 document.write() document.writeln() document.open() 打开网页输出流 document.close() 关闭网页输出流 Element 类型 nodeType = 1 nodeName = 元素的标签名 nodeValue = null parentNode 可能是 Document 或 Element 子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference nodeName 和 tagName 属性都是标签名 HTML 元素HTMLElement 继承 Element 并添加了一些属性 id title lang dir className 操作特性 getAttribute(‘class’) setAttribute(‘class’, &#39;ft&#39;) removeAttribute(&#39;class&#39;) attributes 属性attributes 属性中包含一个 NamedNodeMap 对象，元素每个特性都由一个 Attr 节点表示，节点保存在 NamedNodeMap 对象中对象方法 getNamedItem(name) removeNamedItem(name) setNamedItem(node) item(pos) 节点属性 nodeName nodeValue 创建元素 document.createElement(标签名)创建完成后需要调用前面介绍的方法将其添加到文档树中 Text 类型（开始和结束标签中的文本） nodeType = 3 nodeName = #text nodeValue 节点所包含的文本 parentNode 是 Element 没有子节点 document.createTextNode() 创建文本节点 normalize() 相邻的文本节点之间不存在空格，可以将所有相邻的文本节点拼接起来 splitText() 分割文本节点 Comment 类型 nodeType = 8 nodeName = #comment nodeValue = 注释的内容 parentNode 可能是 Document 或 Element 没有子节点 CDATASection 类型 针对 XML 文档，表示 CDATA 区域 浏览器会解析为 Comment 或 Element DocumentType 类型包含 doctype 有关的信息 DocumentFragment 类型Attr 类型元素的特性，不是 DOM 文档树的一部分 DOM 操作技术动态脚本DOM 操作 script 标签 动态样式DOM 操作 link 标签 和 style 标签 操作表格DOM 操作 table 标签 使用 NodeList NodeList NamedNodeMap HTMLCollection每当文档结构发生变化，它们都会更新，保存最新的信息 理解 DOM 的关键，就是理解 DOM 对性能的影响。DOM 操作往往是 JavaScript 程序中开销最大的 部分，而因访问 NodeList 导致的问题为最多。NodeList 对象都是“动态的”，这就意味着每次访问 NodeList 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作。 第十一章 DOM 扩展选择符 API 参数为 CSS 选择符 querySelector() 返回元素 querySelectorAll() 返回 NodeList 快照 元素遍历 childElementCount 不包括文本节点和注释 firstElementChild lastElementChild previousElementSibling nextElementSibling HTML5与类相关的扩充 getElementsByClassName() classList DOMTokenList 的实例 焦点管理 activeElement 当前获得焦点的元素 hasFocus() 文档是否获得焦点（用户是否正在与页面交互） HTMLDocument 的变化 readyState 属性 loading complete compatMode 兼容模式 CSS1Compat 标准模式 BackCompat 混杂模式 head 引用 head 标签元素 字符集属性 charset 默认 ”UTF-16“ defaultCharset 根据默认浏览器及操作系统设置 自定义数据属性 添加前缀 data- dataset 属性访问自定义属性的值 值是 DOMStringMap 的一个实例 也就是一个名值对的映射 插入标记 innerHTML 属性 outerHTML 属性 insertAdjacentHTML() 方法 params1 插入位置 beforebegin afterbegin beforeend afterend params2 HTML 文本 内存与性能问题 scrollIntoView() 方法让当前的元素滚动到浏览器窗口的可视区域内 第十二章 DOM2 和 DOM3DOM1 主要定义的是 HTML 和 XML 文档的底层结构，DOM2 和 DOM3 分为许多模块，分表描述 DOM 的某个非常具体的子集，目的在于扩展 DOM API 样式定义样式 &lt;link/&gt; 外部样式表 &lt;style/&gt; 嵌入式样式 style 特性 针对特定元素的样式 访问元素的样式 元素的 style 特性是 CSSStyleDeclaration 的实例 CSS 属性的短线转为驼峰才能通过 js 访问 float 是保留字所以 转为 cssFloat 操作样式表CSSStyleSheet 类型表示的是样式表，继承自 StyleSheet，后者可以作为一个基础接口来定义非 CSS 样式表 元素大小 偏移量 客户区大小 所有偏移量、客户区大小都是只读的，每次访问要重新计算。避免重复访问，有需要可以保存下来。 滚动大小 确定元素大小getBoundingClientRect() 返回 DOMRect 对象，包含四个值 遍历 NodeIterator TreeWalker 范围 范围是选择 DOM 结构中特定部分，然后再执行相应操作的一种手段。 使用范围选区可以在删除文档中某些部分的同时，保持文档结构的格式良好，或者复制文档中的相应部分。","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第八章 BOM","slug":"第8章-BOM","date":"2020-03-02T15:41:03.000Z","updated":"2020-03-15T13:20:54.606Z","comments":true,"path":"2020/03/02/第8章-BOM/","link":"","permalink":"http://ziiyan.github.io/2020/03/02/%E7%AC%AC8%E7%AB%A0-BOM/","excerpt":"","text":"第八章 BOMwindow 对象 BOM 的核心对象是 window，表示浏览器的一个实例全局作用域 Window 作为 Global 对象，所有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法 全局变量不能通过 delete 删除，直接在 window 对上定义的属性可以 窗口位置 window.screenLeft window.screenTop window.screenX window.screenY window.moveTo(x, y) window.moveBy(a, b) 窗口大小 window.innerWidth window.innerHeight window.outerWidth window.outerHeight window.resizeTo(w, h) window.resizeBy(w, h) 导航和打开窗口 window.open(URL, target, String, Boolean) 间歇调用和超时调用 setTimeout(function, ms) ms 后把当前任务添加到任务队列，如果此时任务队列是空的才会立即执行 所以不一定 ms 后就会执行 function 返回一个数值 ID clearTimeout(timeoutID) setInterVal(function, ms) clearInterval(timeoutID) 系统对话框样式由操作系统或浏览器决定显示这些对话框的时候代码会停止执行 alert() confirm() prompt() find() print() location 对象 既是 window 对象的属性，也是 document 对象的属性 window.LOcation 和 document.location 引用的是同一个对象 位置操作 location.assign(url) window.location = &quot;url&quot; location.href = &quot;url&quot;修改 location 其它属性页面都会重新加载，浏览器的历史记录会生产一条新记录 replace(url) 不会产生新记录 reload() 无参数，可能是用缓存 参数 true，强制从服务器重新加载 调用之后的代码可能会也可能不会执行，这要取决于网络延迟或系统资源等因素。最好将 reload()放在代码的最后一行 screen 对象history 对象 history.go() number 前进或后退页面 string 跳转到历史记录中包含string最近的位置 history.back() 后退 history.forward() 前进 history.length 历史记录数量","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第十五章 使用 Canvas 绘图","slug":"第15章-使用Canvas绘图","date":"2020-03-02T15:05:31.000Z","updated":"2020-03-09T17:06:45.017Z","comments":true,"path":"2020/03/02/第15章-使用Canvas绘图/","link":"","permalink":"http://ziiyan.github.io/2020/03/02/%E7%AC%AC15%E7%AB%A0-%E4%BD%BF%E7%94%A8Canvas%E7%BB%98%E5%9B%BE/","excerpt":"","text":"基本用法 设置 width 和 height 属性，制定绘图区域1&lt;canvas id=\"drawing\" width=\"200\" height=\"200\"&gt;A drawing of something.&lt;/canvas&gt; 取得绘图上下文1234567var drawing = document.getElementById(\"drawing\");//确定浏览器支持 &lt;canvas&gt; 元素if (drawing.getContext) &#123; var context = drawing.getContext(\"2d\"); ……&#125; 导出绘制的图像1234567891011var drawing = document.getElementById(\"drawing\");if (drawing.getContext) &#123; //取得图像的数据 URI var imgURI = drawing.toDataURL(\"imge/png\"); //显示图像 var image = document.createElement(\"img\"); image.src = imgURI; document.body.appendChild(image);&#125; 2D上下文 坐标开始于左上角，原点坐标 (0, 0) x 越大靠右，y 越大靠下 width 和 height 表示水平和垂直两个方向上可用的像素数 填充和描边 fillStyle 填充（字符串、渐变对象或模式对象） strokeStyle 描边（字符串、渐变对象或模式对象） lineWidth 线条宽度（整数） lineCap 线条末端形状（“butt”、“round”、“square”） lineJoin 线条相交形状（“round”、“bevel”、“miter”） 绘制矩形 fillRect(x, y, w, h) strokeRect(x, y, w, h) clearRect(x, y, w, h) x: x 坐标 y: y 坐标 w: 矩形宽度 h: 矩形高度 绘制路径 调用beginPath()表示开始绘制新路径 绘制路径 arc(x, y, radius, startAngle, endAngle, counterclockwise) arcTo(x1, y1, x2, y2, radius) bezierCurveTo(c1x, c1y, c2x, c2y, x, y) lineTo(x, y) moveTo(x, y) quadraticCurveTo(cx, cy, x, y) rect(x, y, width, height) 绘制到画布 closePath() fill() stroke() clip() isPointInpath(x, y) 点(x, y)是否在路径上 绘制文本 fillText(string, x, y, (可选)font-size) strokeText(string, x, y, (可选)font-size) font 文本样式、大小、字体 textAlign 文本对齐方式 textBaseline 文本基线 measureText() 确定文本大小 变换 rotate(angle) 绕原点旋转图像 scale(scaleX, scaleY) 缩放图像 translate(x, y) 将坐标原点移动到 (x, y) transform(m1_1, m1_2, m2_1, m2_2, dx, dy) 修改变换矩阵 setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy) 将变换矩阵重置为默认状态再调用 transform() save() 保存上下文状态 restore() 读取保存的状态 绘制图像 drawImage() 要绘制的图像 源图像的 x 坐标 源图像的 y 坐标 源图像的宽度 源图像的高度 目标图像的 x 坐标 目标图像的 y 坐标 目标图像的宽度 目标图像的高度 阴影 shadowColor shadowOffsetXr shadowOffsetY shadowBlur 渐变 cg = createLinearGradient() 创建新的渐变，返回 CanvasGradient 对象 cg.addColorStop() 制定色标 fillStyle = cg/strokeStyle = cg 绘制 模式 重复的图像 createPattern() 使用图像数据 getImageData() 合成 globalAlpha 透明度 globalCompositionOperation source-over(默认值):后绘制的图形位于先绘制的图形上方 ……","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第七章 函数表达式","slug":"第7章-函数表达式","date":"2020-02-29T16:51:34.000Z","updated":"2020-03-03T17:41:19.385Z","comments":true,"path":"2020/03/01/第7章-函数表达式/","link":"","permalink":"http://ziiyan.github.io/2020/03/01/%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"定义函数的方式 函数声明123456functionName(); // 正确function functionName() &#123; ……&#125;// 函数声明提升// 执行代码前会读取函数声明，意味着可以把函数声明放在调用后面 函数表达式123456functionName(); // 报错var functionName = function() &#123; ……&#125;// 没有函数声明提升// 使用前必须先赋值 function 关键字后面没有标识符，所以叫匿名函数，也叫拉姆达函数。 递归12345678910111213141516171819202122function factorial(num) &#123; if (num &lt;= 1) &#123; reutrn 1; &#125; else &#123; return num * factorial(num-1); &#125;&#125;var anotherFactorial = factorial;factorial = null;alert(anotherFactorial(4)); // 报错// 因为调用 anotherFactorial(num) 时，函数内部会执行 factorial(num-1)，而此时 factorial 已经被置为 null// 改为 arguments.callee 即可，如下function factorial(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125; 闭包闭包是指(有权访问[另一个函数作用域中的变量]的)函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。 123456789101112131415function createComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; // 这个匿名函数的作用域链中包含 createComparisonFunction() 的作用域，所以这两行代码可以访问外部函数中的变量 propertyName if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125; 当函数执行完毕后，局部活动对象会被销毁，内存仅保留全局作用域。但是闭包有所不同。在另一个函数内部定义的函数会将包含它的函数（即外部函数）的活动对象添加到它的作用域链中。因此，createComparisonFunction() 函数内部定义的匿名函数的作用域链中，实际上会包含外部函数 createComparisonFunction() 的活动对象。在匿名函数从 createComparisonFunction() 中被返回后，它的作用域链被初始化为 包含 createComparisonFunction() 函数的活动对象和全局变量对象。这样，匿名函数就可以访问在 createComparisonFunction() 中定义的所有变量。同时，createComparisonFunction() 的活动对象由于被匿名函数的作用域链引用，在函数执行完毕之后不会被销毁。 由于闭包会携带外部函数的作用域，因此会比其他函数占更多的内存。所以要慎重使用闭包。 闭包与变量 闭包只能取得包含函数中每个变量的最新值 因为每个函数作用域链中都保存着外部函数的活动对象，是共享的，最后更新的内容会被引用。 关于 this 对象 匿名函数的执行环境具有全局性，this 通常指向 window。用 call 或 apply 改变制定环境时会指向其他对象。12345678910111213141516171819var name = \"The Window\";var object = &#123; name: \"My Object\", var that = this getNameFunc: function() &#123; return function() &#123; return this.name + \" \" that.name; &#125;; &#125; getName: function() &#123; return this.name &#125;&#125;;alert(object.getNameFunc()()); // \"The Window My Object\"alert(object.getName()); // \"My Object\" 内存泄漏 闭包会引用包含函数的整个活动对象，可以活动对象中的变量赋值 null 解除引用，保证内存正常回收。 模仿块级作用域（）私有作用域1234(function() &#123; // 这里是块级作用域&#125;)();// 定义并立即调用了一个匿名函数 1234567891011121314// 理解过程// 定义一个函数并立即调用var someFunction = function() &#123; // 这里是块级作用域&#125;;someFunction();// 用函数的值直接取代函数名function() &#123; // 这里是块级作用域&#125;(); // 报错，函数声明后不能跟圆括号(function() &#123; // 这里是块级作用域&#125;)(); // 正确，函数表达式可以跟圆括号 私有变量 严格来说，js 中没有私有成员的概念，所有的对象属性都是公有的 个人理解：oop 语言中私有成员不能被子类继承，而 js 中所有对象属性都能被继承，因此都是公有的 但有私有变量的概念，任何在函数中定义的变量都可以认为是私有变量，因为不能在函数的外部访问这些变量 私有变量包括 函数的参数 局部变量 在函数内部定义的其他函数 特权方法：有权访问私有变量和私有函数的公有方法12345678910111213141516// 在构造函数中定义特权方法function MyObject() &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; // 特权方法 this.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;&#125; 静态私有变量1234567891011121314151617(function() &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return fasle; &#125; // 构造函数（没有var，全局变量） MyObject = function() &#123; &#125;; // 公有/特权方法 MyObject.prototype.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125;)(); 模块模式 模块模式：为单例创建私有变量和特权方法 单例：只有一个实例的对象 123456var singleton = &#123; name: value, method: function() &#123; …… &#125;&#125;; 12345678910111213141516var singleton = function() &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; // 返回单例的公共接口 return &#123; publicProperty: true, publicMethod: function() &#123; privateVariable++; return privateFunction(); &#125; &#125;&#125; 增强的模块模式123456789101112131415161718var singleton = function() &#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; //创建对象 var object = new CustomType(); //添加特权/公有属性和方法 object.publicProperty = true; object.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;; //返回这个对象 return object; &#125;();","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第六章 面向对象程序设计","slug":"第6章-面向对象程序设计","date":"2020-02-27T17:18:54.000Z","updated":"2020-07-22T11:15:57.218Z","comments":true,"path":"2020/02/28/第6章-面向对象程序设计/","link":"","permalink":"http://ziiyan.github.io/2020/02/28/%E7%AC%AC6%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"面向对象语言的标志是都有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。 而 ECMAScript 中没有类的概念，因此它的对象和基于类的语言中的对象有所不同。 ECMAscript 对象定义：无序属性的集合，其属性可以包含基本值、对象或函数。 每个对象都是基于一个引用类型创建的。可以是原生类型，也可以是开发人员定义的类型。 理解对象属性类型属性数据 [[Configurable]]:表示能否通过 delete 删除属性从而定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。 [[Enumerable]]:表示能否通过 for-in 循环返回属性。 [[Writable]]:表示能否修改属性的值。 [[Value]]:包含设个属性的数据值。 Object.defineProperty(属性所在对象，属性的名字，描述符对象)：修改属性默认的特性 访问器属性 [[Configurable]]:表示能否通过 delete 删除属性从而定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。 [[Enumerable]]:表示能否通过 for-in 循环返回属性。 [[Get]]:在读取属性时调用的函数，默认值 undefined。 [[Set]]:在写入属性时调用的函数，默认值 undefined。 访问器属性不能直接定义，必须使用Object.defineProperty()来定义。 1234567891011121314151617var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, \"year\", &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;);book.year = 2005; alert(book.edition); // 2 定义多个属性 Object.defineProperties(对象，要添加和修改属性) 通过描述赋一次定义多个属性读取属性的特性 Object.getOwnPropertyDescriptor(属性所在的对象，要读取其描述符的属性名称)返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get 和 set；如果是数据属性，这个对象的属性有 configurable、enumerable、writable 和 value。 创建对象工厂模式 抽象了创建具体对象的过程 12345678910function createPerson (name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; return o;&#125; 构造函数模式 定义在 Global 对象（浏览器即 window 对象）中 12345678function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125; new 操作符调用构造函数时： 创建一个新对象 将构造函数的作用域赋给新对象（this 就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性、方法等） 返回新对象12var person = new Person(\"Greg\", 27, \"Doctor\");console.log(person.constructor == Person) // true 将构造函数当作函数 构造函数与其他函数唯一的区别是调用方式不同12345678910// 构造函数var person = new Person(\"Greg\", 27, \"Doctor\");person.sayName();// 普通函数Person(\"Greg\", 27, \"Doctor\");window.sayName();// 在另一个对象的作用域中调用var o = new Object();Person.call(o, \"Greg\", 27, \"Doctor\");o.sayName(); 构造函数的缺点 每个方法都要在每个实例上重新创建一遍 不同实例上的同名函数是不相等的 123456789function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName; &#125; function sayName()&#123; alert(this.name); &#125; 如果需要很多方法，就需要定义很多全局函数 原型模式 每个函数都有 prototype（原型）属性 是一个指针，指向一个对象 对象包含所有实例共享的属性和方法 换句话说，prototype 就是通过调用构造函数而创建的对象实例的原型对象 好处 让所有对象实例共享它所包含的属性和方法 不必在构造函数中定义对象实例的信息，而且将这些信息直接添加到原型对象中12345678function Person() &#123;&#125;Person.prototype.name = \"Grey\";Person.prototype.age = 29;Person.prototype.job = \"Doctor\";Person.prototype.sayName = function() &#123; alert(this.name);&#125; 理解原型对象 只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象 默认情况下，所有原型对象会自动获得一个 constructor(构造函数) 属性，这个属性包含一个指向 prototype 属性所在函数（也就是构造函数）的指针 Person.prototype.constructor 指向 Person 每个实例有一个[[Prototype]]（__proto__）属性，指向构造函数的原型对象 isPrototypeOf()确定原型关系 Person.prototype.isPrototypeOf(person) Object.getPrototypeOf() 返回[[Prototype]] 的指针 Object.getPrototypeOf(person) == Person.prototype 在实例中修改属性值，会屏蔽原型中的同名属性 delete person.name 删除实例中的 name 属性，console.log(person.name) 将输出原型中的 name 属性 Person.prototype.name hasOwnProperty() 检测一个属性是否在实例中，false 来自原型 原型与 in 操作符 单独使用 属性 in 实例 无论属性在实例还是在原型，都返回 true for-in 返回可枚举的（enumerated）属性 无论属性在实例还是在原型 Object.keys(对象) 返回所有可枚举属性名Object.getOwnPropertyNames(对象) 返回所有属性名 更简单的原型语法1234567891011function Person() &#123;&#125;Person.prototype = &#123; name: \"Grey\", age: 29, job: \"Doctor\", sayName: function() &#123; alert(this.name); &#125;&#125;; 字面量形式创建原型 Person.prototype.constructor 不再指向 Person （前面说）每创建一个函数，就会同时创建它的 prototype 对象，这个对象自动获得 constructor 属性 这里完全重写了默认的 prototype 对象，constructor 属性指向 Object 构造函数原型的动态性 实例中的指针仅指向原型，而不指向构造函数 重写原型对象切断了现有原型与之前任何一件存在的对象实例直接的联系；对象实例引用的原型是重写之前的 原型模式的缺点如果原型包含引用类型值的属性，由于原型中的值是所有实例对象共享的，在一个实例对象中修改引用类型，会体现在别的实例对象中 组合使用构造函数模型和原型模式 构造函数模型用于定义实例属性 原型模式用于定义方法和共享属性 动态原型模式 在构造函数中检查是否存在某个方法，再决定是否需要初始化原型 12345678910function Person (name, age, job) &#123; this.name = name; this.age = age; this.job = job; if (typeof this.sayName != \"function\") &#123; Person.prototype.sayName = function () &#123; alert(this.name); &#125; &#125;&#125; 寄生构造函数模式 不能用 instanceof 不推荐 1234567891011121314151617181920// 寄生构造函数模式function Person(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; return o;&#125;// 构造函数模式function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125; 稳妥构造函数模式 稳妥对象 没有公共属性，方法也不引用 this 安全的环境中禁止使用 this 和 new 1234567function Person(name, age, job) &#123; var o = new Object(); o.sayName = function() &#123; alert(name); &#125;; return o;&#125; 只有 sayName() 能访问数据成员 继承 面向对象语言中 接口继承 只继承方法签名 实现继承 继承实际的方法 ECMAScript 中函数没有签名，无法实现接口继承，故只支持实现继承 依靠原型链原型链 利用原型让一个引用类型继承另一个引用类型的属性和方法 构造函数 A 和原型 A 都有一个指向原型对象 A 的指针，而原型对象 A 有一个指向构造函数 A 的指针。让原型对象 A 等于另一个类型的实例 B。此时原型对象 A（也就是实例 B）将包含一个指向原型对象 B 的指针，原型对象 B 中包含一个指向构造函数 B 的指针。假如原型 B 又是另一个类型的实例 C，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。 默认的原型所有引用类型默认继承 Object，在原型链最后都是 Object 原型对象，包含一个指针指向 Object 构造函数。 确定原型和实例的关系 实例 instanceof 构造函数 实例的原型链中出现过构造函数就返回 true 原型对象.isPrototypeOf(实例) 实例的原型链中出现过原型对象就返回 true 对象字面量创建原型方法会重写原型链12345678910SubType.prototype = new SuperType();// 导致上一行代码无效SubType.prototype = &#123; getSubValue: function() &#123; return this.subproperty; &#125;, someOtherMethod: function() &#123; return false; &#125;&#125;; 原型链的缺点 不能给超类型的构造函数传递参数借用构造函数（伪造对象/经典继承） 在子类型构造函数的内部调用超类型构造函数（利用 call 或 apply）1234567function SuperType(name) &#123; ……&#125;function SubType() &#123; // 继承了 SuperType SUperType.call(this, name);&#125; 可以给超类型的构造函数传递参数组合继承（伪经典继承） 最常用 组合原型链和借用构造函数 原型链实现对原型属性和方法的继承 借用构造函数实现对实例属性的继承 缺点 调用两次超类型构造函数 创建子类型原型 子类型构造函数内部 原型式继承 Object.create(作为新对象原型的对象， 作为新对象定义额外属性的对象) 返回一个新对象 寄生式继承 创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象寄生组合式继承 通过借用构造函数来继承属性 通过原型链的混成形式来继承方法","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第五章 引用类型","slug":"第5章-引用类型","date":"2020-02-22T14:05:54.000Z","updated":"2020-02-22T14:10:11.724Z","comments":true,"path":"2020/02/22/第5章-引用类型/","link":"","permalink":"http://ziiyan.github.io/2020/02/22/%E7%AC%AC5%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"引用类型是一种数据结构，用于将数据和功能组织在一起。 引用类型的值（对象）是引用类型的一个实例。 引用类型与类看起来相似，但并不相同。 ECMAScript 从技术上讲是一门面向对象的语言，但不具备传统的面向对象语言所支持的类和接口等基本结构。 引用类型也被称为对象定义，描述一类对象所具有的属性和方法。 ECMAScript 提供类很多原生引用类型（例如 Object） Object 类型大多数对象都是 Object 类型的实例 创建实例 new 操作符123var person = new Object();person.name = \"Nicholas\";person.age = 29; 对象字面量 对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。1234var person = &#123; name: \"Nicholas\", age: 29&#125;; 1234// 定义只包含默认属性和方法的对象var person = &#123;&#125;;// 或var person = new Object(); 通过对象字面量定义对象时，实际上不会调用 Object 构造函数疑问：对象字面量是怎么定义对象的？ Array 类型和其他语言的区别：每一项可以保存任何类型的数据，互相之间不影响 创建实例 new123var colors = new Array();var colors = new Array(20); // length = 20var colors = new Array(\"Grey\"); // length = 1 省略 new1var colors = Array(3); // length = 3 数组字面量12var names = [];var colors = [\"red\", \"blue\", \"green\"]; 数组字面量表示法时不会调用 Array 构造函数 length 可修改，会移除超出的项 当把一个值放在超出当前数组大小的位置上时，会重新计算长度，长度值为最后一项的索引 + 112345678var colors = [\"red\", \"blue\", \"green\"];// [\"red\", \"blue\", \"green\"]colors.length = 2;// [\"red\", \"blue\"]colors.length = 3;// [\"red\", \"blue\", empty]console.log(colors[3]);// [\"red\", \"blue\", empty, \"green\"] length = 4 检测数组value instanceof Array 假定只有一个全局执行环境，如果从一个框架向另一个框架传入数组，就具有不同的构造函数Array.isArray()转换方法 Array.toString() Array.toLocaleString() Array.valueOf()栈/队列方法 Array.push 末尾添加 Array.pop 取最后一项并移除 Array.shift 取第一项并移除 Array.unshift 头部添加重排序 Array.reverse() 反转顺序 Array.sort() 先转 toString()，字符串升序 sort 接收比较函数 params1 -&gt; params2 ===&gt; -1 params2 -&gt; params1 ===&gt; 1操作方法 Array.concat Array.slice(a, b) [a, b) 负数则从末尾开始数 Array.splice(a, b, ...c) a 位置 b 要删除的项数 c 插入的内容（若干） return 被删除的内容 位置方法查找数组内容，===，返回下标 Array.indexOf() Array.lastIndexOf()迭代方法 两个参数 要在每一项上运行的函数 三个参数 数组项的值 该项再数组中的位置 数组对象本身 （可选的）运行该函数的作用域对象 影响this的值 Array.every() 每一项都返回 true，则返回 true Array.some() 任一项返回 true，则返回 true Array.filter() 返回该函数返回 true 的项组成的数组 Array.map() 返回每次函数调用的结果组成的数组 Array.forEach() 没有返回值 以上方法都不回修改数组中包含的值 归并方法 Array.reduce() Array.reduceRight() 两个参数 每一项上调用的函数 四个参数 前一个值 当前值 项的索引 数组对象 （可选的）作为归并基础的初始值 返回值作为第一个参数传给下一项 第一次迭代发生在第二项上，第一个参数是数组的第一项，第二个参数是数组的第二项 Date 类型 Date.parse() params: 表示日期字符串，格式因地区而异 return: 毫秒 Date.UTC() params: 年份、月份（0开始）、天数、小时、分钟、秒、毫秒 return: 毫秒 Date.now()继承的方法 Date.toLocaleString() 根据当地时区 Date.toString() 带有时区信息 Date.valueOf() 毫秒日期格式化方法 Date.toDateString() Date.toTimeString() Date.toLocaleDateString() Date.toLocaleTimeString() Date.toUTCString() Date.toLocaleString() 因浏览器而异 RegExp 类型1var expression = / pattern / flags ; pattern ( [ { \\ ^ $ | ) ? * + . ] } 需要转义 flags g 全局，默认匹配第一个停止 i 不区分大小写 m 多行模式RegExp 实例属性 global ignoreCase lastIndex multiline source RegExp 实例方法 exec test toString toLocaleString valueOf 构造函数属性其他语言中被看成是静态属性 长属性名 短属性名 说明 input $_ 最近一次要匹配的字符串 lastMatch $&amp; 最近一次的匹配项 lastParen $+ 最近一次匹配的捕获组 leftContext $` input 字符串中 lastMatch 之前的文本 multiline $* 布尔值，是否所有表达式都使用多行模式 rightContext $’ input 字符串中 lastMatch 之后的文本 Function 类型 每个函数都是 Function 类型的实例，具有属性和方法。 函数名是一个只想函数对象的指针，不会与某个函数绑定。 创建实例 函数声明 123function sum (num1, num2) &#123; return num1 + num2;&#125; 函数表达式 123var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 区别：解析器会先读取函数声明，在执行任何代码之前可用（函数声明提升）函数表达式要等解析器执行到它所在的代码行才会被解释执行 Function 构造函数（不推荐） 1var sum = new Function(\"num1\", \"num2\", \"return num1 + num2\"); 没有重载声明两个同名函数，后面的函数覆盖前面的，结合 “函数是对象，函数名是指针” 很好理解。 作为值的函数 函数名本身是变量，可以作为值来使用 可以作为参数，也可以作为返回值 函数的内部属性 arguments 类数组对象 callee 属性，该属性是一个指针，指向拥有这个 arguments 对象的函数 this 引用的是执行函数的环境对象1234567891011sindow.color = \"red\";var o = &#123; color: \"blue\" &#125;;function sayColor() &#123; alert(this.color);&#125;sayColor(); // \"red\"o.sayColor = sayColor;o.sayColor(); // \"blue\" caller 调用当前函数的函数的引用，全局中调用当前函数则 null123456789function outer() &#123; inner();&#125;function inner() &#123; console.log(inner.caller); // inner.callr 指向 outer() // 等价于 arguments.callee.caller&#125;outer(); 函数属性和方法 length 函数希望接收的命名参数的个数 prototype 对引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，toString() 和 valueOf() 等方法都是保存在 prototype 名下，只是通过各自对象的实例访问。 不可枚举，for-in 无法发现。 每个函数都包含两个非继承而来的方法，都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。 apply 两个参数 在其中运行函数的作用域 参数数组 call 1 + n 个参数 在其中运行函数的作用域 一个一个地传入参数 bind 创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值 基本包装类型为了便于操作基本类型值，ECMAScript 提供 3 个特殊的引用类型：Boolean、Number、String 12var s1 = \"smoe.txt\";var s2 = s1.substring(2); 基本类型不是对象，理论上不应该有方法。当第二行代码访问 s1 时，访问过程处于一种读取模式，从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台自动完成：(1) 创建 String 类型的一个实例(2) 在实例上调用指定的方法(3) 销毁这个实例 引用类型与基本包装类型的主要区别是对象的生存期 引用类型的实例在执行流离开当前作用域之前一直保存在内存中 基本包装类型只存在于一行代码的执行瞬间 可以显示的创建基本包装类型的对象，但会分不清自己在处理基本类型还是引用类型的值 new 调用基本包装类型的构造函数，和转型函数是不一样的1234567var value = \"25\";var number = Number(value); // 转型函数console.log(typeof number); // \"number\"var obj = new Number(value); // 构造函数console.log(typeof obj); // “object\" Boolean 类型布尔表达式中，所有的对象都会转为 true 123var falseObject = new Boolean(false);var result = falseObject &amp;&amp; true;alert(result); // true 产生误解，建议不要使用 Number 类型 toString(n) n 进制 toFixed(n) 四舍五入 n 位小数 toExponential(n) n 位数表示一个数字 字符方法 charAt charCodeAt 方括号表示法[]下标读取字符 字符串操作方法 concat 拼接字符串，常用+ slice substr substring 字符串位置方法 indexOf lastIndexOf trim() 方法创建一个字符串的副本，删除前置以及后缀的所有空格，然后返回结果 字符串大小写转换 toLowerCase toLocaleLowerCase toUpperCase toLocaleUpperCase 字符串的模式匹配方法 match params:正则表达式或 RegExp 对象 本质调用 RegExp 的 exec search params:正则表达式或 RegExp 对象 return: 下标，找不到 -1 replace 两个参数，用第二个参数替换第一个 第一个参数可以是正则 第二个参数可以是函数 split 基于一个制定的分隔符，将一个字符串分割成多个子字符串 localeCompare() 方法比较两个字符串，各地区实现不同 fromCharCode() 方法接收一个或多个字符编码，然后转换成一个字符串 单体内置对象ECMA-262对单体内置对象的定义：由 ECMAScript 实现提供的，不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。 前面已经介绍了大多数内置对象，如 Object、Array、String Global 对象 不属于任何其他对象的属性和方法，最终都是 Global 对象的属性和方法 事实上，没有全局变量或全局函数。所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。如 isNan()、isFinite()、parseint() encodeURI() 用于整个 URIencodeURIEomponent() 用于 URI 中的一段decodeURI()decodeURIEomponent() eval() 像一个完整的 ECMAScript 解析器 params: 要执行的 ECMAScript 字符串 Global 对象属性 undefined、NaN、Infinity 等 Object、Function 等 window 对象 Web 浏览器中，Global 对象是 window 对象的一部分 Math 对象 Math 对象的属性 Math.E Math.LN10 Math.LN2 Math.LOG2E Math.LOG10 Math.PI Math.SQRT1_2 Math.SQRT2 min()、max() 舍入方法 Math.ceil() 向上舍入 Math.floor() 向下舍入 Math.round() 四舍五入 random() [0, 1) 随机数 其他方法 Math.abs(num) Math.exp(num) Math.log(num) Math.pow(num, power) Math.sqrt(num) Math.acos(x) ……","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第四章 变量、作用域和内存问题","slug":"第4章-变量、作用域和内存问题","date":"2020-02-17T14:16:00.000Z","updated":"2020-02-17T14:20:57.688Z","comments":true,"path":"2020/02/17/第4章-变量、作用域和内存问题/","link":"","permalink":"http://ziiyan.github.io/2020/02/17/%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/","excerpt":"","text":"基本类型和引用类型的值 基本数据类型（5）按值访问，可以操作保存在变量中的实际的值。占据固定大小的空间，被保存在栈内存中。 引用类型（1）的值是保存在内存中的对象，保存在堆内存中。JS 不能直接操作对象的内存空间：复制保存对象的某个变量时，操作对象的引用；为对象添加属性时，操作的是实际的对象。 复制变量值 基本类型：创建新值 引用类型：创建新值，值是指针，实际与旧值引用同一个对象 传递参数ECMAScript 中所有函数的参数都是按值传递的。 基本类型：被传递的值会被复制给一个局部变量。 引用类型：被传递的值的地址复制给一个局部变量。因此这个局部变量的变化会反应在函数的外部。 若在函数体内对这个局部变量进行重新赋值，那么保存的地址就改变了，指向的内存也不再是被传入的对象。 1234567function setName(obj) &#123; obj.name = \"Nicholas\";&#125;var person = new Object();setName(person);alert(person.name); //“Nicholas” 123456789function setName(obj) &#123; obj.name = \"Nicholas\"; obj = new Object(); obj.name = \"Greg\";&#125;var person = new Object();setName(person);alert(person.name); //“Nicholas” 在内部重写 obj 时，变量引用的就是一个局部对象了。局部对象在函数执行完毕后立即被销毁。 检测类型 基本类型：typeof 引用类型：instanceof 根据12345// result = variable instanceof constructor// 根据原型链来识别alert(person instanceof Object);alert(person instanceof Array);alert(person instanceof RegExp); 所有引用类型的值都是 Object 的实例。Obj instanceof Object 始终返回 true，检测基本类型始终 false，因为基本类型不是对象。 执行环境及作用域 执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。 每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 全局执行环境：根据宿主环境。WEB 浏览器中是 window 对象。 执行环境，函数的环境，保存在栈中。 当代码在一个环境中执行时，会创建变量对象的一个作用域链，保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链的前端，始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量（即arguments对象，全局环境中不存在）。下一个变量对象来自包含（外部）环境……一直到全局执行环境。标识符解析是沿着作用域链一级一级地搜索标识符的过程。内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境重的变量和函数。 延长作用域链 try-catch 语句的 catch 块 with 语句1234567function buildUrl() &#123; var qs = \"?debug=true\"; with (location) &#123; var url = href + qs; &#125; return url;&#125; with 语句接收 location 对象，因此其变量对象中包含了 location 对象的所有属性和方法，而这个变量被添加到了作用域链的前端。 疑问：作用域链：全局执行环境-&gt;buildUrl()-&gt;with(location)with 中定义的变量 url 为什么能够在外部环境 buildUrl 中访问？url是被定义在全局执行环境中的 location 变量对象中吗？ 因为没有块级作用域，变量声明会被添加到当前的执行环境（这里是buildUrl（））中 没有块级作用域1234if (true) &#123; var color = \"blue\";&#125;alert(color); js 中，if 语句中的变量声明会将变量添加到当前的执行环境（这里是全局环境）如果没有用 var 声明，会直接被添加到全局环境。 let 似乎解决了这个问题，本书没有讲到，看完 es6 再来补。 垃圾收集标记清除 当变量进入环境，标记为“进入环境”。 逻辑上讲，永远不能释放进入环境的变量所占用的内存。 当变量离开环境时，则标记“离开环境”。 可以使用任何方式来标记变量。如： 翻转某个特殊的位 “进入环境”变量列表及“离开环境”变量列表 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后再被加上标记的变量将被视为准备删除的变量。最后完成内存清除工作，销毁值并回收内存空间。 引用计数跟踪记录每个值被引用的次数，赋值给变量则该值+1，若变量取得另一个值，则该值-1。 垃圾收集器下次运行时，释放计数 0 的值占用的内存。 循环引用会导致引用次数永远不为 0BOM 和 DOM 中的对象是使用 C++ 以 COM（Component Object Model，组件对象模型）对象的形式实现的，COM 对象的垃圾收集机制就是引用计数策略。解决：手动断开循环引用（赋值为null） 性能问题垃圾收集器是周期运行的，如果为变量分配的内存数量很大，那么回收工作量也相当大，确定时间间隔很重要。 管理内存使用具备垃圾收集机制的语言编写程序，一般不必操心内存管理。但 js 比较特殊，因为分配给 Web 浏览器的可用内存通常比桌面应用少。尽量少用内存页面会有更好的性能。一旦数据不再有用，赋值 null 来解除引用。适用于大多数全局变量和全局对象的属性，局部变量会在离开执行环境时自动解除。解除引用不是自动回收内存，是让值脱离环境，垃圾收集器下次运行的时候将其回收。","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第三章 基本概念","slug":"第3章-基本概念","date":"2020-02-15T15:22:54.000Z","updated":"2020-03-09T17:02:19.445Z","comments":true,"path":"2020/02/15/第3章-基本概念/","link":"","permalink":"http://ziiyan.github.io/2020/02/15/%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"语法ECMAScript 标示符采用驼峰大小写格式 严格模式 strict mode在顶部添加代码 &quot;use strict&quot;;编译指示(pragma)，用于告诉支持的 JavaScript 引擎切换到严格模式。函数体中包含指定函数在严格模式下执行。 变量松散类型：可以用来保存任何类型的数据。每个变量仅仅用于保存值的占位符。 数据类型5 基本数据类型 - Undefined、Null、Boolean、Number、String1 复杂数据类型 - ObjectOobject 本质上是由一组无序的名值对组成的ECMAScript 不支持任何创建自定义类型的机制 typeof 操作符，返回值（均为字符串）未定义：&quot;undefined&quot;布尔值：&quot;boolean&quot;字符串：&quot;string&quot;数值：&quot;number&quot;对象或null：&quot;object&quot;函数：&quot;function&quot;特殊值 null 被认为是一个空的对象引用，因此返回 &quot;object&quot;。safari 5 和 Chrome 7 及之前版本 typeof 正则表达式 会返回 &quot;function&quot;，而其他浏览器返回&quot;object&quot; 从技术角度讲，函数在 ECMAScript 中是对象，而不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 typeof 操作符区分函数和其他对象是有必要的。 Undefined 类型Undefined 类型只有一个值，即 undefined 变量已声明但未初始化（message）：该变量的值为 undefined,typeof 返回&quot;undefined&quot;若变量未声明（age）：只可以执行typeof 操作符，返回&quot;undefined&quot;，其他操作产生错误。 Null 类型Null 类型只有一个值，即 null，表示一个空对象指针，因此 typeof null 返回 &quot;object&quot;。如果定义的变量准备用于保存对象，那么最好初始化为 null，可以直接判断是否已经保存了一个对象的引用。 123if (car != null) &#123; ……&#125; 实际上，undefined 派生自 null，因此： 12alert(null == undefined); // true Boolean 类型ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。调用 转型函数 Boolean() 获得对应 Boolean 值。 数据类型 true false Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值（包括无穷大） 0 和 NaN Object 任何对象 null Undefined N/A undefined N/A：not applicable 的缩写，不适用 Number 类型使用 IEEE754 格式来表示整数和浮点数值（双精度数值）。为了支持各种数值类型，ECMA-262定义了不同的数值字面量格式。 十进制 八进制（0） 十六进制（0x）在进行算数计算时，都会转为十进制数值。浮点数值浮点数值需要的内存空间是整数值的两倍。6 个 0 以上，e表示法：3.125e7、3e-17浮点数值最高精度 17 位小数，但在算数计算时精度远不如整数。（IEEE745 数值的浮点计算通病，不是 ECMAScript 独有） 数值范围Number.MIN_VALUE 5e-324Number.MAX_VALUE 1.7976931348623157e+308Number.POSITIVE_INFINITY 或 Infinity 正无穷Number.NEGATIVE_INFINITY 或 -Infinity 负无穷isFinite()有穷返回 true NaN 任何涉及 NaN 的操作都会返回 NaN NaN 与任何值都不相等，包括自己本身 isNaN() 函数判断变量是否可以转为数值 isNaN(object):首先调用对象的 valueOf() 方法，检查该方法的返回值是否可以转换为数值如果不能，基于这个返回值再调用 toString() 方法，再测试返回值。 数值转换Number() 任何类型parseInt() 字符串parseFloat() 字符串 parseInt 和 parseFloat 从第一个符合条件的字符开始转换，开始后若碰到不符合的字符，抛弃之后的字符。 String 类型 Unicode 字符组成的字符序列。 ECMAScript 中双引号/单引号没有区别。 字符字面量字符字面量，即转义字符，被作为一个字符来解析。 特点 不可改变123var lang = \"Java\";lang = lang + \"Script\";// 首先创建一个能容纳 10 个字符的新字符串，然后填充 “Java” 和 “Script”，最后销毁原来的字符串。（不在原字符串上修改） 转为字符串 toString() 几乎每个值都有这个方法，null 和 undefined 值没有。 通常不需要参数。 调用数值的 toString() 方法时可以传递进制基数作为参数。 不知道是不是 null 或 undefined 的时候可以使用转型函数 String() 如果值有 toString() 方法，调用 如果值是 null，返回 &quot;null&quot; 如果值是 undefined，返回 &quot;undefined&quot; obj + &quot;&quot; 和字符串加在一起 Object 类型 对象是一组数据和功能的集合。 在 ECMAScript 中，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。Object 的每个实例都具有下列属性和方法。 Constructor 构造函数 hasOwnProperty(propertyName) 检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。参数（propertyName）为字符串 isProtorypeOf(object) 检查传入的对象是否是另一个对象的原型 propertyIsEnumerable(propertyName) 检查给定的属性是否能够使用 for-in 语句。参数（propertyName）为字符串 toLocaleString() 根据本地规范进行格式化 toString() valueOf() 通常自动调用 从技术角度讲，ECMA-262 中对象的行为不一定适用于 JS 中的其他对象。如 BOM 和 DOM 中的对象属于宿主对象，宿主对象可能会也可能不会继承 Object。 操作符操作符应用于对象时，通常会调用对象的 valueOf() 和（或）toString() 方法。 语句for-in枚举对象的属性 123for (var propName in window) &#123; document.write(propName);&#125; 属性没有顺序，所以先后顺序因浏览器而异。 label类似 go to 不建议使用 with简化多次编写同一个对象的工作大量使用 with 会导致性能下降，不建议使用 switch比较值时使用全等 === 函数未指定返回值的函数返回 undefined 函数要么始终返回一个值，要么永远都不要返回值。 理解参数 函数体内通过 arguments 对象来访问参数数组。 ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。 详看第四章 —— 传递参数 没有重载不存在函数签名的特性，ECMAScript 函数不能重载定义两个名字相同的函数，会被后面定义的函数覆盖","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第二章 在 HTML 中使用 JavaScript","slug":"第2章-在 HTML 中使用 JavaScript","date":"2020-02-09T15:22:54.000Z","updated":"2020-02-17T14:20:35.314Z","comments":true,"path":"2020/02/09/第2章-在 HTML 中使用 JavaScript/","link":"","permalink":"http://ziiyan.github.io/2020/02/09/%E7%AC%AC2%E7%AB%A0-%E5%9C%A8%20HTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20JavaScript/","excerpt":"","text":"script元素属性 src 可选。包含要执行代码的外部文件。 如果有 src，标签内嵌入的 JavaScript 代码会被忽略可以包含来自外部域的 JavaScript 文件。这点与 img 相同 async 可选。立即下载脚本，但不妨碍页面中其他操作。只对外部脚本文件有效。不能保证按顺序执行。不要修改 DOM 会在load 事件前执行，可能会在 DOMContentLoaded 事件触发之前或之后执行。 defer 可选。延迟到文档完全被解析和显示之后（/html标签后）执行。只对外部脚本文件有效。（嵌入脚本的 defer 属性会被忽略）延迟脚本不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只有一个延迟脚本。 只要不存在 defer 和 async 属性，浏览器都会按照 scrip 元素在页面中出现的先后顺序进行解析 type 可选。language（已废弃）的替代属性；脚本语言的内容类型（MIME 类型）。默认值 text/javascript 不推荐 text/javascript 和 text/ecmascript服务器在传送 JavaScript 文件时使用的 MIME 类型通常是 application/x-javascript非 IE 浏览器中可以使用 application/javascript 和 application/ecmascript charset 可选。表示通过 src 属性指定代码的字符集。大多数浏览器忽略 标签的位置放在 head 中必须先把 js 代码下载、解析和执行完成后才能开始呈现页面内容，此时页面空白。把 js 引用放在 body 中，空白时间会缩短。或者设置 defer 属性，立即下载，延迟（/html标签后）执行。 外部文件的优点 可维护性：集中精力编辑 js 代码 可缓存：如果两个页面使用同一个文件，只需下载一次 适应未来 文档模式!DOCTYPE html noscript元素 浏览器不支持脚本 浏览器支持脚本，但脚本被禁用符合上述条件，元素内容会被显示。","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"第一章 JavaScript 简介","slug":"第1章-JavaScript 简介","date":"2020-01-16T15:22:54.000Z","updated":"2020-02-16T15:32:13.912Z","comments":true,"path":"2020/01/16/第1章-JavaScript 简介/","link":"","permalink":"http://ziiyan.github.io/2020/01/16/%E7%AC%AC1%E7%AB%A0-JavaScript%20%E7%AE%80%E4%BB%8B/","excerpt":"","text":"ECMA-262——定义一种名为 ECMAScript 的新脚本语言的标准浏览器开发商将 ECMAScript 作为各自 JavaScript 实现的基础 JavaScript 包括： 核心： ECMAScript 文档对象模型： DOM 浏览器对象模型： BOM ECMAScript 没有输入和输出定义 ECMA-262 定义了 ECMAScript 基础，在此基础上可以构建更完善的脚本语言 宿主环境提供基本的 ECMAScript 实现，也提供该语言的拓展，以便语言和环境之间对接交互 ECMA-262 标准规定了 语法 类型 语句 关键字 保留字 操作符 对象ECMAScript 就是对实现该标准规定的各个方面内容的语言的描述JavaScript 实现了 ECMAScriptAdobe ActionScript 也实现了 ECMAScript什么是 ECMAScript 兼容 要想成为 ECMAScript 的实现，必须做到： 支持 ECMA-262 描述的所有“类型、值、对象、属性、函数以及程序语法和语义” 支持 Unicode 字符标准 可以进行拓展： 添加 ECMA-262 没有描述的“更多类型、值、对象、属性和函数”。主要指新对象和对象的新属性 支持 ECMA-262 没有定义的“程序和正则表达式语法”。即可以修改和拓展内置的正则表达式语法 为开发人员基于 ECMAScript 开发一门新语言提供了广阔的空间和极大的灵活性 DOMDOM（Document Object Model）是针对 XML 但经过拓展用于 HTML 的 API（Application Programming Interface） W3C 制定了 DOM 标准 DOM 不止针对 JavaScript，很多别的语言也实现了 DOM DOM 包括 DOM 核心和 DOM HTML DOM 核心规定如何映射基于 XML 的文档结构 DOM HTML 模块则在 DOM 核心 的基础上添加了针对 HTML 的对象和方法 除了 DOM 核心和 DOMHTML 接口之外，另外几种语言发布了只针对自己的 DOM 标准。以下语言都是基于 XML 的，每种语言的 DOM 标准都添加了与特定语言相关的新方法和新接口： SVG(Scalable Vector Graphic) MathML（Mathematical Markup Language） SMIL（Synchronized Multimedia Integration Language）BOM开发人员使用 BOM（Browser Object Model）控制浏览器显示的页面以外的部分BOM 作为 JavaScript 实现的一部分却没有相关的标准。H5 致力于把很多 BOM 功能写入正式规范。根本上讲，BOM 只处理浏览器窗口和框架；但习惯上把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分。","categories":[],"tags":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]}],"categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://ziiyan.github.io/tags/CSS/"},{"name":"面试","slug":"面试","permalink":"http://ziiyan.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://ziiyan.github.io/tags/JavaScript/"},{"name":"网络","slug":"网络","permalink":"http://ziiyan.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"浏览器","slug":"浏览器","permalink":"http://ziiyan.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"性能","slug":"性能","permalink":"http://ziiyan.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"Webpack","slug":"Webpack","permalink":"http://ziiyan.github.io/tags/Webpack/"},{"name":"翻译","slug":"翻译","permalink":"http://ziiyan.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"精读","slug":"精读","permalink":"http://ziiyan.github.io/tags/%E7%B2%BE%E8%AF%BB/"},{"name":"刷题","slug":"刷题","permalink":"http://ziiyan.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"HTML","slug":"HTML","permalink":"http://ziiyan.github.io/tags/HTML/"},{"name":"其它","slug":"其它","permalink":"http://ziiyan.github.io/tags/%E5%85%B6%E5%AE%83/"},{"name":"Vue","slug":"Vue","permalink":"http://ziiyan.github.io/tags/Vue/"},{"name":"PWA","slug":"PWA","permalink":"http://ziiyan.github.io/tags/PWA/"},{"name":"ECMAScript 6 入门","slug":"ECMAScript-6-入门","permalink":"http://ziiyan.github.io/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/"},{"name":"工作","slug":"工作","permalink":"http://ziiyan.github.io/tags/%E5%B7%A5%E4%BD%9C/"},{"name":"Java","slug":"Java","permalink":"http://ziiyan.github.io/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://ziiyan.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"React","slug":"React","permalink":"http://ziiyan.github.io/tags/React/"},{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://ziiyan.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]}