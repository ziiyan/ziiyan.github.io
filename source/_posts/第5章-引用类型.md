---
title: 第五章 引用类型
date: 2020-02-22 22:05:54
tags: JavaScript高级程序设计
---
* **引用类型**是一种数据结构，用于将数据和功能组织在一起。
* 引用类型的值（对象）是引用类型的一个实例。
* <u>引用类型与类看起来相似，但并不相同。</u>
* ECMAScript 从技术上讲是一门面向对象的语言，但不具备传统的面向对象语言所支持的类和接口等基本结构。
* 引用类型也被称为**对象定义**，描述一类对象所具有的属性和方法。
* ECMAScript 提供类很多原生引用类型（例如 Object）

## Object 类型
大多数对象都是 Object 类型的实例
###### 创建实例
* new 操作符
```js
var person = new Object();
person.name = "Nicholas";
person.age = 29;
```
* 对象字面量
    * 对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。
```js
var person = {
    name: "Nicholas",
    age: 29
};
```
```js
// 定义只包含默认属性和方法的对象
var person = {};
// 或
var person = new Object();
```
> 通过对象字面量定义对象时，实际上不会调用 Object 构造函数
> 疑问：对象字面量是怎么定义对象的？

## Array 类型
和其他语言的区别：每一项可以保存任何类型的数据，互相之间不影响

###### 创建实例
* new
```js
var colors = new Array();
var colors = new Array(20); // length = 20
var colors = new Array("Grey"); // length = 1
```
* 省略 new
```js
var colors = Array(3); // length = 3
```
* 数组字面量
```js
var names = [];
var colors = ["red", "blue", "green"];
```
> 数组字面量表示法时不会调用 Array 构造函数
---
* length 可修改，会移除超出的项
* 当把一个值放在超出当前数组大小的位置上时，会重新计算长度，长度值为最后一项的索引 + 1
```js
var colors = ["red", "blue", "green"];
// ["red", "blue", "green"]
colors.length = 2;
// ["red", "blue"]
colors.length = 3;
// ["red", "blue", empty]
console.log(colors[3]);
// ["red", "blue", empty, "green"] length = 4
```
### 检测数组
`value instanceof Array` 假定只有一个全局执行环境，如果从一个框架向另一个框架传入数组，就具有不同的构造函数
`Array.isArray()`
### 转换方法
* `Array.toString()`
* `Array.toLocaleString()`
* `Array.valueOf()`
### 栈/队列方法
* `Array.push` 末尾添加
* `Array.pop` 取最后一项并移除
* `Array.shift` 取第一项并移除
* `Array.unshift` 头部添加
### 重排序
* `Array.reverse()` 反转顺序
* `Array.sort()` 先转 toString()，字符串升序
    * sort 接收比较函数
        * params1 -> params2 ===> -1
        * params2 -> params1 ===> 1
### 操作方法
* `Array.concat`
* `Array.slice(a, b)` [a, b)
    * 负数则从末尾开始数
* `Array.splice(a, b, ...c)`
    * a 位置
    * b 要删除的项数
    * c 插入的内容（若干）
    * return 被删除的内容

### 位置方法
查找数组内容，`===`，返回下标
* `Array.indexOf()`
* `Array.lastIndexOf()`
### 迭代方法
* 两个参数
    * 要在每一项上运行的函数
        * 三个参数
            * 数组项的值
            * 该项再数组中的位置
            * 数组对象本身
    * （可选的）运行该函数的作用域对象
        * 影响this的值
* `Array.every()` 每一项都返回 true，则返回 true
* `Array.some()` 任一项返回 true，则返回 true
* `Array.filter()` 返回该函数返回 true 的项组成的数组
* `Array.map()` 返回每次函数调用的结果组成的数组
* `Array.forEach()` 没有返回值 

以上方法都不回修改数组中包含的值
### 归并方法
* `Array.reduce()`
* `Array.reduceRight()`

* 两个参数
    * 每一项上调用的函数
        * 四个参数
            * 前一个值
            * 当前值
            * 项的索引
            * 数组对象
    * （可选的）作为归并基础的初始值
* 返回值作为第一个参数传给下一项
* 第一次迭代发生在第二项上，第一个参数是数组的第一项，第二个参数是数组的第二项

## Date 类型
* `Date.parse()` 
    * params: 表示日期字符串，格式因地区而异
    * return: 毫秒
* `Date.UTC()`
    * params: 年份、月份（0开始）、天数、小时、分钟、秒、毫秒
    * return: 毫秒
* `Date.now()`
### 继承的方法
* `Date.toLocaleString()` 根据当地时区
* `Date.toString()` 带有时区信息
* `Date.valueOf()` 毫秒
### 日期格式化方法
* `Date.toDateString()`
* `Date.toTimeString()`
* `Date.toLocaleDateString()`
* `Date.toLocaleTimeString()`
* `Date.toUTCString()`
* `Date.toLocaleString()`

因浏览器而异
## RegExp 类型
```js
var expression = / pattern / flags ;
```

* pattern
    * ( [ { \ ^ $ | ) ? * + . ] } 需要转义
* flags
    * g 全局，默认匹配第一个停止
    * i 不区分大小写
    * m 多行模式
### RegExp 实例属性
* `global` 
* `ignoreCase` 
* `lastIndex` 
* `multiline` 
* `source` 

### RegExp 实例方法
* `exec` 
* `test` 
* `toString` 
* `toLocaleString` 
* `valueOf` 

### 构造函数属性
其他语言中被看成是**静态属性**

| 长属性名 | 短属性名 | 说明 |
| --- | --- | --- |
| input | $_ | 最近一次要匹配的字符串 |
| lastMatch | $& | 最近一次的匹配项 |
| lastParen | $+ | 最近一次匹配的捕获组 |
| leftContext | $\` | input 字符串中 lastMatch 之前的文本 |
| multiline | $* | 布尔值，是否所有表达式都使用多行模式 |
| rightContext | $' | input 字符串中 lastMatch 之后的文本 |

## Function 类型
* 每个函数都是 Function 类型的实例，具有属性和方法。
* 函数名是一个只想函数对象的指针，不会与某个函数绑定。
##### 创建实例
* 函数声明
```js
function sum (num1, num2) {
    return num1 + num2;
}
```
* 函数表达式
```js
var sum = function(num1, num2) {
    return num1 + num2;
};
```
> 区别：
> 解析器会先读取函数声明，在执行任何代码之前可用（函数声明提升）
> 函数表达式要等解析器执行到它所在的代码行才会被解释执行

* Function 构造函数（不推荐）
```js
var sum = new Function("num1", "num2", "return num1 + num2");
```
### 没有重载
声明两个同名函数，后面的函数覆盖前面的，结合 “函数是对象，函数名是指针” 很好理解。
### 作为值的函数
* 函数名本身是变量，可以作为值来使用
* 可以作为参数，也可以作为返回值

### 函数的内部属性
* `arguments` 类数组对象
    * `callee` 属性，该属性是一个指针，指向拥有这个 arguments 对象的函数
* `this` 引用的是执行函数的环境对象
```js
sindow.color = "red";
var o = { color: "blue" };

function sayColor() {
    alert(this.color);
}

sayColor(); // "red"

o.sayColor = sayColor;
o.sayColor();   // "blue"
```
* `caller` 调用当前函数的函数的引用，全局中调用当前函数则 null
```js
function outer() {
    inner();
}
function inner() {
    console.log(inner.caller);
    // inner.callr 指向 outer()
    // 等价于 arguments.callee.caller
}
outer();
```
### 函数属性和方法
* `length` 函数希望接收的命名参数的个数
* `prototype`
    * 对引用类型而言，prototype 是保存它们所有实例方法的真正所在。换句话说，toString() 和 valueOf() 等方法都是保存在 prototype 名下，只是通过各自对象的实例访问。
    * 不可枚举，for-in 无法发现。

每个函数都包含两个非继承而来的方法，都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。
* `apply` 
    * 两个参数
        * 在其中运行函数的作用域
        * 参数数组
* `call` 
    * 1 + n 个参数
        * 在其中运行函数的作用域
        * 一个一个地传入参数
        
* `bind` 创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值

## 基本包装类型
为了便于操作基本类型值，ECMAScript 提供 3 个特殊的引用类型：`Boolean`、`Number`、`String`
```js
var s1 = "smoe.txt";
var s2 = s1.substring(2);
```
> 基本类型不是对象，理论上不应该有方法。
> 当第二行代码访问 s1 时，访问过程处于一种读取模式，从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台自动完成：
> (1) 创建 String 类型的一个实例
> (2) 在实例上调用指定的方法
> (3) 销毁这个实例

* 引用类型与基本包装类型的主要区别是对象的生存期
    * 引用类型的实例在执行流离开当前作用域之前一直保存在内存中
    * 基本包装类型只存在于一行代码的执行瞬间
* 可以显示的创建基本包装类型的对象，但会分不清自己在处理基本类型还是引用类型的值
* new 调用基本包装类型的构造函数，和转型函数是不一样的
```js
var value = "25";

var number = Number(value); // 转型函数
console.log(typeof number); // "number"

var obj = new Number(value); // 构造函数
console.log(typeof obj);     // “object"
```

### Boolean 类型
布尔表达式中，所有的对象都会转为 true
```js
var falseObject = new Boolean(false);
var result = falseObject && true;
alert(result); // true
```
产生误解，建议不要使用

### Number 类型
* `toString(n)` n 进制
* `toFixed(n)` 四舍五入 n 位小数
* `toExponential(n)` n 位数表示一个数字

#### 字符方法
* `charAt`
* `charCodeAt`
* `方括号表示法[]下标读取字符`

#### 字符串操作方法
* `concat` 拼接字符串，常用`+`
* `slice`
* `substr`
* `substring`

#### 字符串位置方法
* `indexOf`
* `lastIndexOf`

#### trim() 方法
创建一个字符串的副本，删除前置以及后缀的所有空格，然后返回结果

#### 字符串大小写转换
* `toLowerCase`
* `toLocaleLowerCase`
* `toUpperCase`
* `toLocaleUpperCase`

#### 字符串的模式匹配方法
* `match`
    * params:正则表达式或 RegExp 对象
    * 本质调用 RegExp 的 exec
* `search`
    * params:正则表达式或 RegExp 对象
    * return: 下标，找不到 -1
* `replace` 
    * 两个参数，用第二个参数替换第一个
    * 第一个参数可以是正则
    * 第二个参数可以是函数
* `split` 基于一个制定的分隔符，将一个字符串分割成多个子字符串

#### localeCompare() 方法
比较两个字符串，各地区实现不同
#### fromCharCode() 方法
接收一个或多个字符编码，然后转换成一个字符串

## 单体内置对象
ECMA-262对**单体内置对象**的定义：<u>由 ECMAScript 实现提供的，不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。</u>

前面已经介绍了大多数内置对象，如 Object、Array、String
### Global 对象
* 不属于任何其他对象的属性和方法，最终都是 Global 对象的属性和方法
* 事实上，没有全局变量或全局函数。所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。如
    * isNan()、isFinite()、parseint()
    * encodeURI() 用于整个 URI
      encodeURIEomponent() 用于 URI 中的一段
      decodeURI()
      decodeURIEomponent()
    * eval() 像一个完整的 ECMAScript 解析器
        * params: 要执行的 ECMAScript 字符串
    * Global 对象属性
        * undefined、NaN、Infinity 等
        * Object、Function 等
    * window 对象
        * Web 浏览器中，Global 对象是 window 对象的一部分

### Math 对象
* Math 对象的属性
    * Math.E
    * Math.LN10
    * Math.LN2
    * Math.LOG2E
    * Math.LOG10
    * Math.PI
    * Math.SQRT1_2
    * Math.SQRT2
* min()、max()
* 舍入方法
    * Math.ceil() 向上舍入
    * Math.floor() 向下舍入
    * Math.round() 四舍五入
* random() [0, 1) 随机数
* 其他方法
    * Math.abs(num)
    * Math.exp(num)
    * Math.log(num)
    * Math.pow(num, power)
    * Math.sqrt(num)
    * Math.acos(x)
    * ……