---
title: 面试准备：刷面经
date: 2020-07-07 20:38:41
tags: 面试
---

最近有点看不进去书，到牛客找面经上面对面经复习

主要是为了用自己的语言组织一下，怕面试了答不上来

## HTML

* **简述一下你对 HTML 语义化的理解**
	* 用正确的标签做正确的事
	* 便于浏览器及搜索引擎的解析，利于 SEO
	* 可读性
		* 视觉障碍的人可能会使用屏幕阅读器，语义化的文档对屏幕阅读器更友好
		* 开发人员看代码时也更容易理解结构，利于维护

## JS

* this 作用域
	* 指向运行时所在的作用域，一般是调用函数的对象
	* 如果是全局就是 Window
	* 如果是该函数是一个构造函数，this指针指向一个新的对象
	* 使用 call、apply、bind 可以改变 this 的指向
		* call、apply 区别：
			* 第一个参数都是 this 需要指向的对象
			* call 参数一个个传
			* apply 传数组
		* bind 只是绑定一下，不执行，要执行的话需要再加括号
		* 箭头函数没有自己的 this，根据作用域链去找
			* 如果箭头函数使用 call、apply、bind，第一个参数会被忽略
* 什么样的 const 值可以更改
	* const 只规定了变量的内容不被修改
	* 如果是基本数据类型（string、number、bool、undefined、null、symbol）就不能改，因为直接存的数据
	* 如果是复杂数据类型（Object）就可以改，因为保存的是变量的地址，地址再指向真实的数据，改变真实数据的情况下，地址不会变
* 事件
	* 事件捕获
	* 处于目标阶段
	* 事件冒泡
* Promise
* 函数的柯里化
	* 把接受多个参数的函数变换成接受一个参数的函数，并且返回接受余下参数的新函数
* js 原型链
* 深浅复制
* 闭包
	* 能够读取其他函数变量的函数
* new 一个对象的过程
	* 创建一个空对象
	* 将对象的原型指向构造函数
	* 执行构造函数中的代码
	* 返回新对象

```js
let obj = {}
obj.__proto__ = Base.prototype;
Base.call(obj);
```



## CSS

* 垂直居中

* 怎么用 css 画一个三角形

* 相对定位

* 绝对定位

* flex-box 怎么用

* 圣杯布局

	* ```html
		<body>
		  <div class="container">
		    <div class="main">main</div>
		    <div class="left">left</div>
		    <div class="right">right</div>
		  </div>
		</body>
		
		<style>
		  .left,
		  .main,
		  .right {
		    position: relative;
		    min-height: 200px;
		    float: left;
		  }
		  .left {
		    width: 200px;
		    background: lightpink;
		    margin-left: -100%;
		    left: -200px;
		  }
		  .right {
		    width: 300px;
		    background-color: lightgreen;
		    margin-left: -300px;
		    right: -300px;
		  }
		  .main {
		    width: 100%;
		    background-color: lightblue;
		  }
		  .container {
		    padding: 0 300px 0 200px;
		  }
		</style>
		```

* 双飞翼布局

	* ```html
		<body>
		  <div class="container">
		    <div class="main">
		      <div class="inner">content</div>
		    </div>
		    <div class="left">left</div>
		    <div class="right">right</div>
		  </div>
		</body>
		
		<style>
		  .left,
		  .main,
		  .right {
		    min-height: 200px;
		    float: left;
		  }
		  .left {
		    width: 200px;
		    background: lightpink;
		    margin-left: -100%;
		  }
		  .right {
		    width: 300px;
		    background: lightgreen;
		    margin-left: -300px;
		  }
		  .main {
		    width: 100%;
		    background: lightblue;
		  }
		  .inner {
		    background: salmon;
		    min-height: 200px;
		    margin: 0 300px 0 200px;
		  }
		</style>
		```

## Vue

* 双向绑定原理
* vue-router 实现方式
* vue 和 React 的区别
* mvvm 的设计模式
	* ViewModel 分离视图和模型，ViewModel 只关心数据和业务的处理
* 父子组件的通信机制
* 组件化思想
* 页面懒加载向写法
* 生命周期

## 数据结构

* 队列和栈的区别？用栈来实现队列
	* 队列是先进先出，类似于排队；栈的话是先进后出，出入口是同一个，先进的元素会被压在下面
	* 可以用两个栈，在出栈的时候把元素都先放到另外一个栈中，这样顺序就对了

## 网络

* TCP、UDP区别？TCP如何做到双工可靠传输？TCP阻塞控制是什么？
	* TCP 是面向连接的，传输比较可靠；UDP 是不可靠传输，比较适用于实时应用
* 302 和 304 的区别
* http code 的含义
* HTTP 1.0/2.0 HTTPS
	* [HTTP的发展](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP)
	* [如何优雅的谈论HTTP](https://www.jianshu.com/p/52d86558ca57)

## 浏览器

* 跨域
* jsonp 原理
* 用户输入网址，看到页面的流程
* 存储

## 项目

* 项目难点

	> 之前项目有一个抽屉组件，最下面有提交按钮，就是说抽屉组件内的信息编辑完成后一次性提交给后台。
	>
	> 抽屉组件里有一个成员列表，是后端分页的，一次只能拿到10条数据，同时列表每行都有移除按钮，就是移除单个成员。根据刚才说的，在点击抽屉组件的提交按钮之前，这个移除操作还没有提交给后台。
	>
	> 同时列表旁边有一个添加成员的按钮，点击之后会出现一个弹窗，可以进行成员的搜索，就是根据搜索框的输入进行实时的get请求，当然这里用防抖（debounce）做了一点点优化。这里的搜索结果是匹配的成员列表，同时需要展示该成员是否已加入当前组织，如果已加入当然就不能选择了，需要禁止点击。这里选择完成后，点击弹窗的确定按钮，需要把刚刚选择的人添加到上一层抽屉组件的成员列表中。当然这个添加操作和刚刚的移除也是一样的，还没有提交给后台。
	>
	> 数据流是这样的，打开抽屉组件的时候，会请求成员列表第一页的数据，添加和移除成员的操作都是前端临时的，没有同步到后端，但在添加成员的弹窗里，搜索展示的成员状态是和后端实时同步的。
	>
	> 这种前后的数据不统一的场景会带来很多问题
	>
	> 1. 列表分页的问题。比如我有20条数据，第一页1-10，第二页11-20，我在第一页移除了编号1的数据，此时前端第一页2-11，第二页12-20， 后端数据不变，前后的数据已经不统一了，具体应该怎么展示就是一个大问题。这里我维护一个已删除列表，把刚刚那个编号1记录下来，第一页就只展示9条数据，第二页还是10条，当用户从第二页切换回第一页的时候，再把编号1筛选出来，不展示在界面上。当然这种情况下，每页的长度就不一样了，更极端的把某一页的数据全移除的话，就翻车了
	> 2. 点击移除后，弹窗里的搜索结果还是已加入。这里和刚才思路也是一样，获取到搜索结果之后再筛选，如果是在已删除列表里的，修改一下是否存在的字段就行。
	> 3. 弹窗选择确定后，需要添加新选择的成员到列表里，这里维护一个已添加列表，临时拼接在当前页后面，当然这也会导致列表长度不一的情况。这边还要同时比较一下已删除列表，如果某个成员同时存在移除和添加里，说明它状态和后端是同步的，可以同时从两个列表中移除了，不需要特判。这边组件间传值用的是 props 和 emit。
	>
	> 最后抽屉提交的时候只要提交已删除列表和已添加列表就行了。
	>
	> 我觉得这种处理方式还是有非常多 bug ，考虑到业务场景，和产品商量之后还算可以接受，就先这样做了。

* 怎么优化项目

## 手撕代码

* 提取url中search部分参数，https://www.aliexpress.com/?a=1&b=2

```js
function fn (str) {
  let arr = str.split('?')[1];
  let params = arr.split('&');
  let ans = []
  for (item of params) {
    let param = item.split('=');
    ans.push({key: param[0], value: param[1]})
  }
  return ans;
}
```

* 写一个类Person， 拥有属性age和name，拥有方法say(something)， 再写一个类Superman，继承Person，拥有自己的属性power，拥有自己的方法fly(height)

```js
class Person {
  constructor(age, name) {
    this.age = age;
    this.name = name;
  }
  say(something) {
    console.log(something)
  }
}
class Superman extends Person {
  constructor(power) {
    super();
    this.power = power;
  }
  fly(height) {
    console.log(`fly to ${height}`)
  }
}
```

* Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

```js
function moveDup(params) {
  for (let i = 1; i < params.length; i++) {
    if (params[i] === params[i-1]) {
      params.splice(i, 1)
    }
  }
  return params
}
console.log(moveDup([1, 2, 3, 3, 4, 5, 5]))
```

* quickSort

```js
function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left >= right) {
    return
  }
  const priv = arr[right];
  let i = left;
  let j = right;
  while (i < j) {
    while (i < j && arr[i] < priv) {
      i++;
    }
    arr[j] = arr[i];
    while (j > i && arr[j] > priv) {
      j--;
    }
    arr[i] = arr[j];
  }
  arr[j] = priv;
  quickSort(arr, left, j-1);
  quickSort(arr, j+1, right);
  return arr;
}
```

* debounce

```js
function debounce(fn, ms) {
  let timer = null;
  return function () {
    clearTimeout(timer);
    timer = setTimeout(()=>{
      fn.apply(this, arguments);
    }, ms);
  }
}
```

* throttle

```js
function throttle(fn, ms) {
  let flag = true;
  return function() {
    if (!flag) return;
    flag = false;
    setTimeout(()=>{
      fn.apply(this, arguments);
      flag = true
    }, ms)
  }
}
```

