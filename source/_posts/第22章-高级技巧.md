---
title: 第二十二章 高级技巧
date: 2020-03-14 17:27:55
tags: JavaScript高级程序设计
---

# 第二十二章 高级技巧

## 高级函数

### 安全的类型检测

`Object.toString()` 方法返回一个 `[object NativeConstructorName]` 格式的字符串。每个类内部都有一个 `[[Class]]` 属性，指定了上述字符串中的构造函数名。

```js
Object.prototype.toString.call(value);
// "[object Array]"
```

开发人员定义的构造函数返回 `object Object`。



### 作用域安全的构造函数

* 当 new 调用构造函数时，构造函数内用到的 this 对象会指向新创建的对象实例。

* 如果不用 new，this 会映射到全局对象 widow 上，导致属性被添加到全局。
* 解决：构造函数内部检查 this 对象是否正确

```js
function Person(name, age, job) {
  if (this instanceof Person) {
    this.name = name;
    this.age = age;
    this.job = job;
  } else {
    return new Person(name, age, job);
  }
}
```



### 惰性载入函数

函数执行的分支只执行一次

* 函数被调用时处理
	* 第一次调用时用合适函数覆盖原来的函数
		* 例如检查浏览器是否支持某功能，执行一次就行
	* 在声明时就指定适当函数
		* 加载时损失性能，执行时不会



### 函数绑定 bind()

创建一个函数，可以在特定的 this 环境中以指定参数调用另一个函数。

```js
var handler = {
  message: "Event handled",
  handleClick: function (event) {
    alert(this.message);
  }
};

var btn = document.getElementById("my-btn");
EventUtil.addHandler(btn, "click", handler.handleClick);
// 由于没有保存 handler.handleClick() 的执行环境
// this 指向 DOM 按钮而非 handler
// 本来应该显示 “Event handled”，会显示 undefined

// 使用闭包解决：
EventUtil.addHandler(btn, "click", function(event) {
  handler.handleClick(event);
})

// bind() 可以将函数绑定到指定环境的函数
function bind(fn, context) {
  return function() {
    return fn.apply(context, arguments);
  }
}
EventUtil.addHandler(btn, "click", bind(handler,handleClick, handler));
```



### 函数柯里化

* 用于创建已经设置好了一个或多个参数的函数
* 基本方法和函数绑定一样：使用一个闭包返回一个函数
* 区别在于：函数被调用时，返回的函数还需要设置一些传入的参数

```js
function curry(fn, context) {
  var args = Array.prototype.slice.call(arguments, 2);
  return function() {
    var innerArgs = Array.prototype.slice.all(arguments);
    var finalArgs = args.concat(innerArgs);
    return fn.apply(context, finalArgs);
  };
}
```



## 防篡改对象

一旦把对象定义为防篡改，就无法撤销了

* `Object.preventExtensions()` 不可扩展对象
	* 无法添加新属性和方法
	* 已有成员可以修改/删除
* `Object.seal()` 密封对象
	* 不可扩展
	* 不能删除
	* 可以修改
* `Object.freeze()` 冻结对象
	* 不可扩展
	* 密封
	* `[[Writable]]` 设置为 false，若定义 `[[Set]]` 属性可写



## 高级定时器

* 定时器不是线程

* Javascript 运行于单线程环境中
* 定时器是计划代码在未来的某个时间执行，执行时机不能保证
* 因为在页面的生命周期中，不同时间可能有其他代码在控制 Javascript 进程
* 在页面下载完后的代码运行、事件处理程序、Ajax 回调函数都必须使用同样的线程来执行
* 浏览器负责进行排序，指派某段代码在某个时间点运行的优先级
* 除了主 JavaScript 执行进程外，还有一个需要在进程下一次空闲时执行的代码队列
* 没有任何代码是立即执行的，但一旦进程空闲则尽快执行
* 定时器时间过去时，将代码插入队列末尾
	* 若队列不空，则仍需等待
	* 若主 JavaScript 执行进程正在执行，也仍需等待

### 重复的定时器

当使用 `setInterval()` 仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中

* 某些间隔会被跳过
* 多个定时器的代码执行之间的间隔可能会比预期小

解决：链式 `setTimeout()`

```js
setTimeout(function(){
  // ……
  setTimeout(arguments.callee, interval);
}, interval);
```

### Yielding Processes

如果代码运行超过特定的时间或者特定语句数量就不会让它继续执行

展开循环前，思考：

* 该处理是否必须同步完成？
* 数据是否必须按顺序完成？

如果答案都为否，可以使用**数组分块**技术

* 为要处理的项目创建一个队列，使用定时器取出下一个要处理的项目，再设置另一个定时器

```js
function chunk(array, process, context) {
  setTimeout(function() {
    var item = array.shift();
    process.call(context, item);
    if (array.length > 0) {
      setTimeout(arguments.callee, 100);
    }
  }, 100);
}
```



### 函数节流 throttle

* DOM 操作比非 DOM 交互需要更多的内存和 CPU 时间

* 连续尝试进行过多的 DOM 相关操作可能会导致浏览器挂起，甚至崩溃。例如 onresize 调整浏览器大小
* 防止连续触发，使用定时器进行**节流**
* 基本思想
	* 某些代码不可以在没有间断的情况连续重复执行
	* 第一次调用函数时，创建一个定时器，在指定的时间间隔之后运行代码
	* 第二次调用函数时，清除前一次的定时器，并设置另一个
		* 如果前一次的定时器已经执行，这个操作无意义
		* 如果前一次的定时器还未执行，就是替换新定时器
	* 目的是只有在执行函数的请求停止了一段时间之后才执行

```js
var processor = {
  timeoutId: null,
  // 实际进行处理的方法
  performPorcessing: function () {
    // ……
  },
  // 初始处理调用的方法
  process: function () {
    clearTimeout(this.timeoutId);
    var that = this;
    this.timeoutId = setTimeout(function() {
      that.performProcessing();
    }, 100);
  }
};
// 尝试开始执行
processor.process();
```

简化的 `throttle() `函数

```js
function throttle(method, context) {
  clearTimeout(method.tId);
  method.tId = setTimeout(function() {
    method.call(context);
  }, 100);
}
```

## 自定义事件

* 事件是 Javascript 与浏览器交互的主要途径

* 事件是观察者模式，一种创建松散耦合代码的技术

* 观察者模式有两类对象组成
	* 主体
		* 发布事件
		* 不知道观察者的存在，独立运行
	* 观察者
		* 通过订阅事件来观察主体
		* 知道主体并能注册事件的回调函数（事件处理程序）



## 拖放

* 创建一个绝对定位的元素，使其可以用鼠标移动
