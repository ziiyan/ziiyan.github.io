---
title: 第二十二章 高级技巧 & 第二十三章 离线应用与客户端存储
date: 2020-03-14 17:27:55
tags: JavaScript高级程序设计
---

# 第二十二章 高级技巧

## 高级函数

### 安全的类型检测

`Object.toString()` 方法返回一个 `[object NativeConstructorName]` 格式的字符串。每个类内部都有一个 `[[Class]]` 属性，指定了上述字符串中的构造函数名。

```js
Object.prototype.toString.call(value);
// "[object Array]"
```

开发人员定义的构造函数返回 `object Object`。



### 作用域安全的构造函数

* 当 new 调用构造函数时，构造函数内用到的 this 对象会指向新创建的对象实例。

* 如果不用 new，this 会映射到全局对象 widow 上，导致属性被添加到全局。
* 解决：构造函数内部检查 this 对象是否正确

```js
function Person(name, age, job) {
  if (this instanceof Person) {
    this.name = name;
    this.age = age;
    this.job = job;
  } else {
    return new Person(name, age, job);
  }
}
```



### 惰性载入函数

函数执行的分支只执行一次

* 函数被调用时处理
	* 第一次调用时用合适函数覆盖原来的函数
		* 例如检查浏览器是否支持某功能，执行一次就行
	* 在声明时就指定适当函数
		* 加载时损失性能，执行时不会



### 函数绑定 bind()

创建一个函数，可以在特定的 this 环境中以指定参数调用另一个函数。

```js
var handler = {
  message: "Event handled",
  handleClick: function (event) {
    alert(this.message);
  }
};

var btn = document.getElementById("my-btn");
EventUtil.addHandler(btn, "click", handler.handleClick);
// 由于没有保存 handler.handleClick() 的执行环境
// this 指向 DOM 按钮而非 handler
// 本来应该显示 “Event handled”，会显示 undefined

// 使用闭包解决：
EventUtil.addHandler(btn, "click", function(event) {
  handler.handleClick(event);
})

// bind() 可以将函数绑定到指定环境的函数
function bind(fn, context) {
  return function() {
    return fn.apply(context, arguments);
  }
}
EventUtil.addHandler(btn, "click", bind(handler,handleClick, handler));
```



### 函数柯里化

* 用于创建已经设置好了一个或多个参数的函数
* 基本方法和函数绑定一样：使用一个闭包返回一个函数
* 区别在于：函数被调用时，返回的函数还需要设置一些传入的参数

```js
function curry(fn, context) {
  var args = Array.prototype.slice.call(arguments, 2);
  return function() {
    var innerArgs = Array.prototype.slice.all(arguments);
    var finalArgs = args.concat(innerArgs);
    return fn.apply(context, finalArgs);
  };
}
```



## 防篡改对象

一旦把对象定义为防篡改，就无法撤销了

* `Object.preventExtensions()` 不可扩展对象
	* 无法添加新属性和方法
	* 已有成员可以修改/删除
* `Object.seal()` 密封对象
	* 不可扩展
	* 不能删除
	* 可以修改
* `Object.freeze()` 冻结对象
	* 不可扩展
	* 密封
	* `[[Writable]]` 设置为 false，若定义 `[[Set]]` 属性可写



## 高级定时器

* 定时器不是线程

* Javascript 运行于单线程环境中
* 定时器是计划代码在未来的某个时间执行，执行时机不能保证
* 因为在页面的生命周期中，不同时间可能有其他代码在控制 Javascript 进程
* 在页面下载完后的代码运行、事件处理程序、Ajax 回调函数都必须使用同样的线程来执行
* 浏览器负责进行排序，指派某段代码在某个时间点运行的优先级
* 除了主 JavaScript 执行进程外，还有一个需要在进程下一次空闲时执行的代码队列
* 没有任何代码是立即执行的，但一旦进程空闲则尽快执行
* 定时器时间过去时，将代码插入队列末尾
	* 若队列不空，则仍需等待
	* 若主 JavaScript 执行进程正在执行，也仍需等待

### 重复的定时器

当使用 `setInterval()` 仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中

* 某些间隔会被跳过
* 多个定时器的代码执行之间的间隔可能会比预期小

解决：链式 `setTimeout()`

```js
setTimeout(function(){
  // ……
  setTimeout(arguments.callee, interval);
}, interval);
```

### Yielding Processes

如果代码运行超过特定的时间或者特定语句数量就不会让它继续执行

展开循环前，思考：

* 该处理是否必须同步完成？
* 数据是否必须按顺序完成？

如果答案都为否，可以使用**数组分块**技术

* 为要处理的项目创建一个队列，使用定时器取出下一个要处理的项目，再设置另一个定时器

```js
function chunk(array, process, context) {
  setTimeout(function() {
    var item = array.shift();
    process.call(context, item);
    if (array.length > 0) {
      setTimeout(arguments.callee, 100);
    }
  }, 100);
}
```



### 函数节流 throttle

* DOM 操作比非 DOM 交互需要更多的内存和 CPU 时间

* 连续尝试进行过多的 DOM 相关操作可能会导致浏览器挂起，甚至崩溃。例如 onresize 调整浏览器大小
* 防止连续触发，使用定时器进行**节流**
* 基本思想
	* 某些代码不可以在没有间断的情况连续重复执行
	* 第一次调用函数时，创建一个定时器，在指定的时间间隔之后运行代码
	* 第二次调用函数时，清除前一次的定时器，并设置另一个
		* 如果前一次的定时器已经执行，这个操作无意义
		* 如果前一次的定时器还未执行，就是替换新定时器
	* 目的是只有在执行函数的请求停止了一段时间之后才执行

```js
var processor = {
  timeoutId: null,
  // 实际进行处理的方法
  performPorcessing: function () {
    // ……
  },
  // 初始处理调用的方法
  process: function () {
    clearTimeout(this.timeoutId);
    var that = this;
    this.timeoutId = setTimeout(function() {
      that.performProcessing();
    }, 100);
  }
};
// 尝试开始执行
processor.process();
```

简化的 `throttle() `函数

```js
function throttle(method, context) {
  clearTimeout(method.tId);
  method.tId = setTimeout(function() {
    method.call(context);
  }, 100);
}
```

## 自定义事件

* 事件是 Javascript 与浏览器交互的主要途径

* 事件是观察者模式，一种创建松散耦合代码的技术

* 观察者模式有两类对象组成
	* 主体
		* 发布事件
		* 不知道观察者的存在，独立运行
	* 观察者
		* 通过订阅事件来观察主体
		* 知道主体并能注册事件的回调函数（事件处理程序）



## 拖放

* 创建一个绝对定位的元素，使其可以用鼠标移动


# 第二十三章 离线应用与客户端存储

离线 Web 应用：设备不能上网的情况下仍然可以运行的应用



## 离线检测

* `navigator.onLine` 属性



* 应用缓存



## 应用缓存

* appache 从浏览器的缓存中分出一块缓存区
	* 使用一个**描述文件(manifest file)**，列出要下载和缓存的资源
	* 将描述文件与页面关联起来，可以在 `html` 中的 `manifest` 属性指定文件路径
* applicationCache 对象



## 数据存储

### HTTP Cookie

* 要求服务器对任意 HTTP 请求发送 Set-Cookie HTTP 作为响应的一部分，其中包含会话信息

> 如：
>
> HTTP/1.1 200 OK
>
> Content-type: text / html
>
> Set-Cookie: name = value
>
> Other-header: other-header-value

* 限制

	* Cookie 在性质上是绑定在特定的域名下的
	* 当设定了一个 cookie 后，再给创建它的域名发送请求时，都会包含这个 cookie
	* 确保 cookie 中的信息只能让批准的接受者访问，而无法被其他域访问

* 构成

	* 名称：不区分大小写（实践最好区分），经过 URL 编码
	* 值：URL 编码
	* 域：有效域
	* 路径：对于指定的路径，应该向服务器发送 cookie
		* 若指定 http://www.wrox.com/books/，就不会给 http://www.wrox.com 发送 cookie
	* 失效时间：cookie 何时应该被删除的时间戳
	* 安全标志：指定后之后 SSL 连接时才发送到服务器

* JS 中的 cookie

	* BOM 的 document.cookie 属性

* 子 cookie

	* 存放在单个 cookie 中的更小段的数据

	* 使用 cookie 值来存储多个名称值对

	* > 如 name=name1=value1&name2=value2&name3=value3&name4=value4&name5=value5

	* 查询字符串的格式进行格式化



> 所有的 cookie 都会由浏览器作为请求头发送，所以在 cookie 中存储大量信息会影响到特定域的请求性能



### Web 存储机制

* Web Storage 的两个主要目标
	* 提供一种在 cookie 之外存储会话数据的途径
	* 提供一种存储大量可以跨会话存在的数据的机制



##### Storage 类型

* 只能存储字符串
* 提供最大的存储空间
* `clear()`
* `getItem(name)`
* `key(index)`
* `removeItem(name)`
* `setItem(name, value)`

##### sessionStorage 对象

*  Storage 的一个实例
* 存储特定于某个会话的数据，只保持到浏览器关闭
	* 如果浏览器支持，崩溃重启可以继续使用
* 可以跨越页面刷新而存在
* 存储在 sessionStorage 的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制

##### globalStorage 对象

* 不是 Storage 实例，globalStorage["xxx.com"] 才是 Storage 的实例
* 跨越会话存储数据，有特定的访问限制
* 如果不删除，或者用户未清除浏览器缓存，存储在 globalStorage 属性中的数据会一直保留在磁盘上
* 合在客户端存储文档或者长期保存用户偏好设置

##### localStorage 对象

* Storage 实例，用法与 sessionStorage 相同
* 取代 globalStorage，不用设置规则
* 同域名、同协议、同端口
* 保留到通过 JavaScript 删除或者是用户清除浏览器缓存

##### storage 事件

* 修改 Storage 对象会在文档上触发 storage 事件



### IndexedDB

* 浏览器中保存结构化数据的一种数据库
* 替代被废弃的 Web SQL Database API
* 创建一套 API，方便保存和读取 JavaScript 对象，同时还支持查询及搜索
* 异步
* 做为全局对象 windows.indexedDB，具体名称根据浏览器不同



##### 数据库

* 用对象保存数据，而不是用表来保存
* 一个 IndexedDB 数据库，就是一组位于相同命名空间下的对象的集合
* indexDB.open() 创建/打开
* 返回 IDBRequest 对象
	* onerror
	* onsuccess

##### 对象存储空间

* 可以把这里的对象存储空间(object storge)想象成表，把其中保存的对象想象成表中的记录
* `add()`
* `put()`

##### 事务

* 读取或修改数据都要通过事务来组织所有操作
* 使用事务可以直接通过已知的键检索单个对象

##### 使用游标查询

* 需要检索多个对象的情况下，需要在事务内 部创建游标
* 与传统数据库查询不同
	* 游标不提前收集结果
	* 游标指针会先指向结果中的第一项，在接到查找下一项的指令时指向下一项

##### 键范围

##### 设定游标方向
