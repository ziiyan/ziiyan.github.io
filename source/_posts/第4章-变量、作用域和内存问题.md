---
title: 第四章 变量、作用域和内存问题
date: 2020-02-17 22:16:00
tags: JavaScript高级程序设计
---

## 基本类型和引用类型的值
* 基本数据类型（5）按值访问，可以操作保存在变量中的实际的值。占据固定大小的空间，被保存在栈内存中。
* 引用类型（1）的值是保存在内存中的对象，保存在堆内存中。JS 不能直接操作对象的内存空间：复制保存对象的某个变量时，操作对象的引用；为对象添加属性时，操作的是实际的对象。

### 复制变量值
* 基本类型：创建新值
* 引用类型：创建新值，值是指针，实际与旧值引用同一个对象

### 传递参数
ECMAScript 中所有函数的参数都是按值传递的。
* 基本类型：被传递的值会被复制给一个局部变量。
* 引用类型：被传递的值的**地址**复制给一个局部变量。因此这个局部变量的变化会反应在函数的外部。
> 若在函数体内对这个局部变量进行重新赋值，那么保存的地址就改变了，指向的内存也不再是被传入的对象。

``` JS
function setName(obj) {
    obj.name = "Nicholas";
}

var person = new Object();
setName(person);
alert(person.name); //“Nicholas”
```

``` JS
function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}

var person = new Object();
setName(person);
alert(person.name); //“Nicholas”
```
在内部重写 obj 时，变量引用的就是一个局部对象了。局部对象在函数执行完毕后立即被销毁。

### 检测类型
* 基本类型：`typeof`
* 引用类型：`instanceof`
* 根据
``` JS
// result = variable instanceof constructor
// 根据原型链来识别
alert(person instanceof Object);
alert(person instanceof Array);
alert(person instanceof RegExp);
```
所有引用类型的值都是 Object 的实例。`Obj instanceof Object` 始终返回 true，检测基本类型始终 false，因为基本类型不是对象。

## 执行环境及作用域
* 执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。
* 每个执行环境都有一个与之关联的**变量对象**，环境中定义的所有变量和函数都保存在这个对象中。
* **全局执行环境**：根据宿主环境。WEB 浏览器中是 window 对象。
* **执行环境**，函数的环境，保存在栈中。
* 当代码在一个环境中执行时，会创建变量对象的一个**作用域链**，<u>保证对执行环境有权访问的所有变量和函数的有序访问。</u>
> 作用域链的前端，始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其**活动对象**作为变量对象。活动对象在最开始时只包含一个变量（即arguments对象，全局环境中不存在）。下一个变量对象来自包含（外部）环境……一直到全局执行环境。
> 标识符解析是沿着作用域链一级一级地搜索标识符的过程。
> 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境重的变量和函数。

### 延长作用域链
* try-catch 语句的 catch 块
* with 语句
``` js
function buildUrl() {
    var qs = "?debug=true";
    with (location) {
        var url = href + qs;
    }
    return url;
}
```
with 语句接收 location 对象，因此其变量对象中包含了 location 对象的所有属性和方法，而这个变量被添加到了作用域链的前端。
> 疑问：
> 作用域链：全局执行环境->buildUrl()->with(location)
> with 中定义的变量 url 为什么能够在外部环境 buildUrl 中访问？url是被定义在全局执行环境中的 location 变量对象中吗？
> ***
> 因为没有块级作用域，变量声明会被添加到当前的执行环境（这里是buildUrl（））中

### 没有块级作用域
```js
if (true) {
    var color = "blue";
}
alert(color);
```
js 中，if 语句中的变量声明会将变量添加到当前的执行环境（这里是全局环境）
如果没有用 var 声明，会直接被添加到全局环境。
> let 似乎解决了这个问题，本书没有讲到，看完 es6 再来补。

## 垃圾收集
### 标记清除
* 当变量进入环境，标记为“进入环境”。
    * 逻辑上讲，永远不能释放进入环境的变量所占用的内存。
* 当变量离开环境时，则标记“离开环境”。
* 可以使用任何方式来标记变量。如：
    * 翻转某个特殊的位
    * “进入环境”变量列表及“离开环境”变量列表
> 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记。在此之后再被加上标记的变量将被视为准备删除的变量。最后完成内存清除工作，销毁值并回收内存空间。

### 引用计数
跟踪记录每个值被引用的次数，赋值给变量则该值+1，若变量取得另一个值，则该值-1。
> 垃圾收集器下次运行时，释放计数 0 的值占用的内存。

> 循环引用会导致引用次数永远不为 0
> BOM 和 DOM 中的对象是使用 C++ 以 COM（Component Object Model，组件对象模型）对象的形式实现的，COM 对象的垃圾收集机制就是引用计数策略。
> 解决：手动断开循环引用（赋值为null）

### 性能问题
垃圾收集器是周期运行的，如果为变量分配的内存数量很大，那么回收工作量也相当大，确定时间间隔很重要。

### 管理内存
使用具备垃圾收集机制的语言编写程序，一般不必操心内存管理。但 js 比较特殊，因为分配给 Web 浏览器的可用内存通常比桌面应用少。
尽量少用内存页面会有更好的性能。一旦数据不再有用，赋值 null 来**解除引用**。适用于大多数全局变量和全局对象的属性，局部变量会在离开执行环境时自动解除。
解除引用不是自动回收内存，是让值脱离环境，垃圾收集器下次运行的时候将其回收。