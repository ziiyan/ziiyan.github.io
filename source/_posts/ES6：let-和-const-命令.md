---
title: ES6：let 和 const 命令
date: 2020-03-15 18:18:51
tags: ECMAScript 6 入门
---

# let 和 const 命令

## let 命令

### 基本用法

* let 声明的变量值在 let 命令坐在的代码块内有效

```js
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i);
  };
}
a[6](); // 10
// var 声明的 i 在全局有效，最终所有的 i 都指向同一个 i，也就是最后一轮循环时 i 的值
```

```js
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i);
  };
}
a[6](); // 6
```

* for 循环变量是一个父作用域，循环体是一个子作用域

```js
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
```

### 不存在变量提升

* `var` 声明会出现"变量提升"现象，即变量可以在声明之前使用，值为 `undefined`
* `let` 改变了语法行为，声明之前使用会报错

### 暂时性死区

* 块级作用域内存在 `let` 或 `const` 命令，它所声明的变量就"绑定(binding)"这个区域，不受外部影响

```js
var tmp = 123;
if (true) {
  tmp = 'abc';	// ReferenceError
  let tmp;
}
```

* 暂时性死区的本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

### 不允许重复声明

* `let` 不允许在相同作用域内重复声明同一个变量

```js
// 报错
function func() {
  let a = 10;
  var a = 1;
}
// 报错
function func() {
  var a = 10;
  let a = 1;
}
// 不报错
function func() {
  var a = 10;
  var a = 1;
}
```

## 块级作用域

### 为什么需要块级作用域？

ES5 只有全局作用域和函数作用域，可能会导致：

1. 内层变量可能会覆盖外层变量
2. 用来计数的循环变量泄露为全局变量

### 块级作用域与函数声明

* ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
* ES6 明确允许在块级作用域之中声明函数，且函数声明语句的行为类似于 let，在块级作用域外不可引用
* 但为了兼容，浏览器在实现时，函数声明的行为可以类似于 var，即会提升到全局作用域或函数作用域的头部

## const 命令

### 基本用法

* `const` 声明一个只读的常量，一旦声明，常量的值就不能改变
* 由于不能改变，声明时就必须初始化，否则报错

### 本质

* `csont` 实际上保证的是变量指向的那个内存地址所保存的数据不得改动
	* 对于简单类型（数值、字符串、布尔值）的数据，变量指向的地址保存值，等同于常量
	* 对于符合类型（对象、数组）的数据，变量指向的地址保存指针，指针再指向实际数据，这里只能保证指针不变，但不能保证实际数据不变
		* 如果想将对象冻结，可以使用 `Object.freeze()` 方法

### ES6 声明变量的六种方法

* ES5
	* var
	* function

---

* ES6 新增
	* let
	* const
	* import
	* class

## 顶层对象的属性

* 顶层对象
	* 浏览器：window
	* Node：global
* ES5 之中，顶层对象的属性和全局变量等价
* ES6 规定
	* var、function 声明的全局变量，依旧是顶层对象的属性
	* let、const、class 声明的全局变量，不属于顶层对象的属性

## globalThis 对象

* 顶层对象提供全局环境（即全局作用域）
* 各个实现不一致
	* 浏览器：`window`
	* 浏览器和 Web Worker：`self`
	* Node：`global`
* 为了兼容，一般使用 `this` ，但有限制
	* 全局环境中，`this` 会返回顶层对象。但 Node 模块和 ES6 模块中，`this` 返回当前模块
	* 函数里面的 `this`，如果函数不是作为对象的方法运行，`this` 指向顶层对象。严格模式下 `undefined`
	* `new Function('return this')()` 返回全局对象。如果浏览器用了 CSP（内容安全策略），则该方法无法使用
* ES2020 引入 `globalThis` 作为顶层对象，指向全局环境下的 `this`

