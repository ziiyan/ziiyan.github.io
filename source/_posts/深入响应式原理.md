---
title: 深入响应式原理
date: 2020-03-24 16:58:28
tags: Vue
---

在简历上写了熟悉 Vue（并不），只好临时抱佛脚……

https://cn.vuejs.org/v2/guide/reactivity.html

# 深入响应式原理

> Vue 最独特的特性之一，是其非侵入性的响应式系统。
>
> 数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新，这使得状态管理非常简单直接。
>
> 不过理解其工作原理同样重要，这样你可以避开一些常见的问题。

## 如何追踪变化

> 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 `data` 选项，Vue 将遍历此对象所有的属性，并使用 [`Object.defineProperty`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 把这些属性全部转为 [getter/setter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#定义_getters_与_setters)。

先来看看这个`Object.defineProperty`，查阅 MDN：

> `Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
>
> 直接在 [`Object`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object) 构造器对象上调用此方法，而不是实例。
>
> ```js
> var o = { a:0 }
> 
> Object.defineProperties(o, {
>     "b": { get: function () { return this.a + 1; } },
>     "c": { set: function (x) { this.a = x / 2; } }
> });
> 
> o.c = 10 // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
> console.log(o.b) // Runs the getter, which yields a + 1 or 6
> ```

其实很简单，就是修改 object 对象的方法嘛，注意这不是实例的方法，而是构造器的。

> `Object.defineProperty` 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。

这里是 shim 是什么呢？shim 可以将新的 API 引入到旧的环境中，而且仅靠就环境中已有的手段实现。所以这里的意思是说，`Object.defineProperty`  这个方法是无法引入到旧的环境的，所以不支持低版本浏览器。

> 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在属性被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 [vue-devtools](https://github.com/vuejs/vue-devtools) 来获取对检查数据更加友好的用户界面。

> 每个组件实例都对应一个 **watcher** 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。
>
> ![data](https://cn.vuejs.org/images/data.png)

## 检测变化的注意事项

> 受现代 JavaScript 的限制 (而且 `Object.observe` 也已经被废弃)，Vue **无法检测到对象属性的添加或删除**。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 `data` 对象上存在才能让 Vue 将它转换为响应式的。
>
> 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, propertyName, value)` 方法向嵌套对象添加响应式属性。
>
> ```js
> Vue.set(vm.someObject, 'b', 2)
> ```
>
> 有时你可能需要为已有对象赋值多个新属性，比如使用 `Object.assign()` 或 `_.extend()`。但是，这样添加到对象上的新属性不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象。
>
> ```js
> this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
> ```

`Object.assign()` 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

```js
Object.assign(target, ...sources)
```

###  声明响应式属性

> 由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明所有根级响应式属性，哪怕只是一个空值。

## 异步更新队列

> Vue 在更新 DOM 时是**异步**执行的。
>
> 只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。
>
> 如果同一个 watcher 被多次触发，只会被推入到队列中一次。
>
> 这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。

感觉这种处理类似于防抖，提升性能。

> 然后，在下一个的事件循环 “tick” 中，Vue 刷新队列并执行实际 (已去重的) 工作。
>
> Vue 在内部对异步队列尝试使用原生的 `Promise.then`、`MutationObserver` 和 `setImmediate`，如果执行环境不支持，则会采用 `setTimeout(fn, 0)` 代替。

`Promise.then`： ES6

`MutationObserver`：接口提供了监视对DOM树所做更改的能力。它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分。

`setImmediate`：非标准。

> 例如，当你设置 `vm.someData = 'new value'`，该组件不会立即重新渲染。
>
> 当刷新队列时，组件会在下一个事件循环 “tick” 中更新。
>
> 多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。
>
> 虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。
>
> 为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 `Vue.nextTick(callback)`。这样回调函数将在 DOM 更新完成后被调用。

## 简单实现

* Observe，给对象的属性添加 setter/getter 事件

```js
var data = { name: 'aaa'}
observe(data)
let name = data.name
data.name = 'bbb'

function observe(obj) {
  // 判断类型
  if (!obj || typeof obj !== 'object') {
    return
  }
  Object.keys(obj).forEach(key => {
    defineReactive(obj, key, obj[key])
  })
}

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  Object.defineProperty(obj, key, {
    // 可枚举
    enumerable: true,
    // 可配置
    configurable: true,
    // 自定义函数
    get: function reactiveGetter() {
      console.log('get value')
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
    }
  })
}
```

* Dep，用于解耦属性的依赖手机和派发更新操作

```js
class Dep {
  constructor() {
    this.subs = []
  }
  // 添加依赖
  addSub(sub) {
    this.subs.push(sub)
  }
  // 更新
  notify() {
    this.subs.forEach(sub => {
      sub.update()
    })
  }
}
// 全局属性，通过该属性配置 Watcher
Dep.target = null
```

* Watcher，触发依赖收集时的操作

```js
class Watcher {
  constructor(obj, key, cb) {
    // 将 Dep.target 指向自己
    // 然后触发属性的 getter 添加监听
    // 最后将 Dep.target 置空
    Dep.target = this
    this.cb = cb
    this.obj = obj
    this.key = key
    this.value = obj[key]
    Dep.target = null
  }
  update() {
    // 获得新值
    this.value = this.obj[this.key]
    // 调用 update 方法更新 Dom
    this.cb(this.value)
  }
}
```

* 改造 `defineReactive`，添加依赖收集和派发更新相关代码

```js

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  let dp = new Dep()
  Object.defineProperty(obj, key, {
    // 可枚举
    enumerable: true,
    // 可配置
    configurable: true,
    // 自定义函数
    get: function reactiveGetter() {
      console.log('get value')
      if (Dep.target) {
        dp.addSub(Dep.target)
      }
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
      dp.notify()
    }
  })
}
```





















