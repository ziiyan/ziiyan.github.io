---
title: 字节跳动-产品研发-一面凉经
date: 2020-07-26 15:58:07
tags: 面试
---

## 计算机网络

* TCP/IP 七层模型

	> 四层：应用层、传输层、网络层、物理层
	>
	> 七层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

* TCP、UDP 在哪层，区别

	> TCP 和 UDP 是传输层协议。
	>
	> TCP 是面向连接的、可靠的，而 UDP 相反，是无连接、不可靠的。TCP 适合数据可靠的场景，UDP 适合通信速度高的场景
	>
	> 三次握手流程：
	>
	> 首先，客户端发起连接请求，同步标志位1，随机起始序号 x；
	>
	> 然后客户端接收到请求，发送响应报文，同步标志位1，确认标志位1，随机起始序号 y，确认号 x+1；
	>
	> 最后客户端收到响应报文，发送确认报文，同步标志位1，确认标志位1，序号x+1，确认号y+1
	>
	> 为什么三次：
	>
	> 两次主要是为了防止服务器和过期的请求建立连接，如果客户端连续发送好几个连接请求，服务端只能全盘接受
	>
	> 有了第三次握手，客户端就可以在第三次的确认报文段告诉服务端你响应的那个连接请求是过期的
	>
	> 四次的话是可以但没必要，因为无论怎么样我们都无法保证连接百分之百不出错，应该说三次是最小次数
	>
	> 无差错

* TCP 怎么实现丢包检测机制

	> 利用滑动窗口，只接收序号在窗口内的数据包，这样能按顺序接收，不在滑动窗口内的序号包就丢弃。响应报文会发送确认号，表示多少号之前的报文我都接受到了，发送方就会重传确认号之后的报文。

* HTTP、HTTPS 区别

	> HTTPS 比 HTTP 多了一层 SSL，HTTP 先和 SSL 通信再由 SSL 和 TCP 通信，HTTPS 需要 CA 证书。
	>
	> HTTP 是不安全的，体现在三个方面，一是明文传输，二是无法验证数据完整性，三是无法验证对方身份，可能被伪装
	>
	> HTTPS 传输过程中是对数据对称加密再传输的，避免了明文传输。同时对数据摘要进行签名并把签名结果一起发送给服务器，服务器用相同的摘要算法提取摘要，再和解密后的签名结果进行比对，就能知道发送过来的数据是否被篡改。因为有了数字签名，也可以证明这个报文就是密钥的持有人发送的。

## HTML

* 语义化标签有哪些

	> 标题 h1 - h6
	>
	> 列表 ul、ol
	>
	> 布局 header、footer、nav、main、article、section、aside

* 聊聊 meta 标签

	> charset 声明文档使用的字符编码
	>
	> http-equiv 添加 http 头部内容
	>
	> name=viewport 主要影响移动端布局的，在content 里设置 width， device-width 是设备宽度

## CSS

* 实现水平垂直居中的方法，尽量多

	> ```css
	> // flex
	> .container {
	>   display: flex;
	>   justify-content: center;
	>   align-items: center;
	> }
	> ---
	> .container {
	>   display: flex;
	> }
	> .item {
	>   margin: auto;
	> }
	> ```
	>
	> ```css
	> // 绝对定位
	> .container {
	>   position: relative;
	> }
	> .item {
	>   position: absoluate;
	>   left: 50%;
	>   top: 50%;
	>   transform: translate(-50%, -50%);
	> }
	> ---
	> .container {
	>   position: relative;
	> }
	> .item {
	>   position: absoluate;
	>   left: 50%;
	>   top: 50%;
	>   margin-left: -0.5 * 宽度;
	>   margin-top: -0.5 * 高度;
	> }
	> ---
	> .container {
	>   position: relative;
	> }
	> .item {
	>   position: absoluate;
	>   left: 0;
	>   right: 0;
	>   top: 0;
	>   bottom: 0;
	>   margin: auto;
	> }
	> ```

* 实现双栏布局（左边定宽100px，右边自适应）

	> ```html
	> <div class="container">
	>   <div class="left"></div>
	>   <div class="right"></div>
	> </div>
	> 
	> <style>
	>   .container {
	>     position: relative;
	>     padding-left: 100px;
	>   }
	>   .left {
	>     width: 100px;
	>     margin-left: -100px;
	>     float: left;
	>   }
	>   .right {
	>     width: 100%;
	>   }
	> </style>
	> ```

## JS

* 基本数据类型

	> （6种）String、Number、Undefined、NULL、Boolean、Symbol
	>
	> 引用数据类型（1） Object

* 关于 Symbol 知道多少

	> 

* 判断数据类型的方法

	> typeof：引用类型除function之外返回的都是object
	>
	> 已知引用类型用 instanceof 和 constructor
	>
	> instanceof：基于原型链
	>
	> constructor：属性易变，不可信赖
	>
	> Object.prototype.toString.call 通用但繁琐 

* 如何区分 Array 和 Object

	> arr instanceof Array
	>
	> arr.constructor === Array
	>
	> Object.prototype.toString.call(arr) === "[object Array]"
	>
	> Array.isArray(arr)

* 节流、防抖场景

	> 节流是每隔一段时间执行一次操作，比如监听滚动事件
	>
	> 防抖是延迟执行，比如连续点击，只在最后一次点击之后发送请求

* 手写节流 / 防抖

	> ```js
	> function debounce(fn, ms) {
	>   let timer = null;
	>   return (...arg) => {
	>     clearTimeout(timer);
	>     timer = setTimeout(() => {
	>       fn(...arg);
	>     }, ms)
	>   }
	> }
	> 
	> function throttle(fn, ms) {
	>   let timer = null;
	>   return (...arg) => {
	>     if (timer) return;
	>     timer = setTimeout(() => {
	>       fn(...arg);
	>       timer = null;
	>     }, ms)
	>   }
	> }
	> ```

## Vue

* 双向绑定原理
* setter、getter 的时候做了什么

## 数据结构

* 判断链表是否有环
* 岛屿最大面积

