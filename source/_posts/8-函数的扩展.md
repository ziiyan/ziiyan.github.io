---
title: 函数的扩展
date: 2020-03-18 21:15:15
tags: ECMAScript 6 入门
---

# 函数的扩展

## 函数参数的默认值

### 基本用法

```js
function Point（x = 0, y = 0) {
  this.x = x;
  this.y = y;
}
```

* 参数默认值是惰性求值，每次重新计算

### 与解构赋值默认值结合使用

### 函数的 length 属性

* 返回没有指定默认值的参数个数

## rest 参数

* `...变量名` 不需要使用 `arguments` 对象
* `arguments` 是类数组
* `rest` 是真的数组

## name 属性

* 返回函数名

## 箭头函数

### 注意点

* 函数体内的 `this` 对象，是定义时所在的对象，而不是使用时所在的对象
	* 箭头函数没有自己的 `this` ，引用外层的 `this`
* 不可以当作构造函数，不可以使用 `new` 命令
* 不可以使用 `arguments` 对象，可以用 `rest` 参数
* 不可以使用 `yield` 命令，因此不能用做 Generator 函数

## 尾调用优化

### 什么是尾调用

* 某个函数的最后一步是调用另一个函数

### 尾调用优化

> 函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数`A`的内部调用函数`B`，那么在`A`的调用帧上方，还会形成一个`B`的调用帧。等到`B`运行结束，将结果返回到`A`，`B`的调用帧才会消失。如果函数`B`内部还调用函数`C`，那就还有一个`C`的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。
>
> 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。

* 只有 Safari 支持

### 尾递归

* 尾调用自身，就称为尾递归。

> 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

* 斐波那契

```js
function Fibonacci(n) {
  if (n <= 1) return 1;
  return Fibonacci(n-1) + Fibonacci(n-2);
}

// 尾递归
function Fibonacci2 (n, ac1 = 1, ac2 = 1) {
  if (n <= 1) return ac2;
  return Fibonacci2 (n-1, ac2, ac1 + ac2);
}
```

* ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存

### 递归函数的改写

* 把所有用到的内部变量改写成函数的参数

> 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。

### 严格模式

* ES6 的尾调用优化只在严格模式下开启

## 函数参数的尾逗号

* ES6 中函数最后一个参数后有逗号不会报错

## Function.prototype.toString()

* `toString()`方法返回函数代码本身，以前会省略注释和空格

## catch 命令的参数省略

* 以前 catch 命令后面必须跟参数，ES6 可以省略

