---
title: 面试准备-计算机网络
date: 2020-0-14 23:01:08
tags: [面试, 网络]
---

## 1、体系结构

| TCP/IP体系结构(四层) | 五层      | `OSI`的体系结构(七层) |
| -------------------- | --------- | --------------------- |
| 4、应用层            | 5、应用层 | 7、应用层             |
|                      |           | 6、表示层             |
|                      |           | 5、会话层             |
| 3、传输层            | 4、传输层 | 4、传输层             |
| 2、网络层            | 3、网络层 | 3、网络层             |
| 1、物理层            | 2、链路层 | 2、链路层             |
|                      | 1、物理层 | 1、物理层             |

## 2、TCP

### 2.1、定义

* Transmission Control Protocol，传输控制协议
* 传输层

### 2.2、特点

* 面向连接
	* 先建立连接、传输完成后释放连接

* 可靠
	* 不丢失、无差错、不重复、按顺序到达

* 面向字节流
	* 流：流入/出进程的字符序列
	* TCP一次传输的报文长度有限制，太大需分块
	* 按序到达可以重新组合
* 全双工通信
	* 双方都能发送数据

### 2.3、优缺点

* 可靠
* 慢
	* 需要建立连接
	* 发送确认包

### 2.4、应用场景

* 要求通信数据可靠

### 2.5、报文段格式

* 序号
	* 本报文段所发送数据的第1个字节的序号
* 确认号（ACK）
	* 期望收到对方下个报文段的第一个字节的序号
	* ACK = N ：N-1 都收到
* SYN（同步位）
	* 连接建立时用于同步序号
	* SYN = 1、ACK = 0：连接请求
	* SYN = 1、ACK = 1：连接请求响应
* FIN（终止控制位）
	* 释放连接
	* FIN = 1：发送完毕，请求释放连接

### 2.6、三次握手

| 描述                         | 报文段信息                                                   | 状态                                  |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------- |
| 客户端发送【连接请求】报文段 | 1、同步标志位 SYN = 1，<br/>2、随机起始序号 seq = x，<br/>3、不携带数据<br/>**SYN = 1 的报文段不能携带数据，但要消耗一个序号** | 客户端【SYN_SEND】【同步已发送】      |
| 服务器发送【响应确认】报文段 | 1、同步标志位 SYN = 1，<br/>2、确认标记位 ACK = 1，<br/>3、随机起时序号 seq = y，<br/>4、确认号字段 ack = x+1<br/>**同上，不携带数据** | 服务器【SYN_RCVD】【同步已接受】      |
| 客户端发送【连接确认】报文段 | 1、确认标记位 ACK = 1，<br/>2、序号 seq = x+1<br/>3、确认号字段 ack = y+1<br/>**可携带数据** | 客户端、服务器【ESTABLISHED】【创建】 |

#### 为什么TCP建立连接需三次握手？

1. 两次？防止服务端与历史请求建立连接
	* 两次握手
		* 如果网络比较差，发送方连续发送多次建立连接的请求，服务端无法判断当前收到的请求是否已经过期
	* 三次握手
		* 如果当前连接是历史连接，即 `SEQ` 过期或者超时，那么发送方就会直接发送 `RST` 控制消息中止这一次连接；
		* 如果当前连接不是历史连接，那么发送方就会发送 `ACK` 控制消息，通信双方就会成功建立连接
2. 初始化序列号
	* 通信双方都需要获得一个用于发送信息的初始化序列号
3. 四次？可以但没必要
	* 总可以使用更多的通信次数交换相同的信息
	* 三次是最小次数

### 2.7、四次挥手

| 描述                             | 报文段信息                                                   | 状态                                                         |
| -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 客户端发送【连接释放】报文段     | 1、终止控制位 FIN = 1，<br/>2、报文段序号，发送数据最后序号+1，seq = u，<br/>可携带数据 | 客户端【FIN-WAIT-1】【终止等待1】                            |
| 服务器发送【连接释放确认】报文段 | 1、确认标记位 ACK = 1，<br/>2、报文段序号，发送数据最后序号+1，seq = v，<br/>3、确认号字段 ack = u+1 | 服务器【CLOSE-WAIT】【关闭等待】<br/>客户端【FIN-WAIT-2】【终止等待2】<br/><br/>**客户端 -> 服务器 TCP 断开** |
| 服务器发送【释放连接】报文段     | 1、终止控制位 FIN = 1，<br/>2、却仍表姐为 ACK = 1，<br/>3、报文段序号 seq = w，<br/>4、重复确认号字段 ack = u+1，<br/>可携带数据 | 服务端【LAST-ACK】【最后确认】                               |
| 客户端发送【连接释放确认】       | 1、确认标记位 ACK = 1，<br/>2、报文段序号 seq = u+1，<br/>3、确认号字段 ack = w+1，<br/>可携带数据 | 客户端【TIME-WAIT】【时间等待】<br/>**经过时间等待后，客户才关闭**<br/><br/>服务器【CLOSED】【关闭】<br/>**服务器 -> 客户端 TCP 断开** |

#### 为什么TCP释放连接需四次挥手？

* 为了保证通信双方都能通知对方需释放 & 断开连接
	* 全双工，即双方都可以发送 & 接收信息
	* 两次挥手只能保证单向关闭

#### 为什么客户端关闭连接前要等待时间？/ TIME-WAIT 的作用？

* 为了保证客户端发送的【连接释放确认】报文能到达服务器

### 2.8、无差错传输

#### 2.8.1、含义

* 无差错：即 传输信道不出差错
* 发送 & 接收效率匹配：即 无论发送方以多快的速度发送数据，接收方总来得及处理收到的数据

#### 2.8.2、基础：滑动窗口

* 发送窗口
	* 任意时刻，发送方维持的一组连续的、允许发送帧的帧序号
	* 对发送方进行流量控制
	* 收到确认帧，滑动窗口滑动
* 接受窗口
	* 任意时刻，接收方维持的一组连续的、允许接收帧的帧序号
	* 控制可接收哪些数据帧
	* 只有当收到数据帧序号落入接收窗口，接收并滑动，否则丢弃帧

#### 2.8.3、实现无差错传输的解决方案<sup>[2]</sup>

* 核心思想：采用一些可靠传输协议，使得

	* **出错重传**：出现差错时，让发送方重传差错数据
		* 自动重传协议

	* **速度匹配**：当接收方来不及接收收到的数据时，可通知发送方降低发送数据的效率
		* 流量控制
		* 拥塞控制

##### 自动重传协议

* 停等式：发送窗口 = 1、接收窗口 = 1
* 后退N帧：发送窗口 > 1、接收窗口 = 1
* 选择重传：发送窗口 > 1、接收窗口 > 1

##### 流量控制 & 拥塞控制

* 流量控制：点对点
	* 接收方根据自己接收缓存的大小，动态调整发送方窗口大小
	* 发送方根据接收方返回的**确认帧**调整发送方窗口大小
* 拥塞控制：全局
	* 防止过多的数据注入到网络中，使得网络中的路由器 & 链路过载
	* **慢开始 & 拥塞避免**
	* **快重传 & 快恢复**

### 2.9、与 UDP 的区别

* TCP：面向连接、可靠、字节流。适合数据可靠的场景
* UDP：无连接、不可靠、数据报文段。适合通信速度高的场景

## 3、UDP

### 3.1、定义

* User Datagram Protocol，用户数据报协议
* 传输层

### 3.2、特点

* 无连接
* 不可靠
	* 可能出现丢包，不管对方是否接收
* 面向报文
	* 无长度限制，一次性发送
* 无拥塞控制

### 3.3、优缺点

* 速度快
* 不可靠

### 3.4、应用场景

* 要求通信速度高

### 3.5、报文段格式

* 源端口（回复时使用）
* 目的端口
* 长度
* 检验和（检测UDP在传输中是否有错，有错丢弃）
* 伪首部

### 3.6、与 TCP 的区别

* TCP：面向连接、可靠、字节流。适合数据可靠的场景
* UDP：无连接、不可靠、数据报文段。适合通信速度高的场景

## 4、HTTP

### 4.1、定义

* HyperText Transfer Protocol，超文本传输协议
* 应用层

### 4.2、特点

* 传输效率高
	* 无连接：不需要建立 HTTP 连接
	* 无状态：不保存历史&状态信息
	* 传输格式简单：请求时只需方法&路径
* 传输可靠性高
	* 基于 TCP
* 其它
	* 兼容性好：支持 B/S、C/S
	* 灵活性高：允许传输任意类型数据对象

### 4.3、工作方式

* **请求 / 相应** 工作方式

### 4.4、HTTP 报文详解

#### 4.4.1、请求报文

* 请求行

> **GET、POST 方法的区别？**
>
> * 语义：GET 请求，POST 提交
>
> * 参数：GET 放 URL 中，POST 放 body
> 	* 浏览器对 URL 有限制长度，HTTP 协议未限制
> * 安全性：GET 参数可见，POST 数据在浏览器中无缓存

* 请求头
* 请求体

#### 4.4.2、响应报文

* 状态行

> **常见状态码？**
>
> * 200
> * 404
> * 302
> * 304

* 响应头
* 响应体

### 4.5、额外知识

#### 4.5.1、HTTP 1.1 与 HTTP 1.0 的区别

* http 1.1 引入持久连接，在一个 TCP 中可以传送多个 HTTP 请求 & 响应
* 多个请求 & 响应可以同时进行
* 引入更多请求头 & 响应头

#### 4.5.2、HTTP 与 HTTPS 的区别

| URL      | 原理   | 功能                  | 标准端口 | CA     |
| -------- | ------ | --------------------- | -------- | ------ |
| http://  | 应用层 | 不加密                | 80       | 不需要 |
| https:// | 传输层 | 加密（SSL、身份认证） | 443      | 需要   |

#### 4.5.3、HTTP 处理长连接的方式

* Keep-Alive 机制

## 5、其它

### 5.1、浏览器输入 URL 到页面显示的过程

1. dns解析
2. tcp连接
3. http请求
4. 服务器响应
5. 浏览器渲染
	1. 页面资源加载
		1. 建立连接
		2. 加载资源
	2. 页面资源渲染
		1. 处理HTML标记，构建DOM树
		2. 处理CSS标记，构建CSSOM树
		3. 将DOM树和CSSOM树融合成渲染树（会忽略不需要渲染的dom）
		4. 根据渲染树来布局，计算每个节点的几何信息
		5. 在屏幕上绘制各个节点
		6. 中间遇到各种资源时，会进行资源的下载

### 5.2、跨域

#### 5.2.1、同源策略

* 同源：协议、域名、端口号 相同

* 浏览器限制从**脚本**内发起的跨源HTTP请求

* 解决方案
  * cors

    * ```js
    	res.header('Access-Control-Allow-Origin', '*');
    	res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
    	res.header('Access-Control-Allow-Headers', '*');
    	```
    	
    * 非简单请求会发起预检请求（OPTIONS）

    * 简单请求（普通 HTML Form 在不依赖脚本的情况下可以发出的请求）：

      1. GET、HEAD 或 POST

      2. 只使用了如下的安全首部字段

      - `Accept`
      - `Accept-Language`
      - `Content-Language`
      - `Content-Type` 仅限以下三种
      	- `text/plain`
      	- `multipart/form-data`
      	- `application/x-www-form-urlencoded`

  > **为什么要区分简单请求&非简单请求？**
  >
  > 首先注意同源策略：浏览器限制从**脚本**内发起的跨源HTTP请求
  >
  > 简单请求指的是：普通 HTML Form 在**不依赖脚本**的情况下可以发出的请求
  >
  > 对于服务器来说，不需要区分简单请求是 Form 发出的还是 Ajax 发出的，因为都需要进行处理，所以对这种情况进行预检的话反而多做了一次无用的判断。Ajax 返回的数据会被客户端拦截，服务器不需要进行多余的操作。

  * jsonp

  	* 原理：利用 `<script>`、`<link>`、`<img>` 没有同源限制

  	1. src 属性的值为接口地址
  	2. 前后端约定好执行函数的名称 `callback`
  	3. 前端定义该函数 `callback(data) { console.log(data); }`
  	4. 后台返回数据 `res.send('callback(${JSON.stringify(data))')`

  * nginx 反向代理

  * Node 中间件代理

  * postMessage

  * websocket

### 5.3、cookie、localstroage、sessionstroage 的区别

> Cookie适合存储一些session信息：
>
> 1. cookie限制大小，约4k左右，不适合存储业务数据，尤其是数据量较大的值
> 2. 存在有效期，到期自动销毁
> 3. cookie会每次随http请求一起发送，浪费宽
> 4. cookie设置了domain可以在子域共享跨域
> 5. 可以使用爬虫抓取
>
> localstroage适合存储应用共享的地址信息等：
>
> 1. 存储数据量大，5M或者更大
> 2. 有效期为永久
> 3. 不会随http请求一起发送
> 4. 不能跨域，但是可以使用postMessage和iframe消除这个影响,例如：[cross-storage](https://github.com/zendesk/cross-storage)
> 5. 在浏览器的隐私模式下不能读取
> 6. 不能被爬虫读取
>
> sessionstroage适合存储浏览状态等：
>
> 1. 存储数据量大，5M或者更大
> 2. 有效期为到浏览器关闭
> 3. 不会随http请求一起发送
> 4. 不能被爬虫读取

### 5.4、HTTPS

#### 5.4.1、HTTP 为什么不安全

1. 明文传输，内容可能被窃听
2. 无法验证报文的完整性，内容可能被篡改（中间人攻击）
3. 不验证对方身份，可能被伪装

#### 5.4.2、HTTPS 实现原理

*  HTTP 先跟 SSL 通信再由 SSL 跟 TCP 通信

| HTTP | HTTPS |
| ---- | ----- |
| HTTP | HTTP  |
|      | SSL   |
| TCP  | TCP   |
| IP   | IP    |

> SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应 用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是 当今世界上应用最为广泛的网络安全技术。

* 加密
	* 数据传输阶段——对称密钥加密
		* 加密和解密阶段使用同一个密钥
	* 证书验证阶段——非对称密钥加密
		* 对方公钥加密，对应私钥解密
		* 比对称密钥复杂，慢
	* **混合加密机制**
		* 非对称私钥用来交换共享密钥（公钥加密）
		* 对称密钥用来交换数据（共享密钥加密）
* 证书
	1. 服务器把自己的公开密钥交给CA（Certificate Authority，数字认证机构）
	2. CA 用自己的私钥给服务器的公钥签名，并颁发公钥证书
	3. 客户端拿到服务器的公钥证书，用植入浏览器的CA公钥验证证书真实性，从而保证服务器公钥真实性
	4. 客户端使用服务器的公钥对报文加密后发送
	5. 服务器使用自己的私钥对豹纹解密
* 数据完整性
	* 数字签名
		* 发送方用摘要算法对报文提取生成数字摘要
		* 使用私钥对摘要进行加密加密后的摘要作为数字签名附加在报文上，一起发送给接收方
		* 接收方收到报文后，使用相同的摘要算法提取出摘要
		* 再使用公钥对报文的数字签名进行解密
		* 如果解密后的数字签名与提取出得摘要相同，那么就可以证明报文没被篡改，数据是完整的

#### 5.4.3、HTTPS 完整流程

* 证书验证阶段
	1. 客户端发起 HTTPS 请求
	2. 服务端返回 HTTPS 证书
	3. 客户端验证证书是否合法
* 数据传输阶段
	1. 客户端生成共享密钥
	2. 公钥加密共享密钥，发送给服务端
	3. 服务端用私钥解密，获得共享密钥
	4. 共享密钥加密交换数据

#### 5.4.4、HTTPS 缺点

* 速度慢
* CA 付费

## Reference

* [面试带你飞：这是一份全面的 计算机网络基础 总结攻略](https://juejin.im/post/5ad7e6c35188252ebd06acfa)
* [计算机网络：这是一份全面 & 详细 的TCP协议攻略](https://www.jianshu.com/p/65605622234b)
* [为什么 TCP 建立连接需要三次握手](https://draveness.me/whys-the-design-tcp-three-way-handshake/)
* [计算机网络：这是一份全面& 详细 HTTP知识讲解](https://www.jianshu.com/p/a6d086a3997d)
* [九种跨域方式实现原理（完整版）](https://juejin.im/post/5c23993de51d457b8c1f4ee1)
* [CORS 为什么要区分『简单请求』和『预检请求』？](https://juejin.im/post/6844903936512491528)
* [前端必须懂的计算机网络知识—(跨域、代理、本地存储)](https://juejin.im/post/5bb1cc2af265da0ae5052496)
* [[秃破前端面试] —— HTTP && HTTPS](https://juejin.im/post/6844904029416341512)