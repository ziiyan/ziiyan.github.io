---
title: 面试准备：双向绑定原理
date: 2020-08-06 16:58:28
tags: [ Vue, 面试 ]
---

# 深入响应式原理

> Vue 最独特的特性之一，是其非侵入性的响应式系统。
>
> 数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新，这使得状态管理非常简单直接。
>

## 如何追踪变化

> 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 `data` 选项，Vue 将遍历此对象所有的属性，并使用 [`Object.defineProperty`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 把这些属性全部转为 [getter/setter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#定义_getters_与_setters)。

先来看看这个`Object.defineProperty`，查阅 MDN：

> `Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
>
> 直接在 [`Object`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object) 构造器对象上调用此方法，而不是实例。
>
> ```js
> const _xxObj = {};
> 
> Object.defineProperty(_xxObj, 'xx_val', {
>   get: function () {
>     console.log('ggg');
>   },
>   set: function () {
>     console.log('sss');
>   }
> });
> 
> // 写入时触发 set
> _xxObj.xx_val = 123; // sss
> 
> // 读取时触发 get
> console.log(_xxObj.xx_val); // ggg
> // undefine 因为 get() 没有返回值
> ```

其实很简单，就是修改 object 对象的方法嘛，注意这不是实例的方法，而是构造器的。

> `Object.defineProperty` 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。

这里是 shim 是什么呢？shim 可以将新的 API 引入到旧的环境中，而且仅靠就环境中已有的手段实现。所以这里的意思是说，`Object.defineProperty`  这个方法是无法引入到旧的环境的，所以不支持低版本浏览器。

> 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在属性被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 [vue-devtools](https://github.com/vuejs/vue-devtools) 来获取对检查数据更加友好的用户界面。

> 每个组件实例都对应一个 **watcher** 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。
>
> ![data](https://cn.vuejs.org/images/data.png)

## 检测变化的注意事项

> 受现代 JavaScript 的限制 (而且 `Object.observe` 也已经被废弃)，Vue **无法检测到对象属性的添加或删除**。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 `data` 对象上存在才能让 Vue 将它转换为响应式的。
>
> 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, propertyName, value)` 方法向嵌套对象添加响应式属性。
>
> ```js
> Vue.set(vm.someObject, 'b', 2)
> ```
>
> 有时你可能需要为已有对象赋值多个新属性，比如使用 `Object.assign()` 或 `_.extend()`。但是，这样添加到对象上的新属性不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象。
>
> ```js
> this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
> ```

`Object.assign()` 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

```js
Object.assign(target, ...sources)
```

###  声明响应式属性

> 由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明所有根级响应式属性，哪怕只是一个空值。

## 异步更新队列

> Vue 在更新 DOM 时是**异步**执行的。
>
> 只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。
>
> 如果同一个 watcher 被多次触发，只会被推入到队列中一次。
>
> 这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。

感觉这种处理类似于防抖，提升性能。

> 然后，在下一个的事件循环 “tick” 中，Vue 刷新队列并执行实际 (已去重的) 工作。
>
> Vue 在内部对异步队列尝试使用原生的 `Promise.then`、`MutationObserver` 和 `setImmediate`，如果执行环境不支持，则会采用 `setTimeout(fn, 0)` 代替。

`Promise.then`： ES6

`MutationObserver`：接口提供了监视对DOM树所做更改的能力。它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分。

`setImmediate`：非标准。

> 例如，当你设置 `vm.someData = 'new value'`，该组件不会立即重新渲染。
>
> 当刷新队列时，组件会在下一个事件循环 “tick” 中更新。
>
> 多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。
>
> 虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。
>
> 为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 `Vue.nextTick(callback)`。这样回调函数将在 DOM 更新完成后被调用。

## 简单实现

* Observe，给对象的属性添加 setter/getter 事件

```js
var data = { name: 'aaa'}
observe(data)
let name = data.name
data.name = 'bbb'

function observe(obj) {
  // 判断类型
  if (!obj || typeof obj !== 'object') {
    return
  }
  Object.keys(obj).forEach(key => {
    defineReactive(obj, key, obj[key])
  })
}

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  Object.defineProperty(obj, key, {
    // 可枚举
    enumerable: true,
    // 可配置
    configurable: true,
    // 自定义函数
    get: function reactiveGetter() {
      console.log('get value')
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
    }
  })
}
```

* Dep，用于解耦属性的依赖手机和派发更新操作

```js
class Dep {
  constructor() {
    this.subs = []
  }
  // 添加依赖
  addSub(sub) {
    this.subs.push(sub)
  }
  // 更新
  notify() {
    this.subs.forEach(sub => {
      sub.update()
    })
  }
}
// 全局属性，通过该属性配置 Watcher
Dep.target = null
```

* Watcher，触发依赖收集时的操作

```js
class Watcher {
  constructor(obj, key, cb) {
    // 将 Dep.target 指向自己
    // 然后触发属性的 getter 添加监听
    // 最后将 Dep.target 置空
    Dep.target = this
    this.cb = cb
    this.obj = obj
    this.key = key
    this.value = obj[key]
    Dep.target = null
  }
  update() {
    // 获得新值
    this.value = this.obj[this.key]
    // 调用 update 方法更新 Dom
    this.cb(this.value)
  }
}
```

* 改造 `defineReactive`，添加依赖收集和派发更新相关代码

```js

function defineReactive(obj, key, val) {
  // 递归子属性
  observe(val)
  let dp = new Dep()
  Object.defineProperty(obj, key, {
    // 可枚举
    enumerable: true,
    // 可配置
    configurable: true,
    // 自定义函数
    get: function reactiveGetter() {
      console.log('get value')
      if (Dep.target) {
        dp.addSub(Dep.target)
      }
      return val
    },
    set: function reactiveSetter(newVal) {
      console.log('change value')
      val = newVal
      dp.notify()
    }
  })
}
```

# 极简版双向绑定

```html
<h1>极简版双向绑定</h1>

<input type="text" id="text_id" />
<p id="p_id"></p>

<script type="text/javascript">
  var _xxObj = {}
  
  Object.defineProperty(_xxObj, 'xx_val', {
    get: function () {
      console.log('ggg');
      return 'xx123'
    },
    set: function (_n) {
      document.getElementById('txt_id').value = _n;
      document.getElementById('p_id').innerHTML = _n;
    }
  });
  
  // 监听键盘事件
  document.addEventListener('keyup', function (e) {
    _xxObj.xx_val = e.target.value;
  })
</script>
```

* 上面直接操作 DOM，效率低

* 通过**观察者模式**提高双向绑定效率

# 实现双向绑定 MVVM

```html
<div id="mvvm-app">
    <input type="text" v-model="word">
    <p>{{word}}</p>
    <button v-on:click="sayHi">change model</button>
</div>

<script src="./js/observer.js"></script>
<script src="./js/watcher.js"></script>
<script src="./js/compile.js"></script>
<script src="./js/mvvm.js"></script>
<script>
    var vm = new MVVM({
        el: '#mvvm-app',
        data: {
            word: 'Hello World!'
        },
        methods: {
            sayHi: function() {
                this.word = 'Hi, everybody!';
            }
        }
    });
</script>
```

## 思路整理

1. 实现一个数据监听器 `Observer`，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
2. 实现一个指令解析器 `Compile`，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
3. 实现一个 `Watcher`，作为连接 `Observer` 和 `Compile` 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图
4. mvvm 入口函数，整合以上三者

![图片描述](https://segmentfault.com/img/bVBQYu?w=730&h=390)

## 实现 Observer

* 利用 `Object.defineProperty()` 来监听属性变动，遍历需要监听的属性，设置 `set` 和 `get`，在给属性赋值的时候就会触发 `set`，访问这个属性的时候就会触发 `get`

```js
// observer.js
var data = { name: 'vue' };
observe(data);
data.name = 'dmq';	// 赋值，触发属性 name 的 set

function observe(data) {	// 实现 observer
  if (!data || typeof data !== 'object') {
    return;
  }
  Object.keys(data).forEach(function(key) {	// 取出所有属性遍历
    defineReactive(data, key, data[key]);		
  });
};

function defineReactive(data, key, val) {
  var dep = new Dep();
  
  observe(val);	// 监听子属性
  Object.defineProperty(data, key, {
    enumerable: true,	// 可枚举
    configurable: false,	// 不能再 define
    get: function () {
      Dep.target && dep.addSub(Dep.target);	// 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除（看 Watcher.js）
      return val;
    },
    set: function (newVal) {
      if (val === newVal) return;	// 没变化
      console.log('监听', val, '-->', newVal);
      val = newVal;
      dep.notify();	// 通知所有订阅者
    }
  });
}

function Dep() {	// 消息订阅器
  this.subs = [];	// 收集订阅者
}
Dep.prototype = {
  addSub: function(sub) {	// 添加订阅者
    this.subs.push(sub);
  },
  notify: function() {	// 通知订阅者
    this.subs.forEach(function(sub) {
      sub.update();	// 调用订阅者的更新方法
    });
  }
};
```

## 实现 Compile

* 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
* 因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点`el`转换成文档碎片`fragment`进行解析编译操作，解析完成，再将`fragment`添加回原来的真实dom节点中

## 实现 Watcher

* `Watcher `订阅者作为 `Observer` 和 `Compile` 之间通信的桥梁，主要做的事情是:
	1. 在自身实例化时往属性订阅器 `dep` 里面添加自己
	2. 自身必须有一个 `update` 方法
	3. 待属性变动 `dep.notice()` 通知时，能调用自身的 `update()` 方法，并触发`Compile` 中绑定的回调

```js
// watcher.js
function Watcher(vm, exp, cb) {
  this.cb = cb;
  this.vm = vm;
  this.exp = exp;
  this.value = this.get();	// 此处为了触发属性的getter，从而在 dep 添加自己，结合Observer更易理解
  
  Watcher.prototype = {
    update: function() {
      this.run();	// 属性值变化收到通知
    },
    run: function() {
      var value = this.get();	// 取到最新值
      var oldVal = this.value;
      if (value !== oldVal) {
        this.value = value;
        this.cb.call(this.vm, value, oldVal);	// 执行Compile中绑定的回调，更新视图
      }
    },
    get: function() {
      Dep.target = this;	// 将当前订阅者指向自己
      var value = this.vm[exp];	// 触发getter，添加自己到属性订阅器中
      Dep.target = null;	// 添加完毕，重置
      return value;
    }
  }
}
```

# 谈一谈 vue 双向绑定原理

## 对象

* 首先，Vue 是采用**数据劫持**结合发**布者-订阅模式**，通过 `Object.defineProperty()` 来劫持各个属性的 `setter` 和 `getter`

* 每个属性都对应有一个订阅者列表，订阅者获取该属性时会触发 `get`，这个时候将订阅者添加到属性的订阅者列表里，这就是收集依赖的过程
* 在该属性改变时，会触发 `set`，在 `set` 里通知所有订阅者
* 订阅者收到属性改变的事件后，再更新视图

> * 观察者模式
>
> ```
> 					—— Fire Event ——>
> Subject												Observer
> 					<—— Subscribe ——
> ```
>
> * 发布订阅模式
>
> ```
>                                         		  	—— Fire Event ——>
> Publisher —— Publish Event ——>	Event Channel												Observer
>                                               	<—— Subscribe ——
> ```
>
> 观察者是直接订阅目标事件的，而发布者和订阅者中间还有一个第三方，一般是队列实现的，这个第三方一方面从发布者接收事件，另一个方面向订阅者发布事件，避免发布者和订阅者产生依赖。

## 数组

### 拦截器，重写数组方法

* 首先要知道会改变原数组的方法
	* Push、pop、unshift、shift、splice、sort、reverse
* 当被监听的数组调用这些方法的时候去通知订阅者，所以用方括号&下标方式修改数组是不会触发响应的
* 重写这些方法，在调用数组原生方法前先做一些处理

```js
const arrayProto = Array.prototype;	// 原生的 Array.prototype
const arrayMethods = Object.create(arrayProto); // 拷贝
['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function(method) {
  const original = arrayProto[method];	// 改写原生的方法
  Object.defineProperty(arrayMethods, method, {
    value: function(...args) {
      // TODO 在这里实现 Vue 需要的功能
      return original.apply(this, ...args);
    },
    enumerable: false,
    sritable: true,
    configurable: true
  })
})
```

### 实现响应式 Observer

* 实现 observer 的时候先判断是对象还是数组，如果是数组就把 `__proto__` 改写成自己的 `arrayMethods`： `value.__proto__ = arrayMethods`

### 收集依赖

* 对象的依赖收集是在 `defineReactive` 里，数组的拦截器访问不到，因此 Vue 把依赖收集提前了，放在在 `Observer` 中。把 `Observer` 实例绑到 `value` 的某个属性下，拦截器就可以通过这个属性找到依赖。

### 触发依赖

* 在拦截器里触发依赖（即在上面重写方法的 TODO 位置调用订阅者，即依赖的 `notify` 方法）

### 监听子元素

* `Observer` 中递归

### 监测新增元素

* 在拦截器里对可以添加元素的方法`push`、`unshift`、`splice` 进行判断，如果有新增元素，对新增元素添加 `observer`

# references

* [深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html)

* [响应式对象](https://ustbhuangyi.github.io/vue-analysis/v2/reactive/reactive-object.html)
* [Vue双向绑定原理](https://www.bilibili.com/video/BV1oJ411t7zQ)
* [剖析Vue原理&实现双向绑定MVVM](https://segmentfault.com/a/1190000006599500)

* [Vue2.x双向数据绑定原理-Array篇](https://juejin.im/post/6844903990870687752)











