---
title: ES6：module
date: 2020-03-28 18:51:28
tags: ECMAScript 6 入门
---

# Module 的语法

## 概述

* CommonJS 模块就是对象，输入时必须查找对象属性

```js
// CommonJS模块
let { stat, exists, readFile } = require('fs');

// 等同于
let _fs = require('fs');
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
```

> 整体加载`fs`模块（即加载`fs`的所有方法），生成一个对象（`_fs`），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。

* ES6 模块不是对象，而是通过`export`命令显式指定输出的代码，再通过`import`命令输入

```js
// ES6模块
import { stat, exists, readFile } from 'fs';
```

* 上面代码的实质是从`fs`模块加载 3 个方法，其他方法不加载
* 这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高
* 这也导致了没法引用 ES6 模块本身，因为它不是对象。

## 严格模式

* ES6 的模块自动采用严格模式，不管你有没有在模块头部加上`"use strict";`
* 限制
	* 变量必须声明后再使用
	* 函数的参数不能有同名属性，否则报错
	* 不能使用`with`语句
	* 不能对只读属性赋值，否则报错
	* 不能使用前缀 0 表示八进制数，否则报错
	* 不能删除不可删除的属性，否则报错
	* 不能删除变量`delete prop`，会报错，只能删除属性`delete global[prop]`
	* `eval`不会在它的外层作用域引入变量
	* `eval`和`arguments`不能被重新赋值
	* `arguments`不会自动反映函数参数的变化
	* 不能使用`arguments.callee`
	* 不能使用`arguments.caller`
	* 禁止`this`指向全局对象
	* 不能使用`fn.caller`和`fn.arguments`获取函数调用的堆栈
	* 增加了保留字（比如`protected`、`static`和`interface`）
* ES6 模块之中，顶层的`this`指向`undefined`，即不应该在顶层代码使用`this`

## export 命令

* 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取
* 如果希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量
* 通常情况下，`export`输出的变量就是本来的名字，但是可以使用`as`关键字重命名。重命名后，可以用不同的名字输出两次
* `export`语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值

> `export`命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的`import`命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷

## import 命令

* `import`命令要使用`as`关键字，将输入的变量重命名
* `import`命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口
* 如果是对象，属性可修改，但不建议这样做
* `import`命令具有提升效果，会提升到整个模块的头部，首先执行
	* 本质是，`import`命令是编译阶段执行的，在代码运行之前
* 由于`import`是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构

## 模块的整体加载

* `import * (as xxx) from '...'`

## export default 命令

* `export default xxx` 不需要大括号，`import xxx from '...'` 也不需要大括号

> `export default`命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此`export default`命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应`export default`命令

* 本质上，`export default`就是输出一个叫做`default`的变量或方法，然后系统允许你为它取任意名字

## export 与 import 的复合写法

```js
export { foo, bar } from 'my_module';

// 可以简单理解为
import { foo, bar } from 'my_module';
export { foo, bar };
```

* 写成一行以后，`foo`和`bar`实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，当前模块不能直接使用`foo`和`bar`

## import()

* `import`和`export`命令只能在模块的顶层，不能在代码块之中
* 有利于编译器提高效率，但也导致无法在运行时加载模块
* ES2020 提案引入 `import()` 函数支持动态加载模块



# Module 的加载实现

## 浏览器加载

### 传统方法

* 浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到`<script>`标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间
* 如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载
* `<script>` 标签打开 defer 或 async 属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令

> `defer`与`async`的区别是：`defer`要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；`async`一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。
>
> 一句话，`defer`是“渲染完再执行”，`async`是“下载完就执行”。
>
> 另外，如果有多个`defer`脚本，会按照它们在页面出现的顺序加载，而多个`async`脚本是不能保证加载顺序的

### 加载规则

* 浏览器加载 ES6 模块，也使用 `<script>` 标签，但是要加入 `type="module"` 属性
* `module` 属性都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了``标签的`defer`属性

## ES6 模块与 CommonJS 模块的差异

* CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用
	* 一旦输出一个值，模块内部的变化就影响不到这个值
* CommonJS 模块是运行时加载，ES6 模块是编译时输出接口
	* 生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值
	* ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块