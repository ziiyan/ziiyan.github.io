---
title: 学习笔记：图解HTTP
date: 2020-04-01 20:50:07
tags: 网络
---

# 第一章 了解 Web 及网络基础

## 使用 HTTP 协议访问 Web

Web 是建立在 HTTP 协议上通信的

## HTTP 的诞生

最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的 WWW（World Wide Web，万维网）

* HTML：把 SGML 作为页面的文本标记语言
* HTTP：文档传递协议
* URL：指定文档所在位置

WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。

现在则用来表示这一系列的集合，也可简称为 Web。



## 网络基础 TCP/IP

HTTP 是 TCP/IP 协议族的一个子集

| 应用层 | FTP、DNS、HTTP | HTTP 数据                                   |
| ------ | -------------- | ------------------------------------------- |
| 传输层 | TCP、UDP       | TCP首部（HTTP数据）                         |
| 网络层 | IP 数据包      | IP首部（TCP首部（HTTP数据））               |
| 链路层 | 硬件           | 以太网首部（IP首部（TCP首部（HTTP数据））） |

### IP 协议（负责传输）

* 作用：把各种数据包传送给对方
* IP 地址 ---ARP地址解析协议---> MAC 地址
* 路由选择

### TCP 协议（确保可靠性）

* 作用：提供可靠的字节流服务
	* 字节流服务：为了方便传输，将大块数据分割成报文段（segment）为单位的数据包进行管理
	* 可靠的传输服务：能够确认数据最终是否送达到对方

* 三次握手策略
	* 发送端首先发送一个带有 SYN 标志的数据包给对方
	* 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息
	* 发送端再回传一个带 ACK 标志的数据包

### DNS 服务（负责域名解析）

* 作用：域名 <===> IP 地址

## 各种协议与 HTTP 协议的关系

1. DNS 解析域名，得到对应 IP 地址
2. HTTP 协议生成 HTTP 请求报文
3. TCP 将请求报文分割成报文段
4. IP 协议路由寻址，一边中转一边传送
5. TCP 收到报文段，重组报文段
6. HTTP 队收到的请求进行处理

## URI 和 URL

* URI（Uniform Resource Locator）统一资源标识符

* URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。



# 第二章 简单的 HTTP 协议

* HTTP 协议用于客户端和服务器端之间的通信
* 通过请求和相应的交换达成通信，必须先有请求才有响应

* 请求报文
	* 请求方法
	* 请求 URI
	* 协议版本
	* 可选的请求首部字段
	* 内容实体

* 响应报文
	* 协议版本
	* 状态码（用以解释状态码的原因短语）
	* 可选的响应首部字段
	* 实体主体

## HTTP 是不保存状态的协议

* HTTP 是无状态协议，不保留之前一切的请求或响应报文的信息
	* 为了实现期望的保持状态功能，引入 Cookie 技术

## 请求 URI 定位资源

```
GET http:hackr.jp/index.html HTTP/1.1

GET /index.html HTTP/1.1
Host: hackr.jp
```

* 不是请求具体资源，而是针对服务器端本身的请求 * 代替 URI

```
OPTIONS * HTTP/1.1
```

## HTTP 方法

* GET：获取资源
	* 请求访问已被 URI 识别的资源，资源**经过服务器解析**后返回
* POST：传输实体主体
* PUT：传输文件
	* 请求报文主体中包含文件内容，保存到请求 URI 指定的位置
	* PUT 方法自身不带验证机制，任何人都可以上传，为了安全一般都不用
* HEAD：获得报文首部
	* 类似 GET，不返回报文主体，用于确认 URI 的有效性及资源更新的日期
* DELETE：删除文件
	* 按请求 URI 删除指定的资源
	* 不带验证机制
* OPTIONS（1.1）：询问支持的方法
	* 查询针对请求 URI 指定的资源支持的方法
* TRACE（1.1）：追踪路径
	* 让 Web 服务前端将之前的请求通信环回给客户端
	* 确认请求连接过程中发生的一系列操作
	* 容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，不常用
* CONNECT（1.1）：要求用隧道协议连接代理
	* SSL（Secure Sockets Layer，安全套阶层）
	* TLS（Transport Layer Security，传输层安全）
	* TCP 通信，使用以上两个协议加密

## 持久连接节省通信量

HTTP/1.0 每进行一次 HTTP 通信就要断开一次 TCP 连接；一个网页包含很多资源，TCP 连接建立和断开会增加通信量的开销

### keep-alive

HTTP/1.1 中，只要任意一端没有明确提出断开连接，就保持 TCP 连接状态

### 管线化

从前发送请求后需等待并收到响应才能发送下一个请求

管线化技术出现后，不用等待响应就可以直接发送下一个请求，即能做到同时并行发送多个请求

## Cookie

通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态

Cookie 会根据从服务器端发送端响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去

# 第三章 HTTP 报文内的 HTTP 信息

HTTP 报文本身是由多行数据构成的字符串文本

| 请求报文     | 响应报文     |      |
| ------------ | ------------ | ---- |
| 请求行       | 状态行       | 报   |
| 请求首部字段 | 响应首部字段 | 文   |
| 通用首部字段 | 通用首部字段 |      |
| 实体首部字段 | 实体首部字段 | 首   |
| 其他         | 其他         | 部   |
| （空行）     | （空行）     |      |
| 报文主体     | 报文主体     |      |

### 报文主体和实体主体的差异

* 报文（message）：是 HTTP 通信中的基本单位，由 8 位组字节流组成，通过 HTTP 通信传输
* 实体（enentity）：作为请求或响应的有效载荷数据（补充项）被传输，内容由实体首部和实体主体组成

实体首部是报文首部的一部分（看上面的表格）

一般情况下，实体主体等于报文主体。传输过程中，为了提升传输速率，会对报文主体进行编码，这样报文主体就和实体主体不同了。

### 内容编码（压缩传输）

* **内容编码**指明应用在实体内容上的编码格式。客户端接收并负责解码。
* 常用的内容编码
	* gzip（GNU zip）
	* compress（UNIX 系统的标准压缩）
	* deflate（zlib）
	* identity（不进行编码）

### 分块传输编码

在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。

通过把数据分割成多块，能够让浏览器逐步显示页面。

这种把实体主体分块的功能称为**分块传输编码**。

## 多部分对象集合（发送多种数据）

* multipart/form-data：Web表单文件上传
* multipart/byteranges：状态码 206，响应报文包含多个范围的内容

使用多部分对象集合时，需要在首部字段加上 Content-type

使用 boundary 字符串来划分多部分对象集合指明的各类实体

## 范围请求（断点重传）

* 从之前下载的中断处恢复下载，仅下载指定的实体范围，称为**范围请求**
* 首部字段 Range 来指定资源的 byte 范围
* 针对范围请求，响应会返回状态码为 206 的响应报文
	* 如果是多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges
* 如果无法响应范围请求，会返回 200 和完整的实体内容

## 内容协商

**内容协商机制**指客户端和服务器端就响应的资源内容进行交涉，提供最合适的资源

* 基准：语言、字符集、编码方式等
	* Accept
	* Accept-Charset
	* Accept-Encoding
	* Accept-Language
	* Content-Language
* 内容协商技术类型
	* 服务器驱动协商
		* 以请求的首部字段为参考，在服务器端自动处理，不一定筛出最优内容
	* 客户端驱动协商
		* 用户从浏览器显示的可选项列表中手动选择
		* 利用 js 脚本在 Web 页面上进行选择
	* 透明协商



# 第四章 返回结果的 HTTP 状态码

* 状态码的指责是当客户端向服务器端发送请求时，描述返回的请求结果

|      | 类别          | 原因短语                   |
| ---- | ------------- | -------------------------- |
| 1xx  | Informational | 接收的请求正在处理         |
| 2xx  | Success       | 请求正常处理完毕           |
| 3xx  | Redirection   | 需要进行附加操作以完成请求 |
| 4xx  | Client Error  | 服务器无法处理请求         |
| 5xx  | Server Error  | 服务器处理请求出错         |

* 2xx 成功
	* 200 OK
	* 204 No Content
	* 206 Partial Content
* 3xx 重定向
	* 301 Moved Permanently 永久性重定向，建议用户修改书签
	* 302 Found 临时性重定向，希望用户（本次）能使用新的 URI 访问
	* 303 See Other 请求对应的资源存在另一个 URI，且明确用 GET 访问
	* 304 Not Modified 客户端发送附带条件的请求时，服务器端允许请求访问资源
		* If-Match
		* If-Modified-Since
		* If-None-Match
		* If-Range
		* If-Unmodified-Since
	* 307 Temporary Redirect 临时重定向
* 4xx 客户端错误
	* 400 Bad Request 报文中存在语法错误
	* 401 Unauthorized 发送的请求需要有通过 HTTP 认证的认证信息
	* 403 Forbidden 该状态码表明对请求资源的访问呗服务器拒绝了
	* 404 Not Found 服务器上无法找到请求的资源
* 5xx 服务器错误
	* 500 Internal Server Error 服务器端在执行请求时发生了错误
	* 503 Service Unavailable 超负载或停机维护，无法处理请求



# 第五章 与 HTTP 协作的 Web 服务器

* 通信数据转发程序
	* 代理
		* 转发功能的应用程序，不改变 URI
		* 好处
			* 利用缓存技术减少网络带宽的流量
			* 组织内部针对特定网站的访问控制
			* 获取访问日志
		* 分类
			* 缓存代理
			* 透明代理：不对报文做任何加工
	* 网关
		* 转发其他服务器通信数据的服务器
		* 好处
			* 利用网关可以由 HTTP 请求转化为其他协议通信
	* 隧道
		* 按要求建立一条与其他服务器的通信线路，使用 SSL 等加密手段进行通信
		* 目的
			* 确保通信安全
		* 隧道本身不去解析 HTTP 请求

## 缓存

* 缓存是指代理服务器或客户端本地磁盘内保存的资源副本
	* 利用缓存可减少对源服务器的访问，节省了通信流量和通信时间
* 缓存过期后，会向源服务器确认资源的有效性
* 若缓存失效，浏览器会再次请求新资源

# 第六章 HTTP 首部

## 报文首部

### HTTP 请求报文

* 报文首部
	* 请求行：方法、URI、HTTP 版本
	* HTTP 首部字段
		* 请求首部字段
		* 通用首部字段
		* 实体首部字段
		* 其他
* 空行
* 报文主体

### HTTP 响应报文

* 报文首部
	* 状态行：HTTP 版本、状态码
	* HTTP 首部字段
		* 响应首部字段
		* 通用首部字段
		* 实体首部字段
		* 其他
* 空行
* 报文主体

## HTTP 首部字段

* 首部字段名：字段值

```
Content-Type: text/html
```

### 分类

* 通用首部字段
* 请求首部字段
* 响应首部字段
* 实体首部字段

非 HTTP/1.1 首部字段

* Cookie
* Set-Cookie
* Content-Disposition

#### 通用首部字段

* Cache-Control：控制缓存行为
* Connection：控制不再转发给代理的首部字段；管理持久连接
* Date：创建 HTTP 报文的日期和时间
* Pragma：向后兼容；要求所有的中间服务器不返回缓存的资源
* Trailer：报文主体后记录了哪些首部字段
* Transfer-Encoding：传输时的编码方式
* Upgrade：检测 HTTP 协议及其他协议是否可使用更高的版本进行通信
* Via：追踪传输路径
* Warning：缓存相关问题的警告

#### 请求首部字段

* Accept：用户代理支持的媒体类型及优先级
* Accept-Charset：用户代理支持的字符集及优先级
* Accept-Encoding：用户代理支持的内容编码及优先级
	* gzip
	* compress
	* deflate
	* identity
* Accept-Language：用户代理支持的自然语言集及优先级
* Authorization：
* Expect：期望出现的某种特定行为
* From：电子邮件地址
* Host：请求的资源所处的互联网主机名和端口号；如果未设置主机名发送空
* If-xxx：条件请求，判断为真才执行
	* IF-Match：字段值跟 ETag 值匹配一致时才接受请求
	* If-Modified-Since：字段值（日期）之后资源更新，接受请求
	* If-None-Match：字段值跟 ETag 值不一致时才接受请求
	* If-Range：字段值（ETag或时间）和请求资源（ETag 值或时间）相一致时，作为范围请求处理，否则返回全体资源

#### 响应字段首部

* Accept-Ranges
* Age
* ETag：实体资源的唯一标识，中英文是同一个
	* 强 ETag：细微变化都会改变
	* 弱 ETag：只用于提示资源是否相同，资源发生根本改变产生差异时才改变 ETag 值
* Location
* Proxy-Authenticate
* Retry-After
* Server
* Vary

#### 实体首部字段

* Allow
* Content-Encoding
* Content-Language
* Content-Length
* Content-Location
* Content-MD5
* Content-Range
* Content-Type
* Expires：资源失效的日期
* Last-Modified：资源最终修改的时间

#### 为 Cookie服务的首部字段

| 首部字段名 | 说明                             | 首部类型     |
| ---------- | -------------------------------- | ------------ |
| Set-Cookie | 开始状态管理所使用的 Cookie 信息 | 响应首部字段 |
| COokie     | 服务器接收到的 Cookie 信息       | 请求首部字段 |



# 第七章 确保 Web 安全的 HTTPS

## HTTP 的缺点

* 明文，内容会被窃听	
* 不验证身份，会被伪装
* 无法验证完整性，可能被篡改

未加密协议都会存在这类问题

#### 明文

* TCP/IP 是可能被窃听的网络
	* 抓包工具
* 加密处理防止被窃听
	* 通信的加密
		* SSL
		* TLS
	* 内容的加密

#### 验证身份

* 任何人都可以发起请求，服务器收到请求都会返回响应

* 查明对手的证书：SSL

#### 完整性

* 遭遇篡改，MITM 中间人攻击
* 防止篡改
	* MD5 和 SHA-1等散列值校验
	* 数字签名

## HTTPS = HTTP + 加密 + 认证 + 完整性保护

* 公钥加密，私钥解密
* 公钥加密与共享密钥加密相比，处理速度要慢
* HTTPS 采用混合加密机制
	* 使用公钥加密方式交换共享密钥
	* 之后的通信使用共享密钥加密
* 证书证明公钥的有效性

# 第八章 确认访问用户身份的认证

## BASIC 认证（基本认证）

1. 请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Reuired，返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式（BASIC）及 Request-URI 安全域字符串（realm）
2. 接收到状态码 401 的客户端，需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（：）连接后，再经过 Base64 编码处理。
3. 收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。

## DIGEST 认证（摘要认证）

1. 请求的资源需要 DIGEST 认证时，服务器会随状态码 401 Authorization Reuired，返回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce）
2. 接收到状态码 401 的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息，包括 username、realm、nonce、uri、response 字段。
	* realm、nonce 是从服务端得到
	* username 是 realm 限定范围内可进行认证等用户名
	* uri 即 Request-URI
	* response 存放经过 MD5 运算后的密码字符串，形成响应码
3. 收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。

## SSL 客户端认证

客户端事先安装证书

1. 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书。
2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。
3. 服务器验证客户端证书，验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。

### 双因素认证

* 证书认证 -> 认证客户端计算机

* 表单认证 -> 认证用户本人的行为

## 基于表单认证

* 一般用 Cookie 来管理 Session
* 通过服务器端的 web 应用，将客户端发送过来的用户 ID 和密码与之前登录过的信息做匹配来进行认证的

1. 客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS 通信来进行 HTML 表单画面的显示和用户输入数据的发送。
2. 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 Session ID。
3. 客户端接收到从服务端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。

# 第九章 基于 HTTP 的功能追加协议

### HTTP 的瓶颈

* 一条连接上只可发送一个请求
* 请求只能从客户端开始，客户端不可以接收响应意外的指令
* 请求/响应首部未经压缩就发送。首部信息越多延迟越大
* 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。
* 可任意选择数据压缩格式。非强制压缩发送。

#### Ajax

* Asynchronous JavaScript and XML
* 有效利用 JavaScript 和 DOM 的操作，达到局部 Web 页面替换加载的异步通信手段
* 和以前的同步通信相比，只更新一部分页面，**传输的数据量减少**
* Ajax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 的调用就能和服务器进行 HTTP 通信

#### Comet

* Comet 先将响应挂起，当服务器端后更新再返回。模拟服务器端向客户端推送的功能。
* **内容实时更新**，为了维持连接会消耗更多的资源

## SPDY

* 没有完全改写 HTTP 协议
* 在 TCP/IP 的应用层与传输层之间通过新加会话层的形式运作
* 为了安全规定使用 SSL
* 好处
	* 多路复用流
	* 赋予请求优先级
	* 压缩 HTTP 首部
	* 推送功能
	* 服务器提示功能
* 缺点
	* 单个域名的通信多路服用，一个 Web 网址上使用多个域名下的资源，改善效果有限

## WebSocket

* Web 浏览器与 Web 服务器之间全双工通信标准
* 建立在 HTTP 基础上，发起方仍是客户端，一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方可以直接向对方发送报文。
* 特点
	* 推送功能
	* WebSocket 首部信息很小，减少通信量

为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次握手。

* 握手·请求
	* HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，达到握手的目的。
	* Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值
	* Sec-WebSocket-Protocol 字段内记录使用的子协议
* 握手·响应
	* 返回状态码 101 Switching Protocols
	* Sec-WebSocket-Accept 字段值是由握手请求中的 Sec-WebSocket-Key 的自动值生成的

## HTTP/2.0

* 目标是改善用户在使用 Web 时的速度体验

## Web 服务器管理文件的 WebDAV

* Web-based Distributed Authoring and Versioning
* 可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统

# 第十章 构建 Web 内容的技术

* HTML（HyperText Markup Language）
* CSS（Cascading Style Sheets）
* JavaScript
* JSON（JavaScript Object Notation）

# 第十一章 Web 的攻击技术

* HTTP 不具备必要的安全功能
* HTTP 请求可以在客户端自由地修改
	* 在报文内加载攻击代码
		* URL 查询字段或表单、HTTP 首部、Cookie 等途径

### 针对 Web 应用的攻击模式

* 以服务器为目标的主动攻击

	* 把攻击代码传入的攻击模式
	* 代表
		* SQL 注入攻击
		* OS 命令注入攻击

* 以服务器为目标的被动攻击
	* 利用圈套策略执行攻击代码的攻击模式
		1. 诱使用户触发已经设置好的陷阱，陷阱会自动发送已嵌入攻击代码的 HTTP 请求
		2. 当用户不知不觉中招后，用户的浏览器或邮件客户端救护触发这个陷阱
		3. 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码
		4. 执行完攻击代码，存在安全漏洞的 Web 应用会成为攻击者的跳板，可能导致用户所持的 Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果

	* 代表
		* XSS 跨站脚本攻击
		* 跨站点请求伪造

### 因输入值转义不完全引发的安全漏洞

* XSS 跨站脚本攻击
	* 在 html 中注入 js 代码使得用户在表单中输入的账户密码会发送到攻击者的网站
* SQL 注入攻击
	* 针对数据库，传入非法的 SQL 让服务器执行，可能导致非法浏览和篡改
* OS 命令注入攻击
	* 通过 Web 应用，执行非法的操作系统命令
* HTTP 首部注入攻击
	* 攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击
		* 比如 Cookie 信息、重定向 URL
* 目录遍历攻击
	* 对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的
* 远程文件包含漏洞
	* 当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当以来文件，让脚本读取之后，就可以运行任意脚本的一种攻击

### 因设置或设计上的缺陷引发的安全漏洞

* 强制浏览
* 不正确的错误消息处理
* 开放重定向

### 因会话管理疏忽引发的安全漏洞

* 会话劫持
	* 攻击者通过某种手段拿到用户的会话 ID，并非法使用此会话 ID 伪装成用户
* 会话固定攻击
* 跨站点请求伪造
	* 攻击者通过设置好的陷阱

### 其他安全漏洞

* 密码破解
* 点击劫持
	* 利用透明按钮覆盖在 Web 页面上，让用户点击，又称界面伪装
* DoS 攻击
	* 让运行中的服务呈停止状态的攻击
* 后门程序

