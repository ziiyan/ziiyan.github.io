<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        第二十二章 高级技巧 - undefined
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> life kicks in right now </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>ziiyan</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第二十二章-高级技巧"><span class="toc-text">第二十二章 高级技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#高级函数"><span class="toc-text">高级函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安全的类型检测"><span class="toc-text">安全的类型检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域安全的构造函数"><span class="toc-text">作用域安全的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#惰性载入函数"><span class="toc-text">惰性载入函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数绑定-bind"><span class="toc-text">函数绑定 bind()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数柯里化"><span class="toc-text">函数柯里化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#防篡改对象"><span class="toc-text">防篡改对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高级定时器"><span class="toc-text">高级定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重复的定时器"><span class="toc-text">重复的定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Yielding-Processes"><span class="toc-text">Yielding Processes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数节流-throttle"><span class="toc-text">函数节流 throttle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义事件"><span class="toc-text">自定义事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拖放"><span class="toc-text">拖放</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> life kicks in right now </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        第二十二章 高级技巧
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-03-14 17:27:55</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#JavaScript高级程序设计" title="JavaScript高级程序设计">JavaScript高级程序设计</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="第二十二章-高级技巧"><a href="#第二十二章-高级技巧" class="headerlink" title="第二十二章 高级技巧"></a>第二十二章 高级技巧</h1><h2 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h2><h3 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h3><p><code>Object.toString()</code> 方法返回一个 <code>[object NativeConstructorName]</code> 格式的字符串。每个类内部都有一个 <code>[[Class]]</code> 属性，指定了上述字符串中的构造函数名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(value);</span><br><span class="line"><span class="comment">// "[object Array]"</span></span><br></pre></td></tr></table></figure>

<p>开发人员定义的构造函数返回 <code>object Object</code>。</p>
<h3 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h3><ul>
<li><p>当 new 调用构造函数时，构造函数内用到的 this 对象会指向新创建的对象实例。</p>
</li>
<li><p>如果不用 new，this 会映射到全局对象 widow 上，导致属性被添加到全局。</p>
</li>
<li><p>解决：构造函数内部检查 this 对象是否正确</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(name, age, job);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h3><p>函数执行的分支只执行一次</p>
<ul>
<li>函数被调用时处理<ul>
<li>第一次调用时用合适函数覆盖原来的函数<ul>
<li>例如检查浏览器是否支持某功能，执行一次就行</li>
</ul>
</li>
<li>在声明时就指定适当函数<ul>
<li>加载时损失性能，执行时不会</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="函数绑定-bind"><a href="#函数绑定-bind" class="headerlink" title="函数绑定 bind()"></a>函数绑定 bind()</h3><p>创建一个函数，可以在特定的 this 环境中以指定参数调用另一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  message: <span class="string">"Event handled"</span>,</span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"my-btn"</span>);</span><br><span class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, handler.handleClick);</span><br><span class="line"><span class="comment">// 由于没有保存 handler.handleClick() 的执行环境</span></span><br><span class="line"><span class="comment">// this 指向 DOM 按钮而非 handler</span></span><br><span class="line"><span class="comment">// 本来应该显示 “Event handled”，会显示 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用闭包解决：</span></span><br><span class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  handler.handleClick(event);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind() 可以将函数绑定到指定环境的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EventUtil.addHandler(btn, <span class="string">"click"</span>, bind(handler,handleClick, handler));</span><br></pre></td></tr></table></figure>



<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><ul>
<li>用于创建已经设置好了一个或多个参数的函数</li>
<li>基本方法和函数绑定一样：使用一个闭包返回一个函数</li>
<li>区别在于：函数被调用时，返回的函数还需要设置一些传入的参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.all(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context, finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="防篡改对象"><a href="#防篡改对象" class="headerlink" title="防篡改对象"></a>防篡改对象</h2><p>一旦把对象定义为防篡改，就无法撤销了</p>
<ul>
<li><code>Object.preventExtensions()</code> 不可扩展对象<ul>
<li>无法添加新属性和方法</li>
<li>已有成员可以修改/删除</li>
</ul>
</li>
<li><code>Object.seal()</code> 密封对象<ul>
<li>不可扩展</li>
<li>不能删除</li>
<li>可以修改</li>
</ul>
</li>
<li><code>Object.freeze()</code> 冻结对象<ul>
<li>不可扩展</li>
<li>密封</li>
<li><code>[[Writable]]</code> 设置为 false，若定义 <code>[[Set]]</code> 属性可写</li>
</ul>
</li>
</ul>
<h2 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h2><ul>
<li><p>定时器不是线程</p>
</li>
<li><p>Javascript 运行于单线程环境中</p>
</li>
<li><p>定时器是计划代码在未来的某个时间执行，执行时机不能保证</p>
</li>
<li><p>因为在页面的生命周期中，不同时间可能有其他代码在控制 Javascript 进程</p>
</li>
<li><p>在页面下载完后的代码运行、事件处理程序、Ajax 回调函数都必须使用同样的线程来执行</p>
</li>
<li><p>浏览器负责进行排序，指派某段代码在某个时间点运行的优先级</p>
</li>
<li><p>除了主 JavaScript 执行进程外，还有一个需要在进程下一次空闲时执行的代码队列</p>
</li>
<li><p>没有任何代码是立即执行的，但一旦进程空闲则尽快执行</p>
</li>
<li><p>定时器时间过去时，将代码插入队列末尾</p>
<ul>
<li>若队列不空，则仍需等待</li>
<li>若主 JavaScript 执行进程正在执行，也仍需等待</li>
</ul>
</li>
</ul>
<h3 id="重复的定时器"><a href="#重复的定时器" class="headerlink" title="重复的定时器"></a>重复的定时器</h3><p>当使用 <code>setInterval()</code> 仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中</p>
<ul>
<li>某些间隔会被跳过</li>
<li>多个定时器的代码执行之间的间隔可能会比预期小</li>
</ul>
<p>解决：链式 <code>setTimeout()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">  setTimeout(<span class="built_in">arguments</span>.callee, interval);</span><br><span class="line">&#125;, interval);</span><br></pre></td></tr></table></figure>

<h3 id="Yielding-Processes"><a href="#Yielding-Processes" class="headerlink" title="Yielding Processes"></a>Yielding Processes</h3><p>如果代码运行超过特定的时间或者特定语句数量就不会让它继续执行</p>
<p>展开循环前，思考：</p>
<ul>
<li>该处理是否必须同步完成？</li>
<li>数据是否必须按顺序完成？</li>
</ul>
<p>如果答案都为否，可以使用<strong>数组分块</strong>技术</p>
<ul>
<li>为要处理的项目创建一个队列，使用定时器取出下一个要处理的项目，再设置另一个定时器</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params">array, process, context</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> item = array.shift();</span><br><span class="line">    process.call(context, item);</span><br><span class="line">    <span class="keyword">if</span> (array.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流 throttle"></a>函数节流 throttle</h3><ul>
<li><p>DOM 操作比非 DOM 交互需要更多的内存和 CPU 时间</p>
</li>
<li><p>连续尝试进行过多的 DOM 相关操作可能会导致浏览器挂起，甚至崩溃。例如 onresize 调整浏览器大小</p>
</li>
<li><p>防止连续触发，使用定时器进行<strong>节流</strong></p>
</li>
<li><p>基本思想</p>
<ul>
<li>某些代码不可以在没有间断的情况连续重复执行</li>
<li>第一次调用函数时，创建一个定时器，在指定的时间间隔之后运行代码</li>
<li>第二次调用函数时，清除前一次的定时器，并设置另一个<ul>
<li>如果前一次的定时器已经执行，这个操作无意义</li>
<li>如果前一次的定时器还未执行，就是替换新定时器</li>
</ul>
</li>
<li>目的是只有在执行函数的请求停止了一段时间之后才执行</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> processor = &#123;</span><br><span class="line">  timeoutId: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 实际进行处理的方法</span></span><br><span class="line">  performPorcessing: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 初始处理调用的方法</span></span><br><span class="line">  process: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.timeoutId);</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      that.performProcessing();</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 尝试开始执行</span></span><br><span class="line">processor.process();</span><br></pre></td></tr></table></figure>

<p>简化的 <code>throttle()</code>函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">method, context</span>) </span>&#123;</span><br><span class="line">  clearTimeout(method.tId);</span><br><span class="line">  method.tId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    method.call(context);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><ul>
<li><p>事件是 Javascript 与浏览器交互的主要途径</p>
</li>
<li><p>事件是观察者模式，一种创建松散耦合代码的技术</p>
</li>
<li><p>观察者模式有两类对象组成</p>
<ul>
<li>主体<ul>
<li>发布事件</li>
<li>不知道观察者的存在，独立运行</li>
</ul>
</li>
<li>观察者<ul>
<li>通过订阅事件来观察主体</li>
<li>知道主体并能注册事件的回调函数（事件处理程序）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><ul>
<li>创建一个绝对定位的元素，使其可以用鼠标移动</li>
</ul>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud" target="_blank" rel="noopener">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.xml"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
