<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>life kicks in right now</title>
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">life kicks in right now</a>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
        <li class="menu-item">
          <a href="https://github.com/ziiyan" target="_blank" rel="noopener" class="menu-item-link">Github</a>
        </li>
      
    </ul>
  </nav>
</header>
      <main class="main">
        <article class="post">
  <div class="post-title">
    <h2 class="title">第二十三章 离线应用与客户端存储</h2>
  </div>
   <div class="post-meta">
    <span class="post-time">2020-03-14</span>
  </div>
  <div class="post-content">
    <h1 id="第二十三章-离线应用与客户端存储"><a href="#第二十三章-离线应用与客户端存储" class="headerlink" title="第二十三章 离线应用与客户端存储"></a>第二十三章 离线应用与客户端存储</h1><p>离线 Web 应用：设备不能上网的情况下仍然可以运行的应用</p>
<h2 id="离线检测"><a href="#离线检测" class="headerlink" title="离线检测"></a>离线检测</h2><ul>
<li><code>navigator.onLine</code> 属性</li>
</ul>
<ul>
<li>应用缓存</li>
</ul>
<h2 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h2><ul>
<li>appache 从浏览器的缓存中分出一块缓存区<ul>
<li>使用一个<strong>描述文件(manifest file)</strong>，列出要下载和缓存的资源</li>
<li>将描述文件与页面关联起来，可以在 <code>html</code> 中的 <code>manifest</code> 属性指定文件路径</li>
</ul>
</li>
<li>applicationCache 对象</li>
</ul>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h3><ul>
<li>要求服务器对任意 HTTP 请求发送 Set-Cookie HTTP 作为响应的一部分，其中包含会话信息</li>
</ul>
<blockquote>
<p>如：</p>
<p>HTTP/1.1 200 OK</p>
<p>Content-type: text / html</p>
<p>Set-Cookie: name = value</p>
<p>Other-header: other-header-value</p>
</blockquote>
<ul>
<li><p>限制</p>
<ul>
<li>Cookie 在性质上是绑定在特定的域名下的</li>
<li>当设定了一个 cookie 后，再给创建它的域名发送请求时，都会包含这个 cookie</li>
<li>确保 cookie 中的信息只能让批准的接受者访问，而无法被其他域访问</li>
</ul>
</li>
<li><p>构成</p>
<ul>
<li>名称：不区分大小写（实践最好区分），经过 URL 编码</li>
<li>值：URL 编码</li>
<li>域：有效域</li>
<li>路径：对于指定的路径，应该向服务器发送 cookie<ul>
<li>若指定 <a href="http://www.wrox.com/books/，就不会给" target="_blank" rel="noopener">http://www.wrox.com/books/，就不会给</a> <a href="http://www.wrox.com" target="_blank" rel="noopener">http://www.wrox.com</a> 发送 cookie</li>
</ul>
</li>
<li>失效时间：cookie 何时应该被删除的时间戳</li>
<li>安全标志：指定后之后 SSL 连接时才发送到服务器</li>
</ul>
</li>
<li><p>JS 中的 cookie</p>
<ul>
<li>BOM 的 document.cookie 属性</li>
</ul>
</li>
<li><p>子 cookie</p>
<ul>
<li><p>存放在单个 cookie 中的更小段的数据</p>
</li>
<li><p>使用 cookie 值来存储多个名称值对</p>
</li>
<li><blockquote>
<p>如 name=name1=value1&amp;name2=value2&amp;name3=value3&amp;name4=value4&amp;name5=value5</p>
</blockquote>
</li>
<li><p>查询字符串的格式进行格式化</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>所有的 cookie 都会由浏览器作为请求头发送，所以在 cookie 中存储大量信息会影响到特定域的请求性能</p>
</blockquote>
<h3 id="Web-存储机制"><a href="#Web-存储机制" class="headerlink" title="Web 存储机制"></a>Web 存储机制</h3><ul>
<li>Web Storage 的两个主要目标<ul>
<li>提供一种在 cookie 之外存储会话数据的途径</li>
<li>提供一种存储大量可以跨会话存在的数据的机制</li>
</ul>
</li>
</ul>
<h5 id="Storage-类型"><a href="#Storage-类型" class="headerlink" title="Storage 类型"></a>Storage 类型</h5><ul>
<li>只能存储字符串</li>
<li>提供最大的存储空间</li>
<li><code>clear()</code></li>
<li><code>getItem(name)</code></li>
<li><code>key(index)</code></li>
<li><code>removeItem(name)</code></li>
<li><code>setItem(name, value)</code></li>
</ul>
<h5 id="sessionStorage-对象"><a href="#sessionStorage-对象" class="headerlink" title="sessionStorage 对象"></a>sessionStorage 对象</h5><ul>
<li>Storage 的一个实例</li>
<li>存储特定于某个会话的数据，只保持到浏览器关闭<ul>
<li>如果浏览器支持，崩溃重启可以继续使用</li>
</ul>
</li>
<li>可以跨越页面刷新而存在</li>
<li>存储在 sessionStorage 的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制</li>
</ul>
<h5 id="globalStorage-对象"><a href="#globalStorage-对象" class="headerlink" title="globalStorage 对象"></a>globalStorage 对象</h5><ul>
<li>不是 Storage 实例，globalStorage[“xxx.com”] 才是 Storage 的实例</li>
<li>跨越会话存储数据，有特定的访问限制</li>
<li>如果不删除，或者用户未清除浏览器缓存，存储在 globalStorage 属性中的数据会一直保留在磁盘上</li>
<li>合在客户端存储文档或者长期保存用户偏好设置</li>
</ul>
<h5 id="localStorage-对象"><a href="#localStorage-对象" class="headerlink" title="localStorage 对象"></a>localStorage 对象</h5><ul>
<li>Storage 实例，用法与 sessionStorage 相同</li>
<li>取代 globalStorage，不用设置规则</li>
<li>同域名、同协议、同端口</li>
<li>保留到通过 JavaScript 删除或者是用户清除浏览器缓存</li>
</ul>
<h5 id="storage-事件"><a href="#storage-事件" class="headerlink" title="storage 事件"></a>storage 事件</h5><ul>
<li>修改 Storage 对象会在文档上触发 storage 事件</li>
</ul>
<h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><ul>
<li>浏览器中保存结构化数据的一种数据库</li>
<li>替代被废弃的 Web SQL Database API</li>
<li>创建一套 API，方便保存和读取 JavaScript 对象，同时还支持查询及搜索</li>
<li>异步</li>
<li>做为全局对象 windows.indexedDB，具体名称根据浏览器不同</li>
</ul>
<h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><ul>
<li>用对象保存数据，而不是用表来保存</li>
<li>一个 IndexedDB 数据库，就是一组位于相同命名空间下的对象的集合</li>
<li>indexDB.open() 创建/打开</li>
<li>返回 IDBRequest 对象<ul>
<li>onerror</li>
<li>onsuccess</li>
</ul>
</li>
</ul>
<h5 id="对象存储空间"><a href="#对象存储空间" class="headerlink" title="对象存储空间"></a>对象存储空间</h5><ul>
<li>可以把这里的对象存储空间(object storge)想象成表，把其中保存的对象想象成表中的记录</li>
<li><code>add()</code></li>
<li><code>put()</code></li>
</ul>
<h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><ul>
<li>读取或修改数据都要通过事务来组织所有操作</li>
<li>使用事务可以直接通过已知的键检索单个对象</li>
</ul>
<h5 id="使用游标查询"><a href="#使用游标查询" class="headerlink" title="使用游标查询"></a>使用游标查询</h5><ul>
<li>需要检索多个对象的情况下，需要在事务内 部创建游标</li>
<li>与传统数据库查询不同<ul>
<li>游标不提前收集结果</li>
<li>游标指针会先指向结果中的第一项，在接到查找下一项的指令时指向下一项</li>
</ul>
</li>
</ul>
<h5 id="键范围"><a href="#键范围" class="headerlink" title="键范围"></a>键范围</h5><h5 id="设定游标方向"><a href="#设定游标方向" class="headerlink" title="设定游标方向"></a>设定游标方向</h5>
  </div>
</article>
      </main>
    </div>
  </body>
</html>