<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>life kicks in right now</title>
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">life kicks in right now</a>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
        <li class="menu-item">
          <a href="https://github.com/ziiyan" target="_blank" rel="noopener" class="menu-item-link">Github</a>
        </li>
      
    </ul>
  </nav>
</header>
      <main class="main">
        <article class="post">
  <div class="post-title">
    <h2 class="title">第二十一章 Ajax与Comet</h2>
  </div>
   <div class="post-meta">
    <span class="post-time">2020-03-13</span>
  </div>
  <div class="post-content">
    <p>AJAX - Asynchronous JavaScript + XML</p>
<p>向服务器请求额外的数据而无须卸载页面</p>
<p>核心是 XMLHttpRequest 对象，简称 XHR</p>
<p>使用 XHR 对象取得新数据，通过 DOM 将新数据插入页面</p>
<h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>

<h3 id="XHR的用法"><a href="#XHR的用法" class="headerlink" title="XHR的用法"></a>XHR的用法</h3><ol>
<li><code>open(请求类型, URL, 是否异步)</code><ul>
<li>get / post</li>
<li>相对于当前页面 / 绝对路径</li>
<li>Boolean</li>
</ul>
</li>
<li><code>send(请求主体)</code><ul>
<li>无内容则传入 null</li>
</ul>
</li>
<li>收到响应后，自动填充 XHR 对象的属性<ul>
<li><code>responseText</code> 做为响应主体</li>
<li><code>responseXML</code> “text/xml” 或 “application/xml”</li>
<li><code>status</code> 响应的 HTTP 状态<ul>
<li>200 成功，responseText 就绪 </li>
<li>304 资源未修改，可使用缓存</li>
</ul>
</li>
<li><code>statusText</code> HTTP 状态的说明</li>
<li><code>readyState</code> 异步请求的活动阶段<ul>
<li>0 位初始化</li>
<li>1 启动</li>
<li>2 发送</li>
<li>3 接收</li>
<li>4 完成</li>
<li>值每次改变都触发 <code>readystatechange</code> 事件</li>
</ul>
</li>
<li>收到响应前调用 <code>abort()</code> 取消异步请求</li>
</ul>
</li>
</ol>
<h3 id="HTTP头部信息"><a href="#HTTP头部信息" class="headerlink" title="HTTP头部信息"></a>HTTP头部信息</h3><p>XHR 提供操作请求头部和响应头部信息的方法</p>
<p>默认情况，发送 XHR 请求的同时还会发送以下头部信息</p>
<ul>
<li>Accept：浏览器能够处理的内容类型</li>
<li>Accept-Charset：浏览器能够显示的字符集</li>
<li>Accept-Encoding：浏览器能够处理的压缩编码</li>
<li>Accept-Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cookie：当前页面设置的任何 Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发出请求的页面的 URI</li>
<li>User-Agent：浏览器的用户代理字符串</li>
</ul>
<ul>
<li><p><code>setRequestHeader(头部字段名称，头部字段值)</code> </p>
<ul>
<li>设置自定义的请求头部信息</li>
<li>open 之后 send 之前</li>
</ul>
</li>
<li><p><code>getRequestHeader(头部字段名称)</code></p>
</li>
<li><p><code>getAllResponseHeaders()</code></p>
</li>
</ul>
<h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><p>每个参数的名称和值必须使用 <code>encodeURIComponent()</code> 编码才能放到 URL 末尾，所有名-值对都由 &amp; 分隔</p>
<h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><p><code>serialize()</code> 格式化数据</p>
<h2 id="XMLHttpRequest-2-级"><a href="#XMLHttpRequest-2-级" class="headerlink" title="XMLHttpRequest 2 级"></a>XMLHttpRequest 2 级</h2><ul>
<li>FormData 序列化表单</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(键, 值);</span><br></pre></td></tr></table></figure>

<ul>
<li>超时设定 <code>timeout</code>属性</li>
</ul>
<p>open 之后 send 之前设定，请求在等待响应多少毫秒之后停止</p>
<p>触发 timeout 事件，调用 ontimeout 事件处理程序</p>
<ul>
<li><code>overrideMimeType()</code> 方法</li>
</ul>
<p>重写 XHR 响应的 MIME 类型，send 之前调用</p>
<h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><ul>
<li>loadstart：接收到响应数据的第一个字节时触发</li>
<li>progress：接收响应期间不断地触发</li>
<li>error：请求发生错误时触发</li>
<li>abort：在因为调用 abort() 方法而终止连接时触发</li>
<li>load：在接收到完整的响应数据时触发</li>
<li>loaded：在通信完成或者触发 error、abort 或 load 事件后触发</li>
</ul>
<h2 id="跨资源共享-CORS"><a href="#跨资源共享-CORS" class="headerlink" title="跨资源共享 CORS"></a>跨资源共享 CORS</h2><p>基本思想：使用自定义的 HTTP 头部让浏览器与服务器进行沟通</p>
<p>发送：<code>Origin：http://www...</code></p>
<p>接收：<code>Access-Control-Allow-Origin：http://www...</code></p>
<ul>
<li><p>在 XHR 对象的 open 中传入绝对 URL 可以请求跨域，：限制</p>
<ul>
<li>不能使用 setRequestHeader() 设置自定义头部</li>
<li>不能发送和接收 cookie</li>
<li>调用 getAllResponseHeaders() 会返回空字符串</li>
</ul>
</li>
<li><p>Preflighted Requests 透明服务器验证机制</p>
<ul>
<li>发送<ul>
<li>Origin：与简单的请求相同</li>
<li>Access-Control-Request-Method:请求自身使用的方法</li>
<li>Access-Control-Request-Headers:(可选)自定义的头部信息，多个头部以逗号分隔</li>
</ul>
</li>
<li>接收<ul>
<li>Access-Control-Allow-Origin：与简单的请求相同</li>
<li>Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔</li>
<li>Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔</li>
<li>Access-Control-Max-Age：应该将这个 Preflight 请求缓存多长时间(以秒表示)</li>
</ul>
</li>
</ul>
</li>
<li><p>带凭据的请求</p>
<ul>
<li>默认跨源请求不提供凭据（cookie、HTTP 认证及客户端 SSL 证明）</li>
<li>将 withCredentials 属性设置为 true 可以指定某个请求应该发送凭据</li>
<li>响应：<code>Access-Control-Allow-Credentials: true</code></li>
</ul>
</li>
<li><p>跨浏览器的 CROS</p>
<ul>
<li>所有浏览器都支持简单的（非 Preflight 和不带凭据的）请求</li>
</ul>
</li>
</ul>
<h2 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h2><ul>
<li>图像 Ping<ul>
<li><code>&lt;img&gt;</code> 标签</li>
<li>只能发送 GET 请求</li>
<li>无法访问服务器的响应文本</li>
</ul>
</li>
<li>JSONP - JSON with padding<ul>
<li>包含两部分：回调函数和数据</li>
<li>通过 <code>&lt;script&gt;</code> 元素使用</li>
<li>能直接访问响应文本</li>
<li>从其他域中加载代码执行，不安全</li>
<li>很难确定 JSONP 请求是否成功</li>
</ul>
</li>
<li>Comet 服务器推送<ul>
<li>长轮询：浏览器发送请求，服务器保持连接，直到有数据发送才发送数据。浏览器收到数据后关闭连接，再重新发起新请求</li>
<li>HTTP 流：浏览器发送请求，服务器保持连接，周期性地向浏览器发送数据</li>
</ul>
</li>
<li>SSE 服务器发送事件<ul>
<li>围绕只读 Comet 交互推出的 API 或者模式</li>
</ul>
</li>
<li>Web Socket<ul>
<li>单独的持久连接上提供全双工、双向通信</li>
</ul>
</li>
<li>SSE 与 Web Socket<ul>
<li>Web Socket 需要服务器支持，双向通信</li>
<li>SSE 不需要服务器支持，一般单向，结合 XHR 可以双向</li>
</ul>
</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>要求以 SSL 连接来访问可以通过 XHR 请求的资源</li>
<li>要求每一次请求都要附带经过响应算法计算得到的验证码</li>
</ul>
<p>以下措施对防范 CSRF（Cross-Saite Request Forgery）攻击不起作用</p>
<ul>
<li>要求发送 POST 而不是 GET —— 容易改变</li>
<li>检查来源 URL 以确定 是否可信 —— 容易伪造</li>
<li>基于 cookie 信息进行验证 ——容易伪造</li>
</ul>

  </div>
</article>
      </main>
    </div>
  </body>
</html>