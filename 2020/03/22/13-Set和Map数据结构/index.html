<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>life kicks in right now</title>
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">life kicks in right now</a>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
        <li class="menu-item">
          <a href="https://github.com/ziiyan" target="_blank" rel="noopener" class="menu-item-link">Github</a>
        </li>
      
    </ul>
  </nav>
</header>
      <main class="main">
        <article class="post">
  <div class="post-title">
    <h2 class="title">Set和Map数据结构</h2>
  </div>
   <div class="post-meta">
    <span class="post-time">2020-03-22</span>
  </div>
  <div class="post-content">
    <h1 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li>类似于数组，但成员的值都是唯一的<ul>
<li>不会发生类型转换，所以 5 和 “5” 不同</li>
<li>两个 NaN 是相等的，这和 <code>===</code> 不同</li>
<li>两个对象总是不想等</li>
</ul>
</li>
<li><code>Set</code> 构造函数可以接受一个数组（或具有 iterable 接口的其他数据结构）作为参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Array.from 可以将 Set 结构转为数组</p>
</blockquote>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><ul>
<li><p>属性</p>
<ul>
<li><code>Set.prototype.constructor</code> 构造函数</li>
<li><code>Set.prototype.size</code> 返回 <code>Set</code> 实例的成员总数</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><p>操作方法</p>
<ul>
<li><code>Set.prototype.add(value)</code> 添加某个值，返回 Set 结构本身</li>
<li><code>Set.prototype.delete(value)</code> 删除某个值，返回布尔表示是否成功</li>
<li><code>Set.prototype.has(value)</code> 返回布尔值，表示是否为 <code>Set</code> 成员</li>
<li><code>Set.prototype.clear(value)</code>清空，没有返回值</li>
</ul>
</li>
<li><p>遍历方法</p>
<ul>
<li><p><code>Set.prototype.keys()</code> 返回键名，遍历器对象</p>
</li>
<li><p><code>Set.prototype.values()</code> 返回键值，遍历器对象</p>
<blockquote>
<p>Set 结构没有键名，只有键值（或者说键名键值都是同一个值），所以 keys 方法和 values 方法一样</p>
</blockquote>
</li>
<li><p><code>Set.prototype.entries()</code> 返回键值对，遍历器对象</p>
</li>
<li><p><code>Set.prototype.forEach()</code> 使用回调函数遍历每个成员</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><ul>
<li>类似 Set</li>
<li>成员只能是对象<ul>
<li>弱引用，垃圾回收机制不考虑 WeakSet 的引用，可能会随时被清空</li>
</ul>
</li>
<li>不可遍历</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li>类似于对象，是键值对的集合</li>
<li>对象的键只能是字符串，Map 的键不限制类型</li>
<li><code>Map</code> 构造函数可接受数组，数组成员表示一个键值对（任何具有 Iterator 接口，且每个成员都是一个双元素的数组的数据结构，例如 Set 和 Map）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'zhangsan'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 实际上执行</span></span><br><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'zhangsan'</span>],</span><br><span class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">items.forEach(</span><br><span class="line">	([key, value]) =&gt; map.set(key, value)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>多次赋值一个键，会覆盖</li>
<li>读取一个未知的键，返回 <code>undefined</code></li>
<li>对于对象，地址相同 Map 结构才视为同一个键</li>
<li>对于简单类型，值严格相等 <code>===</code> 就是一个键</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">'a'</span>]) <span class="comment">//	undefined</span></span><br><span class="line"><span class="comment">// ['a'] 是实例，这里两个实例 ['a'] 内存地址不同</span></span><br></pre></td></tr></table></figure>

<h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><ul>
<li>属性<ul>
<li><code>size</code></li>
</ul>
</li>
<li>方法<ul>
<li>操作方法<ul>
<li><code>Map.prototype.set(key, value)</code><ul>
<li>返回当前 <code>Map</code> 对象，可以采用链式写法</li>
</ul>
</li>
<li><code>Map.prototype.get(key)</code></li>
<li><code>Map.prototype.has(key)</code></li>
<li><code>Map.prototype.delete(key)</code></li>
<li><code>Map.prototype.clear(key)</code></li>
</ul>
</li>
<li>遍历方法<ul>
<li><code>Map.prototype.keys()</code></li>
<li><code>Map.prototype.values()</code></li>
<li><code>Map.prototype.entries()</code></li>
<li><code>Map.prototype.forEach()</code></li>
</ul>
</li>
</ul>
</li>
<li>Map 本身没有 <code>map</code> 和 <code>filter</code> 方法，需要结合数组</li>
</ul>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><ul>
<li><p>Map -&gt; 数组</p>
<ul>
<li><code>[...map]</code></li>
</ul>
</li>
<li><p>数组 -&gt; Map</p>
<ul>
<li><code>new Map(array)</code></li>
</ul>
</li>
<li><p>Map -&gt; 对象</p>
</li>
<li><p>对象 -&gt; Map</p>
</li>
<li><p>Map -&gt; JSON</p>
</li>
<li><p>JSON -&gt; Map</p>
</li>
</ul>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><ul>
<li>类似 Map</li>
<li>键名只能对象（除了 null）</li>
<li>指向的对象不计入垃圾回收机制</li>
</ul>

  </div>
</article>
      </main>
    </div>
  </body>
</html>