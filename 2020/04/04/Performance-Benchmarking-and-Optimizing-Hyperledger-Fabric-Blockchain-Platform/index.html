<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Performance Benchmarking and Optimizing Hyperledger Fabric Blockchain Platform | life kicks in right now</title>
  <meta name="description" content="Abstract The rise in popularity of permissioned blockchain platforms in recent time is significant. Hyperledger Fabric is one such permissioned blockchain platform and one of the Hyperledger projects">
<meta property="og:type" content="article">
<meta property="og:title" content="Performance Benchmarking and Optimizing Hyperledger Fabric Blockchain Platform">
<meta property="og:url" content="http://ziiyan.github.io/2020/04/04/Performance-Benchmarking-and-Optimizing-Hyperledger-Fabric-Blockchain-Platform/index.html">
<meta property="og:site_name" content="life kicks in right now">
<meta property="og:description" content="Abstract The rise in popularity of permissioned blockchain platforms in recent time is significant. Hyperledger Fabric is one such permissioned blockchain platform and one of the Hyperledger projects">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406145423347.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406150511423.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406170256066.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406181747147.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406165940078.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406170227600.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406182608909.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406185423203.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406185445094.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406185534544.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200416232925323.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406223431746.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406223953830.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200408103129527.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200408104549524.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200408104913866.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200408111402250.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200408111414932.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200408112038781.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200410111743151.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200410112955545.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200410113304957.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200410114711286.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200414002047642.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200414002126408.png">
<meta property="og:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200414003650302.png">
<meta property="article:published_time" content="2020-04-04T08:53:39.000Z">
<meta property="article:modified_time" content="2020-05-10T17:20:10.828Z">
<meta property="article:author" content="ziiyan">
<meta property="article:tag" content="翻译">
<meta property="article:tag" content="精读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ziiyan.github.io/Users/wuziyan/Library/Application%20Support/typora-user-images/image-20200406145423347.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://ziiyan.github.io/2020/04/04/Performance-Benchmarking-and-Optimizing-Hyperledger-Fabric-Blockchain-Platform/index.html">
  
    <link rel="alternate" href="/atom.xml" title="life kicks in right now" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css">
  
<meta name="generator" content="Hexo 4.2.0"></head>


<body class="main-center theme-purple" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/ziiyan" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Ziiyan</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Life kicks in right now</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> HangZhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/ziiyan" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>鶸挣扎记</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/" rel="tag">ECMAScript 6 入门</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" rel="tag">JavaScript高级程序设计</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWA/" rel="tag">PWA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E5%AE%83/" rel="tag">其它</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C/" rel="tag">工作</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD/" rel="tag">性能</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B2%BE%E8%AF%BB/" rel="tag">精读</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag">面经</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">19</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/CSS/" style="font-size: 13.38px;">CSS</a> <a href="/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/" style="font-size: 13.75px;">ECMAScript 6 入门</a> <a href="/tags/HTML/" style="font-size: 13px;">HTML</a> <a href="/tags/Java/" style="font-size: 13px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 13.75px;">JavaScript</a> <a href="/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" style="font-size: 13.88px;">JavaScript高级程序设计</a> <a href="/tags/PWA/" style="font-size: 13px;">PWA</a> <a href="/tags/React/" style="font-size: 13.25px;">React</a> <a href="/tags/Vue/" style="font-size: 13.63px;">Vue</a> <a href="/tags/Webpack/" style="font-size: 13px;">Webpack</a> <a href="/tags/%E5%85%B6%E5%AE%83/" style="font-size: 13.13px;">其它</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 13.5px;">刷题</a> <a href="/tags/%E5%B7%A5%E4%BD%9C/" style="font-size: 13px;">工作</a> <a href="/tags/%E6%80%A7%E8%83%BD/" style="font-size: 13.25px;">性能</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13px;">数据结构</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 13.63px;">浏览器</a> <a href="/tags/%E7%B2%BE%E8%AF%BB/" style="font-size: 13px;">精读</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 13.38px;">网络</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 13px;">翻译</a> <a href="/tags/%E9%9D%A2%E7%BB%8F/" style="font-size: 13px;">面经</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 14px;">面试</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">30</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/09/13/%E9%9D%A2%E7%BB%8F%EF%BC%9A%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84-%E5%8E%A6%E9%97%A8-%E4%B8%80%E9%9D%A2/" class="title">面经：美团点评-厦门-一面</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-13T14:39:27.000Z" itemprop="datePublished">2020-09-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/09/12/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9A%E5%88%B7%E9%9D%A2%E7%BB%8F/" class="title">面试准备：刷面经</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-12T12:38:41.000Z" itemprop="datePublished">2020-09-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/09/09/%E9%9D%A2%E7%BB%8F%EF%BC%9A%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9-%E4%B8%BB%E7%AB%99%E6%8A%80%E6%9C%AF%E4%B8%AD%E5%BF%83-%E4%B8%80%E9%9D%A2/" class="title">面经：哔哩哔哩-主站技术中心-一二面</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-09T12:15:17.000Z" itemprop="datePublished">2020-09-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/09/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF&%E5%BC%82%E6%AD%A5%E5%8E%9F%E7%90%86/" class="title">学习笔记：事件循环&amp;异步原理</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-09T04:19:17.000Z" itemprop="datePublished">2020-09-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/09/09/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9A%E9%97%AD%E5%8C%85/" class="title">面试准备：闭包</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-09T01:08:56.000Z" itemprop="datePublished">2020-09-09</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Abstract"><span class="toc-number">1.</span> <span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I-INTRODUCTION"><span class="toc-number">2.</span> <span class="toc-text">I. INTRODUCTION</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#II-BACKGROUND-HYPERLEDGER-FABRIC-ARCHITECTURE-amp-CONFIGURATION-PARAMETERS"><span class="toc-number">3.</span> <span class="toc-text">II. BACKGROUND: HYPERLEDGER FABRIC ARCHITECTURE &amp; CONFIGURATION PARAMETERS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Key-Components-in-Fabric"><span class="toc-number">3.1.</span> <span class="toc-text">A. Key Components in Fabric</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Peer"><span class="toc-number">3.1.1.</span> <span class="toc-text">Peer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Endorsement-Policies"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">Endorsement Policies</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#System-chaincodes"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">System chaincodes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">Channel</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ordering-Service"><span class="toc-number">3.1.2.</span> <span class="toc-text">Ordering Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Client"><span class="toc-number">3.1.3.</span> <span class="toc-text">Client</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-Transaction-Flow-in-Hyperledger-Fabric"><span class="toc-number">3.2.</span> <span class="toc-text">B. Transaction Flow in Hyperledger Fabric</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Endorsement-Phase"><span class="toc-number">3.2.1.</span> <span class="toc-text">Endorsement Phase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ordering-Phase"><span class="toc-number">3.2.2.</span> <span class="toc-text">Ordering Phase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Validation-Phase"><span class="toc-number">3.2.3.</span> <span class="toc-text">Validation Phase</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VSCC-Validation"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">VSCC Validation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVCC-Validation"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">MVCC Validation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ledger-Update-Phase"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">Ledger Update Phase</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Configuration-Parameters"><span class="toc-number">3.3.</span> <span class="toc-text">C. Configuration Parameters</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Block-Size"><span class="toc-number">3.3.1.</span> <span class="toc-text">1) Block Size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Endorsement-Policy"><span class="toc-number">3.3.2.</span> <span class="toc-text">2) Endorsement Policy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Channel"><span class="toc-number">3.3.3.</span> <span class="toc-text">3) Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Resource-Allocation"><span class="toc-number">3.3.4.</span> <span class="toc-text">4) Resource Allocation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Ledger-Database"><span class="toc-number">3.3.5.</span> <span class="toc-text">5) Ledger Database</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#III-PROBLEM-STATEMENT"><span class="toc-number">4.</span> <span class="toc-text">III. PROBLEM STATEMENT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Performance-Benchmarking"><span class="toc-number">4.1.</span> <span class="toc-text">1) Performance Benchmarking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Optimization"><span class="toc-number">4.2.</span> <span class="toc-text">2) Optimization</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IV-EXPERIMENTAL-METHODOLOGY"><span class="toc-number">5.</span> <span class="toc-text">IV. EXPERIMENTAL METHODOLOGY</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Setup-and-Workloads"><span class="toc-number">5.1.</span> <span class="toc-text">A. Setup and Workloads</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#V-EXPERIMENTAL-RESULTS"><span class="toc-number">6.</span> <span class="toc-text">V. EXPERIMENTAL RESULTS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-Impact-of-Transaction-Arrival-Rate-and-Block-Size"><span class="toc-number">6.1.</span> <span class="toc-text">A. Impact of Transaction Arrival Rate and Block Size</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Observation-1"><span class="toc-number">6.1.1.</span> <span class="toc-text">Observation 1:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observation-2"><span class="toc-number">6.1.2.</span> <span class="toc-text">Observation 2:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observation-3"><span class="toc-number">6.1.3.</span> <span class="toc-text">Observation 3:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observation-4"><span class="toc-number">6.1.4.</span> <span class="toc-text">Observation 4:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observation-5"><span class="toc-number">6.1.5.</span> <span class="toc-text">Observation 5:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Guideline-1"><span class="toc-number">6.1.6.</span> <span class="toc-text">Guideline 1:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Guideline-2"><span class="toc-number">6.1.7.</span> <span class="toc-text">Guideline 2:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Action-Item-1"><span class="toc-number">6.1.8.</span> <span class="toc-text">Action Item 1:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-Impact-of-Endorsement-Policy"><span class="toc-number">6.2.</span> <span class="toc-text">B. Impact of Endorsement Policy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Observation-6"><span class="toc-number">6.2.1.</span> <span class="toc-text">Observation 6:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Guideline-3"><span class="toc-number">6.2.2.</span> <span class="toc-text">Guideline 3:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Action-Item-2"><span class="toc-number">6.2.3.</span> <span class="toc-text">Action Item 2:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Impact-of-Channels-and-Resource-Allocation"><span class="toc-number">6.3.</span> <span class="toc-text">C. Impact of Channels and Resource Allocation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Observation-7"><span class="toc-number">6.3.1.</span> <span class="toc-text">Observation 7:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observation-8"><span class="toc-number">6.3.2.</span> <span class="toc-text">Observation 8:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observation-9"><span class="toc-number">6.3.3.</span> <span class="toc-text">Observation 9:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Guideline-4"><span class="toc-number">6.3.4.</span> <span class="toc-text">Guideline 4:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Guideline-5"><span class="toc-number">6.3.5.</span> <span class="toc-text">Guideline 5:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Action-Item-3"><span class="toc-number">6.3.6.</span> <span class="toc-text">Action Item 3:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#D-Impact-of-Ledger-Database"><span class="toc-number">6.4.</span> <span class="toc-text">D. Impact of Ledger Database</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Observation-10"><span class="toc-number">6.4.1.</span> <span class="toc-text">Observation 10:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observation-11"><span class="toc-number">6.4.2.</span> <span class="toc-text">Observation 11:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observation-12"><span class="toc-number">6.4.3.</span> <span class="toc-text">Observation 12:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Guideline-6"><span class="toc-number">6.4.4.</span> <span class="toc-text">Guideline 6:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Action-Item-4"><span class="toc-number">6.4.5.</span> <span class="toc-text">Action Item 4:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Action-Item-5"><span class="toc-number">6.4.6.</span> <span class="toc-text">Action Item 5:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#E-Scalability-and-Fault-Tolerant"><span class="toc-number">6.5.</span> <span class="toc-text">E. Scalability and Fault Tolerant</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VI-OPTIMIZATIONS-STUDIED"><span class="toc-number">7.</span> <span class="toc-text">VI. OPTIMIZATIONS STUDIED</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-MSP-Cache"><span class="toc-number">7.1.</span> <span class="toc-text">A. MSP Cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-Parallel-VSCC-Validation-of-a-Block"><span class="toc-number">7.2.</span> <span class="toc-text">B. Parallel VSCC Validation of a Block</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Bulk-Read-Write-During-MVCC-Validation-amp-Commit"><span class="toc-number">7.3.</span> <span class="toc-text">C. Bulk Read&#x2F;Write During MVCC Validation &amp; Commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#D-Combinations-of-Optimizations"><span class="toc-number">7.4.</span> <span class="toc-text">D. Combinations of Optimizations</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VII-RELATED-WORK"><span class="toc-number">8.</span> <span class="toc-text">VII. RELATED WORK</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VIII-CONCLUSION-amp-FUTURE-WORK"><span class="toc-number">9.</span> <span class="toc-text">VIII. CONCLUSION &amp; FUTURE WORK</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IX-ACKNOWLEDGEMENTS"><span class="toc-number">10.</span> <span class="toc-text">IX. ACKNOWLEDGEMENTS</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Performance-Benchmarking-and-Optimizing-Hyperledger-Fabric-Blockchain-Platform" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Performance Benchmarking and Optimizing Hyperledger Fabric Blockchain Platform
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2020/04/04/Performance-Benchmarking-and-Optimizing-Hyperledger-Fabric-Blockchain-Platform/" class="article-date">
	  <time datetime="2020-04-04T08:53:39.000Z" itemprop="datePublished">2020-04-04</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/%E7%B2%BE%E8%AF%BB/" rel="tag">精读</a>, <a class="article-tag-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/04/04/Performance-Benchmarking-and-Optimizing-Hyperledger-Fabric-Blockchain-Platform/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><blockquote>
<p>The rise in popularity of permissioned blockchain platforms in recent time is significant. Hyperledger Fabric is one such permissioned blockchain platform and one of the Hyperledger projects hosted by the Linux Foundation.</p>
<p>The Fabric comprises of various components such as smart-contracts, endorsers, committers, validators, and orderers.</p>
<p>As the performance of blockchain platform is a major concern for enterprise applications, in this work, we perform a comprehensive empirical study to characterize the performance of Hyperledger Fabric and identify potential performance bottlenecks to gain a better understanding of the system.</p>
</blockquote>
<p>最近一段时间，许可链平台的流行度显着上升。 Hyperledger Fabric 是一种这样的许可链平台，也是 Linux 基金会托管的 Hyperledger 项目之一。</p>
<p>Fabric 由各种组件组成，例如智能合约，背书节点，提交节点，验证节点和排序节点。</p>
<p>由于区块链平台的性能是企业应用程序的主要关注点，因此在这项工作中，我们进行了全面的实证研究，以表征 Hyperledger Fabric 的性能并确定潜在的性能瓶颈，以更好地了解系统。</p>
<blockquote>
<p>We follow a two-phased approach.</p>
<p>In the first phase, our goal is to understand the impact of various configuration parameters such as block size, endorsement policy, channels, resource allocation, state database choice on the transaction throughput &amp; latency to provide various guidelines on configuring these parameters.</p>
<p>In addition, we also aim to identify performance bottlenecks and hotspots. We observed that (1) endorsement policy verification, (2) sequential policy validation of transactions in a block, and (3) state validation and commit (with CouchDB) were the three major bottlenecks.</p>
</blockquote>
<p>我们遵循两阶段的方法。</p>
<p>在第一阶段，我们的目标是了解各种配置参数（例如块大小、背书策略、通道、资源配置、状态数据库选择）对交易吞吐量和延迟的影响，以提供有关配置这些参数的各种指导。</p>
<p>此外，我们还旨在确定性能瓶颈和热点。 我们观察到（1）背书策略验证，（2）块中交易的顺序策略验证，（3）状态验证和提交（使用 CouchDB）是三个主要瓶颈。</p>
<blockquote>
<p>In the second phase, we focus on optimizing Hyperledger Fabric v1.0 based on our observations.</p>
<p>We introduced and studied various simple optimizations such as aggressive caching for endorsement policy verification in the cryptography component (3× improvement in the performance) and parallelizing endorsement policy verification (7× improvement). </p>
<p>Further, we enhanced and measured the effect of an existing bulk read/write optimization for CouchDB during state validation &amp; commit phase (2.5× improvement). </p>
<p>By combining all three optimizations, we improved the overall throughput by 16× (i.e., from 140 tps to 2250 tps).</p>
</blockquote>
<p>在第二阶段，我们将根据我们的观察优化 Hyperledger Fabric v1.0。</p>
<p>我们介绍并研究各种简单的优化方法，例如在加密组件中进行背书策略验证的主动缓存（性能提高了 3 倍）和并行化背书策略验证（提高 7 倍）。</p>
<p>此外，我们在验证和提交阶段期间增强并测量了现有的针对 CouchDB 批量读写优化的效果（提高 2.5 倍）。</p>
<p>通过结合这 3 个优化，我们将整体吞吐量提升了 16 倍，即从 140 tps 到 2250 tps。</p>
<h1 id="I-INTRODUCTION"><a href="#I-INTRODUCTION" class="headerlink" title="I. INTRODUCTION"></a>I. INTRODUCTION</h1><blockquote>
<p>Blockchain technologies initially gained popularity as they were seen as a way to get rid of the intermediary and decentralize the system. Since then, blockchain has witnessed a growing interest from different domains and use cases. A blockchain is a shared, distributed ledger that records transactions and is maintained by multiple nodes in the network where nodes do not trust each other. Each node holds the identical copy of the ledger which is usually represented as a chain of blocks, with each block being a logical sequence of transactions. Each block encloses the hash of its immediate previous block, thereby guaranteeing the immutability of ledger.</p>
</blockquote>
<p>区块链最初开始流行是因为它们被认为是一种摆脱中介和去中心化系统的方式。从那之后，区块链见证了来自不同领域和用例日益增长的兴趣。</p>
<p>区块链是一个共享的、分布式的账本，它记录交易并由网络中互不信任的多个节点共同维护。每个节点都拥有该账本的相同副本，账本通常由区块链表示，每个区块都是交易的逻辑顺序。每个交易都包含前一个区块的哈希，从而保证了账本的不可篡改。</p>
<blockquote>
<p>Blockchain is often hailed as a new breed of database systems, in essence being a distributed transaction processing system where the nodes are not trusted and the system needs to achieve Byzantine fault tolerance. Blockchain provides serializability, immutability, and cryptographic verifiability without a single point of trust unlike a database system; properties that have triggered blockchain adoption in a wide variety of industries.</p>
</blockquote>
<p>区块链通常被誉为一种新型的数据库系统，本质上是一个分布式的交易处理系统，其中的节点不受信任，并且这个系统需要实现拜占庭容错。与数据库系统不同，区块链在没有单一信任点的情况下提供了可串行性、不可篡改性和加密可验证性；引发区块链在众多行业中采用的特性。</p>
<blockquote>
<p>A blockchain network can be either permissionless or permissioned. </p>
<p>In a permissionless network or public network such as Bitcoin, Ethereum, anyone can join the network to perform transactions. Due to a large number of nodes in a public network, a proof-of-work consensus approach is used to order transactions and create a block.</p>
<p>In a permissioned network, the identity of each participant is known and authenticated cryptographically such that blockchain can store who performed which transaction. In addition, such a network can have extensive access control mechanisms built-in to limit who can (a) read &amp; append to ledger data, (b) issue transactions, (c) administer participation in the blockchain network.</p>
</blockquote>
<p>区块链网络可以是未经许可的或经过许可的。</p>
<p>在未经许可的网络或公共网络（例如比特币、以太坊）中，任何人都可以加入网络以执行交易。由于公共网络中有大量节点，因此采用工作量证明共识算法来对交易进行排序并创建一个区块。</p>
<p>在经过许可的网络中，每个参与者的身份都是已知的，通过密码验证，区块链可以存储谁执行了哪个交易。此外，这样的网络可以内置广泛的网络控制机制来限制谁可以（a）读取并添加账本数据，（b）发送交易，（c）管理参与区块链网络。</p>
<blockquote>
<p>A permissioned network is highly suitable for enterprise applications that require authenticated participants. Each node in a permissioned network can be owned by different organizations. Further, enterprise applications need complex data models and expressibility which can be supported using smart-contracts. Enterprises find value in being able to integrate diverse systems without having to build a centralized solution and to bring a level of trust among untrusting parties or to bring in a trusted third-party. Trade Finance and Food Safety are examples of blockchain applications where participants see value in visibility advantages it offers as compared to the existing loosely coupled centralized systems.</p>
</blockquote>
<p>许可网络非常适合需要验证参与者身份的企业应用程序。 许可网络中的每个节点可以由不同的组织拥有。 此外，企业应用程序需要复杂的数据模型和可表达性，可以使用智能合约来支持它们。 企业发现了能够集成各种系统而无需构建集中式解决方案并在非信任方之间建立信任度或引入受信任的第三方的价值。 贸易金融和食品安全是区块链应用的例子，与现有的松散耦合的集中式系统相比，参与者在其可见性优势中看到了价值。</p>
<blockquote>
<p>There is a lot of concern about the performance of permissioned blockchain platforms and their ability to handle a huge volume of transactions at low latency. Another concern is the richness of language to describe the transactions. Different blockchain platforms such as Quorum, Corda address these concerns using different techniques derived from the distributed systems domain. Hyperledger Fabric is an enterprise-grade open-source permissioned blockchain platform which has a modular design and a high degree of specifiability through trust models and pluggable components. Fabric is currently being used in many different use cases such as Global Trade Digitization, SecureKey, Everledger and is the focus of our performance study.</p>
</blockquote>
<p>对于许可链平台的性能及其以低延迟处理大量交易的能力，存在很多担忧。 另一个问题是描述交易的语言丰富。 Quorum，Corda 等不同的区块链平台使用源自分布式系统领域的不同技术来解决这些问题。Hyperledger Fabric 是企业级开源许可链平台，具有模块化设计，并通过信任模型和可插拔组件实现高度可定制性。 目前，Fabric 已在许多不同的用例中使用，例如全球贸易数字化，SecureKey，Everledger，这是我们性能研究的重点。</p>
<blockquote>
<p>Fabric consists of various components such as endorsers, ordering service, and committers. Further, it constitutes various phases in processing a transaction such as endorsement phase, ordering phase, validation and commit phase. Due to numerous components and phases, Fabric provides various configurable parameters such as block size, endorsement policy, channels, state database. Hence, one of the main challenges in setting up an efficient blockchain network is finding the right set of values for these parameters. For e.g., depending on the application and requirements, one might need to answer the following questions:</p>
<ul>
<li><p>What should be the block size to achieve a lower latency?</p>
</li>
<li><p>How many channels can be created and what should be</p>
<p>  the resource allocation?</p>
</li>
<li><p>What types of endorsement policy is more efficient?</p>
</li>
<li><p>How much is the performance difference between</p>
<p>  GoLevelDB and CocuhDB when it is used as the</p>
<p>  state database?</p>
</li>
</ul>
</blockquote>
<p>Fabric 由各种组件组成，例如智能合约，背书节点，提交节点，验证节点和排序节点。此外，它还构成了处理交易的各个阶段，例如背书阶段，排序阶段，验证和提交阶段。由于组件和阶段众多，Fabric 提供了各种可配置的参数，例如块大小，背书策略，通道，状态数据库。因此，建立有效的区块链网络的主要挑战之一是为这些参数找到正确的值集。例如，根据应用和要求，可能需要回答以下问题：</p>
<ul>
<li>达到较低延迟的块大小应该是多少？</li>
<li>可以创建多少个通道，应该怎么分配资源？</li>
<li>哪种类型的认可政策更有效？</li>
<li>GoLevelDB 和 CocuhDB 用作状态数据库时它们之间的性能差异有多少？</li>
</ul>
<blockquote>
<p>To answer above questions and to identify the performance bottlenecks, we perform a comprehensive empirical study of Fabric v1.0 with various configurable parameters. Specifically, our three major contributions are listed below.</p>
<ol>
<li>We conducted a comprehensive empirical study of Fabric platform by varying values assigned to the five major parameters by conducting over 1000s of experiments. As a result, we provide six guidelines on configuring these parameters to attain the maximum performance.</li>
<li>We identified three major performance bottlenecks: (i) crypto operations, (ii) serial validation of transactions in a block, and (iii) multiple REST API calls to CouchDB.</li>
<li>Introduced and studied three simple optimizations to improve the overall performance by 16× (i.e., from 140 tps to 2250 tps) for a single channel environment.</li>
</ol>
</blockquote>
<p>为了回答上述问题并确定性能瓶颈，我们对 Fabric v1.0 的各种可配置参数的进行了全面的实证研究。 具体来说，以下是我们的三大贡献。</p>
<ol>
<li>我们通过进行1000多次实验，通过改变分配给五个主要参数的值，对Fabric 平台进行了全面的实证研究。 最终，我们提供了六种有关配置这些参数的准则以获得最佳性能。</li>
<li>我们确定了三个主要的性能瓶颈：（i）加密操作，（ii）块中交易的串行验证以及（iii）对 CouchDB 的多个 REST API 调用。</li>
<li>引入并研究了三种简单的优化方法，针对单个通道环境将整体性能提高16倍（即从 140 tps 到 2250 tps）。</li>
</ol>
<h1 id="II-BACKGROUND-HYPERLEDGER-FABRIC-ARCHITECTURE-amp-CONFIGURATION-PARAMETERS"><a href="#II-BACKGROUND-HYPERLEDGER-FABRIC-ARCHITECTURE-amp-CONFIGURATION-PARAMETERS" class="headerlink" title="II. BACKGROUND: HYPERLEDGER FABRIC ARCHITECTURE &amp; CONFIGURATION PARAMETERS"></a>II. BACKGROUND: HYPERLEDGER FABRIC ARCHITECTURE &amp; CONFIGURATION PARAMETERS</h1><blockquote>
<p>The Hyperledger Fabric is an implementation of permissioned blockchain system which has many unique properties suited for enterprise-class applications. It can run arbitrary smart contracts (a.k.a chaincodes) implemented in Go/JAVA/Nodejs language. It supports an application specifiable trust model for transaction validation and a pluggable consensus protocol to name a few. A Fabric network consists of different types of entities, peer nodes, ordering service nodes and clients, belonging to different organizations. Each of these has an identity on the network which is provided by a Membership Service Provider (MSP), typically associated with an organization. All entities in the network have visibility to identities of all organizations and can verify them.</p>
</blockquote>
<p>Hyperledger Fabric 是许可区块链系统的实现，具有许多适合企业级应用程序的独特属性。 它可以运行以 Go / JAVA / Nodejs 语言实现的任意智能合约（也称为链码）。 它支持用于交易验证的应用程序可定制的信任模型和可插拔的共识协议等。 Fabric 网络由属于不同组织的不同类型的实体、对等节点、排序节点和客户端组成。这些中的每一个在网络上都有一个身份，该身份由通常由组织相关联的成员资格服务提供商（MSP）提供。 网络中的所有实体都可以查看所有组织的身份，并可以对其进行验证。</p>
<h2 id="A-Key-Components-in-Fabric"><a href="#A-Key-Components-in-Fabric" class="headerlink" title="A. Key Components in Fabric"></a>A. Key Components in Fabric</h2><h3 id="Peer"><a href="#Peer" class="headerlink" title="Peer"></a>Peer</h3><blockquote>
<p>A peer node executes the chaincode, which implements a user smart-contract, and maintains the ledger in a file system. The chaincode is allowed access to the shared state by well-defined ledger APIs. A peer is further segregated as an endorsing peer, one which has the chaincode logic and executes it to endorse a transaction or a committing peer, one which does not hold the chaincode logic. Irrespective of this differentiation, both types of peer maintain the ledger. Additionally, both peers maintain the current state as StateDB in a key-value store such that chaincode can query or modify the state using the database query language.</p>
</blockquote>
<p>对等节点执行链码（该链码实现了用户智能合约）并在文件系统中维护账本。 链码可以通过定义明确的分类账本 API 访问共享状态。 对等节点进一步被分类为背书节点（具有链码逻辑和执行链码以背书一个交易）或提交节点（没有链码逻辑）。 不论这些区别是什么，两种类型的对等节点都共同维护账本。 此外，两种对等节点在键值存储中将当前状态保持为 StateDB，以便链码可以使用数据库查询语言查询或修改状态。</p>
<h4 id="Endorsement-Policies"><a href="#Endorsement-Policies" class="headerlink" title="Endorsement Policies"></a>Endorsement Policies</h4><blockquote>
<p>Chaincodes are written in generalpurpose languages that execute on untrusted peers in the network. This poses multiple problems, one of non-deterministic execution and the other of trusting the results from any given peer. The endorsement policy addresses these two concerns, by specifying as part of an endorsement policy, the set of peers that need to simulate the transaction and endorse or digitally sign the execution results. Endorsement policies are specified as boolean expressions over network principals identities. A principal here is a member of a specific organization.</p>
</blockquote>
<p>链码用通用语言编写，可在网络中不受信任的对等节点上执行。 这带来了多个问题，一个是不确定性执行，另一个是信任来自任意给定对等节点的结果。背书策略通过指定作为背书策略的一部分对等节点集合来解决这两个问题，这些对等点需要模拟交易并背书或对执行结果进行数字签名。背书策略被指定为基于网络主体身份的布尔表达式。 此处的负责人是特定组织的成员。</p>
<h4 id="System-chaincodes"><a href="#System-chaincodes" class="headerlink" title="System chaincodes"></a>System chaincodes</h4><blockquote>
<p>System chaincode has the same programming model as normal user chaincodes and is built into the peer executable, unlike user chaincodes. </p>
<p>Fabric implements various system chaincodes; </p>
<p>the life cycle system chaincode (LSCC)—to install/instantiate/update chaincodes; </p>
<p>the endorsement system chaincode (ESCC)—to endorse a transaction by digitally signing the response; </p>
<p>the validation system chaincode (VSCC)—to validate a transaction’s endorsement signature set against the endorsement policy; </p>
<p>the configuration system chaincode (CSCC) – to manage channel configurations.</p>
</blockquote>
<p>系统链码具有与普通用户链码相同的编程模型，并且内置在对等节点可执行文件中，这与用户链码不同。 </p>
<p>Fabric 实现各种系统链码； </p>
<p>生命周期系统链代码（LSCC）-用来安装/实例化/更新链码； </p>
<p>背书系统链码（ESCC）-通过对响应进行数字签名来背书交易； </p>
<p>验证系统链码（VSCC）-根据背书策略来验证交易的背书签名集； </p>
<p>配置系统链码（CSCC）–管理通道配置。</p>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><blockquote>
<p>Fabric introduces a concept called channel as a “private” subnet of communication between two or more peers to provide a level of isolation. Transactions on a channel are only seen by the peer members and participants. The immutable ledger and chaincodes are on a per-channel basis. Further, the consensus is applicable on a per-channel basis, i.e., there is no defined order for transaction across channels.</p>
</blockquote>
<p>Fabric 引入了一个称为通道的概念，作为两个或多个对等节点之间的“专用”通信子网，以提供一定程度的隔离。 通道上的交易仅由对等节点成员和参与者可见。 在每个通道上都有不变的账本和链码。 此外，共识适用于每个通道，即没有定义的跨通道的交易顺序。</p>
<h3 id="Ordering-Service"><a href="#Ordering-Service" class="headerlink" title="Ordering Service"></a>Ordering Service</h3><blockquote>
<p>An Ordering Service Node (OSN), participate in the consensus protocol and cuts block of transactions which is delivered to the peers by a gossip communication protocol. The structure of a block in Fabric v1.0 is shown in Figure2. The ordering service is modular and supports a pluggable consensus mechanism. By default, a serial ordering (i.e., consensus) is achieved using an underlying Kafka/Zookeeper cluster. OSNs publish transactions to kafka topics and leverages the ordered and immutable nature of records in kafka topic to generate a unique ordered sequence of transactions in a block. A block is cut, when either a maximum number of new transactions, since the last block cut, are added added or a configured timeout since the last block cut has occurred. When any one condition is satisfied, an OSN, publishes a time-to-cut marker and cut a block of all transactions message offsets since the last time-to-cut message offset. The block is then delivered to the peer nodes.</p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200406145423347.png" alt="image-20200406145423347" style="zoom:50%;">
</blockquote>
<p>排序服务节点（OSN）参与共识协议和“削减”交易块，该交易通过 Gossip 通信协议传递给对等节点。 Fabric v1.0 中的块结构如图所示。 排序服务是模块化的，并支持可插入的共识机制。 默认使用基础的 Kafka / Zookeeper 集群实现序列排序（即共识）。 OSN 将交易发布到 kafka topic，并利用 kafka topic 中记录的有序和不变性在一个块中生成唯一的有序交易序列。 当添加了自上次切块以来最大数量的新交易，或者自上次切块发生以来的配置超时时，该块被切掉。当满足任何一个条件时，OSN 会发布一个截止时间标记，并切掉自上次截止时间消息偏移以来所有交易消息偏移组成的块。 然后将该块传递到对等节点。</p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><blockquote>
<p>The client application is responsible for putting together a transaction proposal as shown in Figure2. </p>
<p>The client submits the transaction proposal to 1-or-more peers simultaneously for collecting proposal responses with endorsements to satisfy the endorsement policy. </p>
<p>It then broadcasts the transaction to the orderer to be included into a block and delivered to all peers for validation and commit. </p>
<p>In Fabric v1.0, the onus is on the client to ensure that the transaction is well-formed and satisfies the endorsement policies.</p>
</blockquote>
<p>如图2所示，客户应用程序负责将交易提案汇总在一起。</p>
<p>客户将交易提案同时提交给一个或多个对等节点，以收集带有背书的提案响应，以满足背书策略。 </p>
<p>然后，它将交易广播给排序节点，为了打包并交付给所有对等节点来进行验证和提交。 </p>
<p>在Fabric v1.0中，客户有责任确保交易的格式正确并满足背书策略。</p>
<h2 id="B-Transaction-Flow-in-Hyperledger-Fabric"><a href="#B-Transaction-Flow-in-Hyperledger-Fabric" class="headerlink" title="B. Transaction Flow in Hyperledger Fabric"></a>B. Transaction Flow in Hyperledger Fabric</h2><blockquote>
<p>Unlike other Blockchain network which employ an order-execute transaction model, the Fabric employs a simulate order-validate &amp; commit model. </p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200406150511423.png" alt="image-20200406150511423" style="zoom:50%;">

<p>Figure 1 depicts the transaction flow which involves 3 steps, </p>
<p>1) Endorsement Phase – simulating the transaction on selective peers and collecting the state changes; </p>
<p>2) Ordering Phase – ordering the transactions through a consensus protocol; </p>
<p>and 3) Validation Phase – validation followed by commit to ledger. </p>
<p>Before transactions can be submitted on Fabric, the network needs to be bootstrapped with participating organizations, their MSPs and identities for peers. </p>
<p>First, a channel is created on the orderer network with respective organization MSPs. </p>
<p>Second, peers of each organization join the channel and initializes the ledger. </p>
<p>Finally, the required chaincodes are installed on the channel.</p>
</blockquote>
<p>与其他采用顺序执行交易模型的区块链网络不同，Fabric 采用模拟顺序验证和提交模型。 </p>
<p>图1描绘了涉及三个步骤的交易流程：</p>
<p>1）背书阶段–在可选择的对等节点上模拟交易并收集状态变化；</p>
<p>2）排序阶段–通过共识协议对交易进行排序；</p>
<p>3）验证阶段–验证，然后提交到账本。 </p>
<p>在可以在 Fabric 上提交交易之前，网络需要与参与组织（它们的资格服务提供商）一起自举并验证对等节点。 </p>
<p>首先，在带有各自组织资格服务提供商的排序网络上创建通道。 </p>
<p>其次，每个组织的对等节点加入通道并初始化账本。 </p>
<p>最后，所需的链码被安装在通道上。</p>
<h3 id="Endorsement-Phase"><a href="#Endorsement-Phase" class="headerlink" title="Endorsement Phase"></a>Endorsement Phase</h3><blockquote>
<p> A client application using the Fabric SDK, constructs a transaction proposal to invoke a chaincode function which in-turn will perform read and/or write operations on the ledger state. The proposal is signed with the client’s credentials and the client sends it to 1-or-more endorsing peers simultaneously. The endorsement policy for the chaincode dictates the organization peers the client needs to send the proposal to for simulation.</p>
</blockquote>
<p>客户端（client）使用 Fabric SDK 构造交易提议（transaction proposal） 以调用链码函数，该函数将依次对账本状态执行读取和/或写入操作。 提案已被客户端的资格证书签名，且客户端同时将提案发送给1个或多个背书节点。 链码的背书策略规定了客户端需要发送提议给模拟的组织对等节点。</p>
<blockquote>
<p>First, each endorsing peer verifies that the submitter is authorized to invoke transactions on the channel. </p>
<p>Second, the peer executes the chaincode, which can access the current ledger state on peer. The transaction results include response value, read-set and write-set. All reads read the current state of ledger, but all writes are intercepted and modify a private transaction workspace.</p>
<p> Third, the endorsing peer calls a system chaincode called ESCC which signs this transaction response with peer’s identity and replies back to client with proposal response. </p>
<p>Finally, the client inspects the proposal response to verify that it bears the signature of the peer. The client collects enough proposal response from different peers, verifies that the endorsements are same. </p>
<p>Since each peer could have executed the transaction at different height in the blockchain, it is possible that the proposal response differs. In such cases, the client has to re-submit the proposal to other peers, to obtain sufficient matching responses.</p>
</blockquote>
<p>首先，每个背书节点都会验证提交者是否有权调用通道上的交易。</p>
<p>其次，对等节点执行链码，该链码可以访问节点上当前的账本状态。交易结果包括响应值，读集和写集。所有读均读取账本的当前状态，但所有写入均会被拦截并修改私有交易工作区。</p>
<p>第三，背书节点调用一个称为 ESCC 的系统链码，该系统链码以节点的身份对该交易响应进行签名，并通过提案响应将其返回给客户端。</p>
<p>最后，客户端检查提议响应以验证它是否带有节点的签名。客户端从不同的节点那里收集到足够多的提案响应，验证背书是否相同。</p>
<p>由于每个节点可能在区块链中的不同高度处执行交易，因此提案响应可能会有所不同。在这种情况下，客户端必须将提案重新提交给其他节点，以获得足够的匹配响应。</p>
<h3 id="Ordering-Phase"><a href="#Ordering-Phase" class="headerlink" title="Ordering Phase"></a>Ordering Phase</h3><blockquote>
<p>The client broadcasts a well-formed transaction message to the Ordering Service. The transaction will contain the read-write sets, the endorsing peer signatures and the Channel ID. The ordering service does not need to inspect the contents of the transaction to perform its operation. It receives transactions from different clients for various channels and enqueues them on a per-channel basis. It creates blocks of transactions per channel, sign the block with its identity and delivers them to peers using gossip messaging protocol.</p>
</blockquote>
<p>客户端向排序服务广播格式正确的交易消息。 交易将包含读写集，背书节点签名和通道ID。 排序服务不需要检查交易的内容即可执行操作。 它接收来自不同客户的各种通道的交易，并在每个通道的基础上排队。 它创建每个通道的交易块，用其身份签名该块，并使用 gossip 通信协议将其“传递”给节点。</p>
<h3 id="Validation-Phase"><a href="#Validation-Phase" class="headerlink" title="Validation Phase"></a>Validation Phase</h3><blockquote>
<p>All peers, both endorsing and committing peers on a channel receive blocks from the network. The peer first verifies the Orderer’s signature on the block. Each valid block is decoded and all transactions in a block goes through VSCC validation first before performing MVCC validation.</p>
</blockquote>
<p>通道上的所有对等节点（背书节点和提交节点）都从网络接收块。 首先，节点验证块上排序节点的签名。 在执行 MVCC 验证之前，每个有效块都将被解码，并且在一个块中的所有交易都将先通过 VSCC 验证。</p>
<h4 id="VSCC-Validation"><a href="#VSCC-Validation" class="headerlink" title="VSCC Validation"></a>VSCC Validation</h4><blockquote>
<p>A Validation system chaincode evaluates endorsements in the transaction against the endorsement policy specified for the chaincode. If the endorsement policy is not satisfied, then that transaction is marked invalid.</p>
</blockquote>
<p>验证系统链码会根据为链码指定的背书策略评估交易中的背书。 如果不符合则该交易将标记为无效。</p>
<h4 id="MVCC-Validation"><a href="#MVCC-Validation" class="headerlink" title="MVCC Validation"></a>MVCC Validation</h4><blockquote>
<p>As the name implies, the Multi-Version Concurrency Control check ensures that the versions of keys read by a transaction during the endorsement phase are same as their current state in the local ledger at commit time. This is similar to a read-write conflict check done for concurrency control, and is performed sequentially on all the valid transactions in the block (as marked by VSCC validation). If the read-set versions do not match, denoting that a concurrent previous (as-in earlier in this block or before) transaction modified the data read and was since (it’s endorsement) successfully committed, the transaction is marked invalid. To ensure that no phantom reads occur, for range queries, the query is re-executed and compares the hashes of results (which is also stored as part of read-set captured during endorsement).</p>
</blockquote>
<p>顾名思义，“多版本并发控制”检查确保交易在背书阶段读取的密钥版本与提交时本地账本中的当前状态相同。 这类似于为进行并发控制而进行的读写冲突检查，并且对块中的所有有效交易按顺序执行（由 VSCC 验证标记）。 如果读取的版本不匹配，表示并发的先前（在此块中较早或之前）的交易修改了读取的数据，并且是由于（背书）成功提交的，则该交易被标记为无效。 为确保不发生幻读，对于范围查询，将重新执行查询并比较结果的哈希值（也将其存储为背书期间捕获的读取集的一部分）。</p>
<h4 id="Ledger-Update-Phase"><a href="#Ledger-Update-Phase" class="headerlink" title="Ledger Update Phase"></a>Ledger Update Phase</h4><blockquote>
<p>As the last step of transaction processing, the ledger is updated by appending the block to the local ledger. The StateDB, which holds the current state of all keys is updated with the write-sets of valid transactions (as marked by MVCC validation). These updates to the StateDB are performed atomically for a block of transactions and applies the updates to bring the StateDB to the state after all transaction in the block have been processed.</p>
</blockquote>
<p>作为交易处理的最后一步，通过将块添加到本地账本来更新账本。 使用有效交易的写集（由 MVCC 验证标记）更新保存所有密钥当前状态的 StateDB。 对 StateDB 的这些更新是针对一个交易块自动执行的，并在处理了该块中的所有交易之后，应用更新以使 StateDB 进入状态。</p>
<h2 id="C-Configuration-Parameters"><a href="#C-Configuration-Parameters" class="headerlink" title="C. Configuration Parameters"></a>C. Configuration Parameters</h2><blockquote>
<p>Our goal is to study the performance of Fabric under various conditions to understand how choices of different facets of the system affect performance. However, the parameter space is wide and we limit our choices to comprehensively cover a few components and look widely at other aspects of the system so that we can identify interplay of component level choices. To this end, we choose to understand and characterize the overall performance primarily from a peer’s perspective. More specifically, we keep the Orderer, Gossip (physical network) etc. static so that it does not affect our experiments and observations. Next, we describe the five parameters considered in this study and their significance.</p>
</blockquote>
<p>我们的目标是研究各种条件下 Fabric 的性能，以了解系统不同方面的选择如何影响性能。 但是，参数有很多，我们将选择范围限制为全面涵盖几个组件，并广泛查看系统的其他方面，以便我们可以识别组件级别选择的相互影响。 为此，我们选择主要从节点的角度来理解和表征整体绩效。 更具体地说，我们将排序节点，Gossip（物理网络）等保持静态，以免影响我们的实验和观察结果。 接下来，我们描述了这项研究中考虑的五个参数及其意义。</p>
<h3 id="1-Block-Size"><a href="#1-Block-Size" class="headerlink" title="1) Block Size"></a>1) Block Size</h3><blockquote>
<p>Transactions are batched at the orderer and delivered as a block to peers using a gossip protocol. Each peer processes one block at a time. Cryptographic processing like orderer signature verification is done per-block unlike transaction endorsement signatures verification, which is pertransaction. Varying blocksize also brings in the throughputvs-latency tradeoff and for a better picture, we study it in conjunction with the transaction arrival rate.</p>
</blockquote>
<p>交易在排序节点处分批处理，并打包后使用 gossip 协议交付给对等节点。 每个对等节点一次处理一个块。 像排序节点验签这样的加密处理是按块完成的，这与交易背书验签（即每笔交易）不同。 变化的块大小还会带来吞吐量与延迟之间的权衡，为了更好地了解情况，我们结合交易到达率对其进行了研究。</p>
<h3 id="2-Endorsement-Policy"><a href="#2-Endorsement-Policy" class="headerlink" title="2) Endorsement Policy"></a>2) Endorsement Policy</h3><blockquote>
<p>An endorsement policy dictates how many executions of a transaction and signing need to happen before a transaction request can be submitted to the orderer so that the transaction can pass the VSCC validation phase at peers. The VSCC validation of a transaction’ endorsements require evaluation of endorsement policy expression against the collected endorsements and checking for satisfiability, which is NP-Complete. Additionally, a check includes verifying that the identity and its signature. The complexity of the endorsement policy will affect resources and the time taken to collect and evaluate it.</p>
</blockquote>
<p>背书策略指示在可以将交易请求提交给排序节点之前，需要执行多少交易和签名，以便交易可以在对等节点中通过 VSCC 验证阶段。 VSCC 对交易背书的验证需要根据收集的背书和检查可满足性来评估背书策略表示，即 NP 完全。 另外，检查包括验证身份及其签名。 背书政策的复杂性将影响资源以及收集和评估它的时间。</p>
<h3 id="3-Channel"><a href="#3-Channel" class="headerlink" title="3) Channel"></a>3) Channel</h3><blockquote>
<p>Channels isolate transactions from one another. Transactions submitted to different channels are ordered, delivered and processed independent of each other, albeit on same peers. Channels bring inherent parallelism to various aspects of transaction processing in the Fabric. While number of channels to use, and what channels to transact on is determined by the application and participant combinatorics, it has significant implications on platform performance and scalability.</p>
</blockquote>
<p>通道将交易彼此隔离。 提交到不同通道的交易彼此独立地进行排序，交付和处理，尽管它们在同一对等节点上。 通道为结构中交易处理的各个方面带来了固有的并行性。 尽管使用的通道数量以及要进行交易的通道由应用程序和参与者组合程序确定，但它对平台性能和可扩展性具有重大影响。</p>
<h3 id="4-Resource-Allocation"><a href="#4-Resource-Allocation" class="headerlink" title="4) Resource Allocation"></a>4) Resource Allocation</h3><blockquote>
<p>Peers run CPU-intensive signature computation and verification routines as part of system chaincodes. User chaincodes executed by endorsing peers during transaction simulation add to this mix. We vary the number of CPU cores on peer nodes to study its effect. While network characteristics are important, we assume a datacenter or high bandwidth network with very low latency for this study.</p>
</blockquote>
<p>对等节点 将 CPU 密集型签名计算和验证例程作为系统链码的一部分运行。 在交易模拟过程中通过背书对等节点执行的用户链码将添加到此组合中。 我们改变对等节点上 CPU 内核的数量以研究其效果。 尽管网络特性很重要，但我们假设此研究的数据中心或高带宽网络具有极低的延迟。</p>
<h3 id="5-Ledger-Database"><a href="#5-Ledger-Database" class="headerlink" title="5) Ledger Database"></a>5) Ledger Database</h3><blockquote>
<p>Fabric supports two alternatives for key-value store, CouchDB and GoLevelDB to maintain the current state. Both are key-value stores, while GoLevelDB is an embedded database, CouchDB uses a client-server model (accessed using REST API over a secure HTTP) and supports document/JSON data-model.</p>
</blockquote>
<p>Fabric 支持键值存储的两种方案，即 CouchDB 和 GoLevelDB 以维护当前状态。 两者都是键值存储，而 GoLevelDB 是嵌入式数据库，而 CouchDB 使用客户端-服务器模型（通过 REST API 通过安全的 HTTP 访问），并支持 文档/JSON 数据模型。</p>
<h1 id="III-PROBLEM-STATEMENT"><a href="#III-PROBLEM-STATEMENT" class="headerlink" title="III. PROBLEM STATEMENT"></a>III. PROBLEM STATEMENT</h1><blockquote>
<p>The two primary goals of our work are:</p>
</blockquote>
<p>我们工作的两个主要目标是：</p>
<h2 id="1-Performance-Benchmarking"><a href="#1-Performance-Benchmarking" class="headerlink" title="1) Performance Benchmarking"></a>1) Performance Benchmarking</h2><blockquote>
<p>To conduct an in-depth study of Fabric core components and benchmark Fabric performance for common usage patterns. We aim to study the throughput and latency characteristics of the system when varying the configuration of parameters listed §II-C to understand the relationship between the performance metrics and parameters. Based on our observations, we aim to derive and present a few high-level guidelines, which would be valuable to developers and deployment engineers.</p>
</blockquote>
<p>对 Fabric 核心组件进行深入研究，并针对常见使用模式对基准 Fabric 性能进行基准测试。 当更改 §II-C 中列出的参数配置时，我们旨在研究系统的吞吐量和延迟特性，以了解性能指标与参数之间的关系。 根据我们的观察，我们旨在推导并提出一些高级指南，这些指南对于开发人员和部署工程师而言非常有价值。</p>
<h2 id="2-Optimization"><a href="#2-Optimization" class="headerlink" title="2) Optimization"></a>2) Optimization</h2><blockquote>
<p>To identify bottlenecks using code-level instrumentation and to draw out action items to improve the overall performance of Fabric. On identifying bottlenecks, our goal is to introduce and implement optimizations to alleviate these bottlenecks.</p>
</blockquote>
<p>使用代码级工具识别瓶颈并制定行动项目以提高 Fabric 的整体性能。 在确定瓶颈方面，我们的目标是引入并实施优化措施以缓解这些瓶颈。</p>
<h1 id="IV-EXPERIMENTAL-METHODOLOGY"><a href="#IV-EXPERIMENTAL-METHODOLOGY" class="headerlink" title="IV. EXPERIMENTAL METHODOLOGY"></a>IV. EXPERIMENTAL METHODOLOGY</h1><blockquote>
<p>We study the throughput and latency as the primary performance metrics for Fabric. </p>
<p><em>Throughput</em> is the rate at which transactions are committed to ledger. </p>
<p><em>Latency</em> is the time taken from application sending the transaction proposal to the transaction commit and is made up of the following latencies:</p>
</blockquote>
<p>我们将吞吐量和延迟作为 Fabric 的主要性能指标进行研究。</p>
<p>吞吐量是将交易提交到账本的速率。</p>
<p>等待时间是指从应用程序发送交易提案到提交交易所花费的时间，由以下等待时间组成：</p>
<blockquote>
<ul>
<li><em>Endorsement latency</em> – the time taken for the client to collect all proposal responses along with the endorsements.</li>
<li><em>Broadcast latency</em> – the time delay between client submitting to orderer and orderer acknowledges the client.</li>
<li><em>Commit latency</em> – the time taken for the peer to validate and commit the transaction.</li>
<li><em>Ordering latency</em> – the time transaction spent on the ordering service. As the performance of ordering service is not studied in this work, we are not presenting this latency. </li>
</ul>
</blockquote>
<ul>
<li><p>背书延迟 ：客户端收集所有提案回复以及背书的时间。</p>
</li>
<li><p>广播延迟：客户端提交到排序节点和排序节点通知客户端的时间。</p>
</li>
<li><p>提交延迟：对等节点验证并提交交易所需的时间。</p>
</li>
<li><p>排序延迟：交易花费在排序服务的时间。由于本文未研究排序服务的性能，因此我们不介绍这种延迟。</p>
</li>
</ul>
<blockquote>
<p>Further, we define the following three latency at block level:</p>
<ul>
<li><em>VSCC validation latency</em> – the time taken to validate all transactions’ endorsement signature set (in a block) against the endorsement policy.</li>
<li><em>MVCC validation latency</em> – the time taken to validate all transactions in a block by employing multi-version concurrency control as described in §II-B.</li>
<li><em>Ledger update latency</em> – the time taken to update the state database with write-set of all valid transactions in a block.</li>
</ul>
</blockquote>
<p>此外，我们在块级别定义了以下三个延迟：</p>
<ul>
<li>VSCC 验证延迟：根据背书策略验证所有交易的背书签名集（以块为单位）所花费的时间。</li>
<li>MVCC 验证等待时间：通过采用第 II-B 节所述的多版本并发控制来验证一个区块中所有交易所需的时间。</li>
<li>账本更新等待时间：块中所有有效交易的写集更新状态数据库所花费的时间。</li>
</ul>
<blockquote>
<p>Since one of the major goal of this work is to identify performance bottlenecks, our load generator spans multiple clients each stresses the system by continuously generating transactions instead of following a distribution model (say, Poisson). Each client also sends proposal requests in parallel and collates endorsements. The transactions are submitted asynchronously to achieve the specified rate without waiting for commits. However, the benchmark framework tracks commit using our tools named <em>fetch-block</em> to calculate throughput and latency. Further, we instrumented the Fabric source code to collect fine-grained latency such as MVCC latency and others latencies. For multi-channel experiments, all organizations and all its peers join the channel. While other combinations are possible, we believe our approach will stress test the system.</p>
</blockquote>
<p>由于这项工作的主要目标之一是确定性能瓶颈，因此我们的负载生成器跨越多个客户端，每个客户端通过连续生成交易而不是遵循分发模型（例如 Poisson）来给系统施加压力。 每个客户还并行发送提案请求并收集背书。 为了达到指定的速率，交易是异步提交的，无需等待提交。 然而，基准框架使用名为 fetch-block 的工具来跟踪提交，以计算吞吐量和延迟。 此外，我们检测了 Fabric 源代码，以收集细粒度的延迟，例如 MVCC 延迟和其他延迟。 对于多通道实验，所有组织及其所有对等节点都加入了通道。 尽管其他组合也是可能的，但我们认为我们的方法将对系统进行压力测试。</p>
<h2 id="A-Setup-and-Workloads"><a href="#A-Setup-and-Workloads" class="headerlink" title="A. Setup and Workloads"></a>A. Setup and Workloads</h2><blockquote>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200406170256066.png" alt="image-20200406170256066" style="zoom:50%;">

<p>Our test Fabric network consists of 4 organizations, each with 2 endorsing peers for a total of 8 peer nodes as depicted in Figure 3. There is 1 orderer node with a kafka-zookeeper cluster backing it. All nodes and kafka-zookeeper run on the x86 64 virtual machines in a IBM SoftLayer Datacenter. Each virtual machine is allocated 32 vCPUs of Intel(R) Xeon(R) CPU E5-2683 v3 @ 2.00GHz and 32 GB of memory. The three powerful client machines used to generate load was allocated with 56 vCPUs and 128 GB memory. Nodes are connected to the 3 Gbps Datacenter network.</p>
</blockquote>
<p>如图3所示，我们的测试 Fabric 网络由 4 个组织组成，每个组织都有 2 个背书节点，总共 8 个对等节点。有 1 个带有 kafka-zookeeper 集群的排序节点。 所有节点和 kafka-zookeeper 在 IBM SoftLayer 数据中心的 x86 64 虚拟机上运行。 每个虚拟机都分配了 32 个 Intel®Xeon®CPU E5-2683 v3 vCPU @ 2.00GHz 和 32 GB 内存。 用于生成负载的三台强大的客户端计算机分配了 56 个 vCPU 和 128 GB 内存。 节点已连接到 3 Gbps 数据中心网络。</p>
<blockquote>
<p>In the lack of standard benchmarks for Blockchain, we built our own benchmarks by surveying around 12 internal customer solutions built on Fabric for diverse use cases. We identified common defining patterns, data models, and requirements across the board. </p>
<p>One of the recurrent pattern is for each chaincode invocation to operate on exactly one asset or unit of data with the identifier being passed to it. The query logic is done by higher level application layers, often without querying blockchain data. This pattern is modelled as simple writeonly transactions (1w, 3w and 5w denoting number of keys written) in our benchmark. </p>
<p>Another common pattern is for a chaincode to read-and-write a small set of keys, like read a JSON document, update a field and write it back. We model these as read-writes of 1, 3 and 5 keys. As we have modeled our benchmark to imitate real world blockchain applications in production, we have not considered other macro benchmarks.</p>
</blockquote>
<p>在缺乏区块链标准基准的情况下，我们通过调查基于 Fabric 的 12 种内部客户解决方案的不同案例，建立了自己的基准。 我们确定了通用的定义模式，数据模型和全面的要求。 </p>
<p>循环模式之一是，每次链码调用都只对一个资产或数据单元进行操作，并将标识符传递给它。 查询逻辑由高层应用程序层完成，通常无需查询区块链数据。 在我们的基准中，此模式被建模为简单的只写交易（1w，3w 和 5w 表示写入的密钥数）。 </p>
<p>另一种常见模式是链码读写少量密钥，例如读取 JSON文档，更新字段并将其写回。 我们将这些模型建模为 1、3和 5 键的读写。 由于我们已经建立了基准模型来模拟生产中的现实世界中的区块链应用程序，因此我们没有考虑其他宏观基准。</p>
<h1 id="V-EXPERIMENTAL-RESULTS"><a href="#V-EXPERIMENTAL-RESULTS" class="headerlink" title="V. EXPERIMENTAL RESULTS"></a>V. EXPERIMENTAL RESULTS</h1><blockquote>
<p>In this section, we study the impact of various configurable parameters listed in §II-C on the performance of Hyperledger Fabric. The throughput and transaction latency presented in this section are averaged over multiple runs. In total, we conducted more than 1000s of experiments.</p>
</blockquote>
<p>在本节中，我们研究 §II-C 中列出的各种可配置参数对 Hyperledger Fabric 性能的影响。 本节介绍的吞吐量和交易延迟是多次运行的平均值。我们总共进行了 1000 多次实验。</p>
<h2 id="A-Impact-of-Transaction-Arrival-Rate-and-Block-Size"><a href="#A-Impact-of-Transaction-Arrival-Rate-and-Block-Size" class="headerlink" title="A. Impact of Transaction Arrival Rate and Block Size"></a>A. Impact of Transaction Arrival Rate and Block Size</h2><blockquote>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200406181747147.png" alt="image-20200406181747147" style="zoom:50%;">

<p>Figure 4 plots the average throughput and latency for various block sizes over different transaction arrival rates. Table II presents various transaction arrival rates and block sizes used. For other parameters, refer to Table I.</p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200406165940078.png" alt="image-20200406165940078" style="zoom:50%;">

<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200406170227600.png" alt="image-20200406170227600" style="zoom:50%;">
</blockquote>
<p>图 4 绘制了不同交易到达速率下各种块大小的平均吞吐量和延迟。 </p>
<p>表 II 列出了使用的各种交易到达率和块大小。</p>
<p>有关其他参数，请参阅表 I。</p>
<h3 id="Observation-1"><a href="#Observation-1" class="headerlink" title="Observation 1:"></a>Observation 1:</h3><blockquote>
<p><em>With an increase in transaction arrival rate, the throughput increased linearly as expected till it flattened out at around 140 tps, the saturation point</em> as shown in Figure 4. </p>
<p><em>When the arrival rate was close to or above the saturation point, the latency increased significantly (i.e., from an order of 100s of ms to 10s of seconds)</em>. This is because the number of ordered transactions waiting in the VSCC queue during validation phase grew rapidly (refer to Figure 5) which affected the commit latency. </p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200406182608909.png" alt="image-20200406182608909" style="zoom:50%;">

<p>However, with further increase in the arrival rate, we observed no impact on the endorsement and broadcast latency but commit latency. This is because VSCC utilized only a single vCPU and hence new transaction proposals utilized other vCPUs on the peer for simulation and endorsement. As a result, only the validation phase became a bottleneck. </p>
<p>In this experiment, the endorsement and broadcast latency was around 12 ms and 9 ms, respectively.</p>
</blockquote>
<p>如图4所示，<em>随着交易到达率的增加，吞吐量按预期线性增长，直到达到饱和点 140 tps时才趋于平坦</em>。</p>
<p><em>当到达率接近或高于饱和点时，延迟显着增加（即从100毫秒到10秒的数量级）</em>。 这是因为在验证阶段在 VSCC 队列中等待的排序交易数量迅速增长（请参阅图5），这影响了提交延迟。 </p>
<p>但是，随着到达率的进一步提高，我们发现对背书和广播延迟没有影响，但是对提交延迟有影响 。 这是因为 VSCC 仅使用单个 vCPU，因此新的交易提案使用对等节点的其他 vCPU 进行模拟和背书。 结果，只有验证阶段才成为瓶颈。 </p>
<p>在此实验中，背书和广播延迟分别约为 12 毫秒和 9 毫秒。</p>
<h3 id="Observation-2"><a href="#Observation-2" class="headerlink" title="Observation 2:"></a>Observation 2:</h3><blockquote>
<p><em>For an arrival rate lower than the saturation point, with an increase in the block size, the latency increased</em>. For e.g., when the arrival rate was 50 tps, with an increase in the block size from 10 to 100, the transaction latency increased 5-fold, from 242 ms to 1250 ms. </p>
<p>The reason is that with an increase in the block size, the block creation time at the orderer increased and hence, on average, a transaction had to wait at the orderer for a little longer. For e.g., when the transaction arrival rate was 100 tps, for the block size of 50 and 100, the block creation rate was 2 and 1 block(s) per second, respectively, causing latency to double.</p>
</blockquote>
<p><em>对于低于饱和点的到达率，随着块大小的增加，等待时间会增加</em>。 例如，当到达速率为 50 tps 时，随着块大小从 10 增加到 100，交易延迟增加了 5 倍，从 242 毫秒增加到 1250 毫秒。 </p>
<p>原因是随着块大小的增加，排序节点的块创建时间增加，因此，平均而言，每个交易必须在排序节点等待更长的时间。 例如，当交易到达速率为 100 tps时，对于 50 和 100 的块大小，块创建速率分别为每秒 2 个和 每秒 1 个，从而导致等待时间加倍。</p>
<h3 id="Observation-3"><a href="#Observation-3" class="headerlink" title="Observation 3:"></a>Observation 3:</h3><blockquote>
<p><em>For an arrival rate greater than the saturation point, with an increase in the block size, the latency decreased.</em> For e.g., when the arrival rate was 150 tps, with an increase in block size from 10 to 200, the transaction latency decreased from 14 secs to 10 secs. </p>
<p>This is because the time taken to validate and commit a block of size n was always lesser than the time taken to validate and commit m blocks each of size n/m. As a result, throughput also increased by m 3.5%. </p>
<p>Note that the block creation rate at orderer node was always greater than the processing rate at validator irrespective of block size and arrival rate.</p>
</blockquote>
<p><em>对于到达率大于饱和点的情况，随着块大小的增加，等待时间减少。</em>例如，当到达率为 150 tps 时，块大小从 10增加到 200，交易延迟从 14 秒减少到 10 秒。 </p>
<p>这是因为验证和提交大小为 n 的块所需的时间总是比验证和提交大小为 n/m 的 m 个块所需的时间短。 结果，吞吐量也增加了 3.5％。 </p>
<p>请注意，无论块大小和到达速度如何，在排序节点上的块创建速度始终大于验证节点的处理速度。</p>
<h3 id="Observation-4"><a href="#Observation-4" class="headerlink" title="Observation 4:"></a>Observation 4:</h3><blockquote>
<p><em>For a block size, the latency increases as arrival rate increases below the block size as the threshold. The latency decreases as arrival rate increases above the block size</em>. For lower block sizes and at higher arrival rates, blocks were created faster (rather than waiting for a block timeout) which reduced the transaction waiting time at the orderer node. In contrast, for instance, when the block size was 100 and arrival rate increased from 25 to 75 tps, the latency increased from 900 ms to 1250 ms. The reason is that with the increase in rate, the number of transactions in a block increased and so did the time taken by validation and commit phase. Note that if block size limit was not reached within a second, a block was created due to a block timeout.</p>
</blockquote>
<p><em>对于块大小，阈值以下延迟随着到达率增加而增加。 阈值以上随着到达速率增加而减少</em>。对于较小的块大小和较高的到达率，创建块的速度更快（而不是等待块超时），这减少了排序节点的交易等待时间。 相反，例如，当块大小为 100 并且到达速率从 25 tps 增加到 75 tps 时，延迟从 900 ms 增加到 1250 ms。 </p>
<p>原因是随着速率的增加，一个区块中的交易数量增加了，验证和提交阶段所花费的时间也增加了。</p>
<p>请注意，如果在一秒钟内未达到块大小限制，则由于块超时而创建了一个块。</p>
<h3 id="Observation-5"><a href="#Observation-5" class="headerlink" title="Observation 5:"></a>Observation 5:</h3><blockquote>
<p><em>Even at the peak throughput, the resources utilization was very low</em>. With an increase in the arrival rate from 25 to 175 tps, the avg CPU utilization merely increased from 1.4% to 6.7%. The reason is that the CPU intensive task performed during VSCC validation phase of a block (i.e., verification of signatures set against endorsement policy for each transaction) processed only one transaction at a time. Due to this serial execution, only one vCPU was utilized.</p>
</blockquote>
<p><em>即使在峰值吞吐量下，资源利用率也很低</em>。 随着到达速度从 25 tps 增加到 175 tps，平均 CPU 利用率仅从 1.4％ 增加到 6.7％。 </p>
<p>原因是，在一个块的 VSCC 验证阶段（即，针对每个交易的根据背书策略进行的验签）执行的 CPU 密集型任务一次仅处理一个交易。 由于串行执行，因此仅使用了一个 vCPU。</p>
<h3 id="Guideline-1"><a href="#Guideline-1" class="headerlink" title="Guideline 1:"></a>Guideline 1:</h3><blockquote>
<p>When the transaction arrival rate is expected to be lower than the saturation point, to achieve a lower transaction latency for applications, always use a lower block size. In such cases, the throughput will match the arrival rate.</p>
</blockquote>
<p>当预计交易到达率低于饱和点时，要实现较低的应用程序交易延迟，请始终使用较小的块大小。 在这种情况下，吞吐量将与到达速率匹配。</p>
<h3 id="Guideline-2"><a href="#Guideline-2" class="headerlink" title="Guideline 2:"></a>Guideline 2:</h3><blockquote>
<p>When the transaction arrival rate is expected to be high, to achieve a higher throughput and a lower transaction latency, always use a higher block size.</p>
</blockquote>
<p>当预计交易到达率很高时，要实现更高的吞吐量和更低的交易延迟，请始终使用更大的块大小。</p>
<h3 id="Action-Item-1"><a href="#Action-Item-1" class="headerlink" title="Action Item 1:"></a>Action Item 1:</h3><blockquote>
<p>CPU resources are under-utilized. A potential optimization would be to process multiple transactions at a time during the VSCC validation phase as shown in §VI-B.</p>
</blockquote>
<p>CPU资源利用不足。 潜在的优化将是在 VSCC 验证阶段一次处理多个交易，如 §VI-B 所示。</p>
<h2 id="B-Impact-of-Endorsement-Policy"><a href="#B-Impact-of-Endorsement-Policy" class="headerlink" title="B. Impact of Endorsement Policy"></a>B. Impact of Endorsement Policy</h2><blockquote>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200406185423203.png" alt="image-20200406185423203" style="zoom:50%;">

<p>Figure 6 plots the throughput and latency for various endorsement policies defined using both AND/OR and NOutOf syntax over different transaction arrival rates. </p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200406185445094.png" alt="image-20200406185445094" style="zoom:50%;">

<p>Table III presents various policies used in this study. </p>
<p>Note that ‘a’, ‘b’, ‘c’ and ‘d’ denotes four different organizations. For other parameters, refer to Table I. </p>
<p>Though the syntax (AND/OR, NOutOf) used to define the four endorsement policies are different, semantically they are same. For e.g., 3rd policy listed in both syntax denotes that any three organizations endorsement is adequate to pass the VSCC validation.</p>
</blockquote>
<p>图 6 绘制了使用 AND / OR 和 NOutOf 语法定义的各种背书策略在不同交易到达率上的吞吐量和延迟。</p>
<p>表 III 列出了本研究中使用的各种策略。</p>
<p>请注意，“ a”，“ b”，“ c” 和 “ d” 表示四个不同的组织。 有关其他参数，请参阅表 I 。</p>
<p>尽管用于定义四个背书策略的语法（AND / OR，NOutOf）不同，但从语义上讲它们是相同的。 例如，两种语法中列出的第三个策略表示，任意三个组织的认可都足以通过 VSCC 验证。</p>
<h3 id="Observation-6"><a href="#Observation-6" class="headerlink" title="Observation 6:"></a>Observation 6:</h3><blockquote>
<p><em>A combination of a number of sub-policies and a number of crypto signatures verification impacted the performance</em> as shown in Figure 6. The 1st and 4th AND/OR policies, having no sub-policies, performed the same as NOutOf policies due to a few signatures verification. With sub-policies, both the number of sub-policies (i.e., search space) and the number of signatures dictated the performance. For e.g., the throughput achieved with 2nd &amp; 3rd AND/OR policies was 7% &amp; 20% lesser than other policies, respectively.</p>
</blockquote>
<p>如图6所示，<em>子策略和加密签名验证的组合会影响性能</em>。由于签名验证的原因，没有子策略的第 1 和第 4 个 AND / OR 策略的执行效果与 NOutOf 策略相同。 有子策略的情况下，子策略的数量（即搜索空间）和签名的数量都决定了性能。 例如，使用第二个和第三个AND / OR 策略实现的吞吐量分别比其他策略低 7％和20％。</p>
<blockquote>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200406185534544.png" alt="image-20200406185534544" style="zoom:50%;">

<p>Figure 7 plots the VSCC latency and the resource utilization at a peer node for various policies. With an increase in the number of signatures verification (specifically for NOutOf), the VSCC latency increased linearly from 68 ms to 137 ms. When there were sub-policies (as with 2nd and 3rd AND/OR policies), the VSCC latency increased significantly (i.e., 172 ms and 203 ms, respectively). A similar trend for resource utilization as show in Figure 7(b). </p>
<p>Note that the block bytes increased with increase in the number of endorsements due to the number of x.509 certificates encoded in each transaction.</p>
</blockquote>
<p>图 7 绘制了各种策略下的 VSCC 延迟和对等节点上的资源利用率。 随着签名验证数量的增加（特别是对于NOutOf），VSCC 延迟从 68 ms 线性增加到 137 ms。 当存在子策略时（与第 2 和第 3 AND / OR策略一样），VSCC 延迟显着增加（即分别为 172 ms 和 203 ms）。 资源利用率趋势类似，如图7（b）所示。 </p>
<p>请注意，由于每个交易中编码的 x.509 证书数量增加，因此块字节随着背书数量的增加而增加。</p>
<blockquote>
<p>There are three major CPU intensive operations during the policy validation phase (excluding the check for satisfiability) which are listed below.</p>
<p>1) Deserialization of identity (i.e., x.509 certificate). </p>
<p>2) Validation of identity with organization MSP. </p>
<p>3) Verification of signature on the transaction data.</p>
</blockquote>
<p>在策略验证阶段有3个主要的CPU密集型操作（不包括满足性检查），如下所示。</p>
<p>1）身份的反序列化（即 x.509 证书）。</p>
<p>2）与组织 MSP 一起验证身份。</p>
<p>3）验证交易数据上的签名。</p>
<blockquote>
<p>Hence, with an increase in the sub-policies (i.e., search space), the number of identities &amp; signatures to be validated, both CPU utilization and VSCC latency increased. It is interesting to note that the MSP identifier is not sent along with x.509 certificate. As a result, the policy evaluator has to validate each x.509 certificate with multiple organization MSPs to identify the correct one. For a 5 minutes run at an arrival rate of 150 tps, we observed 220K such validation out of which 96K validation failed that resulted in wastage of CPU and time.</p>
</blockquote>
<p>因此，随着子策略（即搜索空间）、要验证的身份和签名的数量的增加， CPU 利用率和 VSCC 延迟都增加了。 有趣的是，MSP 标识符没有与 x.509 证书一起发送。 结果，策略评估者必须使用多个组织 MSP 验证每个 x.509 证书，以识别出正确的证书。 以 150 tps 的到达速度运行了 5 分钟，我们观察到 220K 这样的验证，其中 96K 验证失败，这导致 CPU 和时间的浪费。</p>
<h3 id="Guideline-3"><a href="#Guideline-3" class="headerlink" title="Guideline 3:"></a>Guideline 3:</h3><blockquote>
<p>To achieve a high performance, define policies with a fewer number of sub-policies and signatures.</p>
</blockquote>
<p>要获得高性能，定义策略时使用较少的子策略和签名。</p>
<h3 id="Action-Item-2"><a href="#Action-Item-2" class="headerlink" title="Action Item 2:"></a>Action Item 2:</h3><blockquote>
<p>As the cryptography operations are CPU intensive, we can avoid certain routine operations by maintaining a cache of deserialized identity and their MSP information as shown in §VI-A. This does not introduce a security risk as identities are long-lived and separate Certificate Revocation Lists (CRLs) are maintained.</p>
</blockquote>
<p>由于加密操作是 CPU 密集型操作，我们可以通过维护反序列化身份及其 MSP 信息的缓存来避免某些常规操作，如第 VI-A 节所示。这不会带来安全风险，因为身份是长期的，并且维护单独的证书吊销列表（CRL）。</p>
<h2 id="C-Impact-of-Channels-and-Resource-Allocation"><a href="#C-Impact-of-Channels-and-Resource-Allocation" class="headerlink" title="C. Impact of Channels and Resource Allocation"></a>C. Impact of Channels and Resource Allocation</h2><blockquote>
<p>We categorize the arrival rate for different channel count into two categories; non-overloaded when the latency range was [0.4-1s] and overloaded when the latency range was [30-40s]. Figure 8 plots the average throughput and CPU utilization for these two categories. Table IV presents a various number of channels and transaction arrival rate used for this study. For other parameters, refer to Table I. All peers joined all the channels as described in §IV.</p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200416232925323.png" alt="image-20200416232925323" style="zoom:50%;">
</blockquote>
<p>我们将不同通道数的到达率分为两类： 时延范围为[0.4-1s]时不过载，时延范围为[30-40s]时过载。 图8绘制了这两类的平均吞吐量和CPU利用率。 表IV列出了用于此研究的各种通道和交易到达率。 有关其他参数，请参阅表I。所有对等方都按照§IV中的说明加入了所有通道。</p>
<h3 id="Observation-7"><a href="#Observation-7" class="headerlink" title="Observation 7:"></a>Observation 7:</h3><blockquote>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200406223431746.png" alt="image-20200406223431746" style="zoom:50%;">

<p><em>With the increase in the number of channels, the throughput increased and latency decreased. The resource utilization such as CPU also increased</em> as shown in Figure 8. For e.g., with the increase in the number of channels from 1 to 16, the throughput increased from 140 tps to 832 tps (i.e., by 6× in non-overloaded case) and to 1320 tps (i.e., 9.5× in overloaded case). This is because each channel is independent of others and maintains its own chain of blocks. Hence, the validation phase and the final ledger update of multiple blocks (one per channel) executed in parallel which increased CPU utilization that resulted in higher throughput.</p>
</blockquote>
<p>如图 8 所示，<em>随着通道数的增加，系统的吞吐量增加，时延减小。CPU 等资源利用率也增加了</em>。例如，随着信道数目从 1 增加到 16，吞吐量从 140 tps 增加到 832 tps（即，在非过载情况下增加 6 倍）或增加到 1320 tps（即，在过载情况下增加 9.5 倍）。这是因为每个通道都独立于其他通道，并维护自己的区块链。因此，多个块（每个通道一个）的验证阶段和最终账本的更新都是并行执行，这提高了 CPU 利用率，从而提高了吞吐量。</p>
<blockquote>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200406223953830.png" alt="image-20200406223953830" style="zoom:50%;">

<p>Figure 9(a) and (b) plot the throughput, endorsement &amp; commit latency for 4 and 16 channels, respectively, over a different number of allocated vCPUs but homogeneous peers. Figure 9(c) plots the absolute (instead of average) CPU utilization across all vCPUs. Table V presents a various number of vCPUs allocated, the number of channels and transaction arrival rate used. For other parameters, refer to Table I. </p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200408103129527.png" alt="image-20200408103129527" style="zoom:50%;">
</blockquote>
<p>图9（a）和（b）分别绘制了 4 个和 16 个通道在同构节点但不同数量的 vcpu 分配上的吞吐量、背书和提交延迟。图9（c）描绘了所有 vcpu 的绝对（而不是平均）CPU 利用率。表 V 显示了分配的各种 VCPU 数、使用的通道数和交易到达率。其它参数见表 I。</p>
<h3 id="Observation-8"><a href="#Observation-8" class="headerlink" title="Observation 8:"></a>Observation 8:</h3><blockquote>
<p><em>At moderate loads, when the number of vCPUs allocated were lesser than the channel count, performance degraded</em>. For e.g., When the number of vCPUs allocated were lesser than 16 for 16 channels, the throughput reduced significantly from 848 tps to 32 tps (by 26×) – refer to Figure 9(b). </p>
<p>Further, both the average endorsement and commit latency exploded (from 37 ms to 21 s, and 640 ms to 49 s, respectively) due to a lot of contention on the CPU. </p>
<p>Further, a significant number of requests got a timeout during the endorsement phase. Once a timeout occurs, we marked that transaction as failed. With an allocation of 2 vCPUs, a higher number of endorsement requests got a timeout as compared to 4 vCPUs. Thus, the endorsement and commit latency (of successful transactions) observed with 2 vCPUs were lesser than 4 vCPUs as shown in Figure 9(b).</p>
</blockquote>
<p><em>在中等负载下，当分配的 vCPU 数量少于通道数量时，性能会下降</em>。 例如，当分配的 vCPU 数量少于 16 个通道的 16 个时，吞吐量从 848 tps 显着降低到 32 tps（降低了26倍）–参见图9（b）。 </p>
<p>此外，由于 CPU 上的大量争用，背书和提交的平均延时都爆炸了（分别从 37 ms到 21s 和 640 ms 到 49 s）。</p>
<p> 此外，在背书阶段，大量签名请求超时。 一旦超时，我们将该交易标记为失败。 与 4 个 vCPU 相比，分配 2 个 vCPU 会导致更多的背书请求超时。 因此，如图9（b）所示，使用 2 个 vCPU 观察到的（成功交易）背书和提交等待时间小于 4 个 vCPU。</p>
<blockquote>
<p>Due to the CPU contention, the VSCC latency also increased that affected the commit latency as shown in Figure 9(c). Increasing the vCPUs allocation increased CPU utilization and consequently performance up-to a peak where vCPUs matched the number of channels. Beyond this, additionally allocated vCPUs were idle due to the single-threaded sequential VSCC validation – refer to Figure 9(c).</p>
</blockquote>
<p>由于 CPU 争用，VSCC 延迟也增加了，这影响了提交延迟，如图9（c）所示。 增加 vCPU 分配增加了 CPU 利用率，因此性能达到了 vCPU 与通道数匹配的峰值。 除此之外，由于单线程顺序 VSCC 验证，额外分配的 vCPU 处于空闲状态 – 参见图9（c）。</p>
<blockquote>
<p>Figure 9(d) plot the throughput and latency for 16 channels in a heterogeneous setup. Table VI presents a various number of vCPUs allocated for different peers to enable heterogeneity, the number of channels, transaction complexity and transaction arrival rate used. For other parameters, refer to Table I.</p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200408104549524.png" alt="image-20200408104549524" style="zoom:50%;">
</blockquote>
<p>图9（d）绘制了异构设置中 16 个通道的吞吐量和等待时间。 表 VI 列出了分配给不同节点的各种 vCPU，以实现异构性、通道数、交易复杂性和所使用的交易到达率。 有关其他参数，请参阅表 I。</p>
<h3 id="Observation-9"><a href="#Observation-9" class="headerlink" title="Observation 9:"></a>Observation 9:</h3><blockquote>
<p><em>At moderate loads, even when the number of vCPUs allocated for 2 peers out of 8 were lesser than the channel count, performance degraded</em>. For e.g., when only 2 vCPUs were allocated for 2 peers (others with 32 vCPUs), the throughput reduced from 848 tps to 417 tps (by 2×) for write-only transactions and to 307 tps (by 2.7×) for readwrite transactions. </p>
<p>The reasons for the reduction are twofold, endorsement requests timeout from less powerful peers and MVCC conflicts specifically for read/write transactions. </p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200408104913866.png" alt="image-20200408104913866" style="zoom:50%;">

<p>Figure 10(a) plots the endorsement requests timeout, valid transactions and invalid transactions due to MVCC conflicts for readwrite transactions. With an increase in the number of less powerful peers, the endorsement requests timeout increased. </p>
<p>Further, a higher proportion of total submitted transactions became invalid due to MVCC conflicts. The is because of the lower block commit rate at less powerful peers as compared to powerful peers. Due to the different block height at peers (refer to Figure 10(b)), there was a mismatch of key’s version in the read-set collected. As a result, MVCC conflicts occurred during the state validation which invalidated transactions.</p>
</blockquote>
<p><em>在中等负载下，即使为 8 个中的 2 个节点分配的 vCPU 数量少于通道数，性能也会下降</em>。例如，当仅为 2 个对等节点分配 2 个 vCPU 时（其他具有 32 个vCPU），仅写交易的吞吐量从 848 tps 减少到 417 tps（2倍），而读写操作减少到307 tps（2.7倍）。</p>
<p>减少的原因有两个：支持能力较弱的节点背书请求超时，以及专门针对读/写交易的 MVCC 发生冲突。</p>
<p>图10（a）描绘了由于读写交易的 MVCC 冲突而导致的背书请求超时，有效交易和无效交易。随着能力较弱节点的数量增加，背书请求超时也增加了。</p>
<p>此外，由于 MVCC 冲突，提交的交易中有较高比例变得无效。这是因为与功能强大的节点相比，功能较弱的对等节点的块提交率较低。由于对等节点的块高度不同（请参见图10（b）），因此收集的读取集中的密钥版本不匹配。结果，在状态验证期间发生了 MVCC 冲突，使交易无效。</p>
<blockquote>
<p>Though we have not studied the impact of network resources, we believe that the impact would be similar to that of CPU. This is because, with a low network bandwidth, the delay in both the block and transaction delivery would increase. Even with the heterogeneous network resources for peers, we expect the impact to be similar to the one we observed with CPU.</p>
</blockquote>
<p>尽管我们尚未研究网络资源的影响，但我们认为影响将与 CPU 相似。 这是因为在低网络带宽的情况下，块和交易传递的延迟都会增加。 即使使用对等节点的异构网络资源，我们预期其影响与我们在 CPU 上观察到的影响相似。</p>
<h3 id="Guideline-4"><a href="#Guideline-4" class="headerlink" title="Guideline 4:"></a>Guideline 4:</h3><blockquote>
<p>To achieve higher throughput and lower latency, it is better to allocate at least one vCPU per channel. For optimal vCPU allocation, we need to determine the expected load at each channel and allocate adequate vCPUs accordingly.</p>
</blockquote>
<p>为了获得更高的吞吐量和更低的延迟，最好为每个通道分配至少一个 vCPU。 为了获得最佳的 vCPU 分配，我们需要确定每个通道的预期负载，并相应地分配足够的 vCPU。</p>
<h3 id="Guideline-5"><a href="#Guideline-5" class="headerlink" title="Guideline 5:"></a>Guideline 5:</h3><blockquote>
<p>To achieve higher throughput and lower latency, it is better to avoid heterogeneous peers as the performance would be dictated by less powerful peers.</p>
</blockquote>
<p>为了获得更高的吞吐量和更低的延迟，最好避免异构节点，因为性能将由功能较弱的节点决定。</p>
<h3 id="Action-Item-3"><a href="#Action-Item-3" class="headerlink" title="Action Item 3:"></a>Action Item 3:</h3><blockquote>
<p>Processing transactions within a channel and across channels can be improved to better utilize additional CPU power as shown in §VI-B.</p>
</blockquote>
<p>如 §VI-B 所示，可以改进通道内和通道间的交易处理，以更好地利用额外的 CPU 功能。</p>
<h2 id="D-Impact-of-Ledger-Database"><a href="#D-Impact-of-Ledger-Database" class="headerlink" title="D. Impact of Ledger Database"></a>D. Impact of Ledger Database</h2><blockquote>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200408111402250.png" alt="image-20200408111402250" style="zoom:50%;">

<p>Figure 11 plots the average throughput and latency over multiple transaction arrival rates for both GoLevelDB and CouchDB with different transaction complexities. Table VII presents various databases, transaction complexity and arrival rate used. For other parameters, refer to Table I.</p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200408111414932.png" alt="image-20200408111414932" style="zoom:50%;">
</blockquote>
<p>图 11 绘制了具有不同交易复杂性的 GoLevelDB 和 CouchDB 在多个交易到达率上的平均吞吐量和延迟。 表 VII 列出了使用的各种数据库，交易复杂性和到达率。 有关其他参数，请参阅表 I。</p>
<h3 id="Observation-10"><a href="#Observation-10" class="headerlink" title="Observation 10:"></a>Observation 10:</h3><blockquote>
<p><em>The Fabric transaction throughput with GoLevelDB as state database was 3*× *greater than CouchDB</em>. The maximum throughput achieved with GoLevelDB on a single channel was 140 tps (refer to Figure 4) while with CouchDB, it was only 50 tps (refer to Figure 11(b)). </p>
<p>Further, with an increase in the transaction complexity, i.e., for multiple writes, the throughput with CouchDB dropped from 50 tps to 18 tps while no such impact with GoLevelDB (refer to Figure 11(a)). The reason for significant performance differences between CouchDB and GoLevelDB is that the latter is an embedded database to peer process while former is accessed using REST APIs over a secure HTTP. As a result, the endorsement latency, VSCC latency, MVCC latency and the ledger update latency was higher with CouchDB as compared to the GoLevelDB as shown in Figure 12(a) &amp; (b). With CouchDB, the VSCC latency increased compared to the GoLevelDB as the peer accessed state database using a REST API call for every transaction to retrieve the endorsement policy of the chaincode on which the transaction was simulated. Similarly, the MVCC latency also increased with CouchDB.</p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200408112038781.png" alt="image-20200408112038781" style="zoom:50%;">
</blockquote>
<p><em>使用 GoLevelDB 作为状态数据库的 Fabric 交易吞吐量比 CouchDB 高 3 倍</em>。使用 GoLevelDB 在单个通道上实现的最大吞吐量为140 tps（请参见图4），而对于CouchDB，则仅为50 tps（请参见图11（b））。</p>
<p>此外，随着交易复杂度的增加，即对于多次写入，CouchDB 的吞吐量从 50 tps 下降到 18 tps，而 GoLevelDB 则没有这种影响（请参见图11（a））。 CouchDB 和 GoLevelDB 之间的显着性能差异的原因是，后者是节点进程的嵌入式数据库，而前者是通过 REST API 通过安全 HTTP 访问的。 结果如图12（a）和（b）所示，与 GoLevelDB 相比，CouchDB 的背书等待时间，VSCC 等待时间，MVCC 等待时间和账本更新等待时间更高。 与 GoLevelDB 相比，使用 CouchDB 时，VSCC 延迟增加了，因为节点访问状态数据库使用 REST API 调用每个交易来检索在其上模拟交易的链码的背书策略。 同样，CouchDB 也增加了 MVCC 延迟。</p>
<h3 id="Observation-11"><a href="#Observation-11" class="headerlink" title="Observation 11:"></a>Observation 11:</h3><blockquote>
<p><em>With CouchDB, the endorsement latency and ledger update latency increased with an increase in the number of writes per transaction</em>, i.e., from 40 ms and 240 ms with one write to 800 ms and 1200 ms with three writes, respectively, as shown in Figure 12(b) even though write-only transactions do not access the database during the endorsement phase. </p>
<p>This is because the endorsement phase acquired a shared read lock on the whole database to provide a consistent view of data (i.e., <em>repeatable read isolation level</em>) to the chaincode. Similarly, the final ledger update phase acquired an exclusive write lock on the whole database. Hence, both the endorsement phase and final ledger update contended for this resource. Especially, the final ledger update with CouchDB was costlier as it had to perform the following three tasks for each key-value write in a transaction’s write-set.</p>
</blockquote>
<p>如图12（b）所示，<em>使用 CouchDB 时，背书等待时间和账本更新等待时间随着每笔交易的写入次数的增加而增加</em>，即从一次写入的 40ms 和 240ms 增加到三次写入的 800ms 和 1200ms，即使只写交易在背书阶段也不访问数据库。 </p>
<p>这是因为背书阶段获得了整个数据库的共享读取锁定，以便为链码提供一致的数据视图（即<em>可重复读取隔离级别</em>）。 同样，最后的账本更新阶段在整个数据库上获得了排他性写锁定。 因此，背书阶段和最终账本更新都为此资源竞争。 特别是，使用 CouchDB 进行的最终账本更新成本更高，因为它必须为交易的写入集中的每个键值写入执行以下三个任务。</p>
<blockquote>
<ol>
<li>Retrieve the key’s previous revision number (used for concurrency control within CouchDB) by issuing a GET request, if it exists in the database.</li>
<li>Construct a document for the value (could be a JSON document or binary attachment).</li>
<li>Update the database by submitting a PUT request.</li>
</ol>
</blockquote>
<ol>
<li>如果数据库中存在 GET 请求，则通过发出 GET 请求来检索密钥的先前修订的版本号（用于 CouchDB 中的并发控制）。</li>
<li>为该值构造一个文档（可以是 JSON 文档或二进制附件）。</li>
<li>通过提交 PUT 请求来更新数据库。</li>
</ol>
<blockquote>
<p>As a result, with the increase in the number of writes per transaction, the ledger update latency increased (refer to Figure 12(b)). Due to the above three time consuming serial operations, we surmise that the committer held the lock on the database for a longer duration which increased endorsement latency. </p>
<p>To validate our hypothesis, we performed experiments by disabling the lock acquisition on the whole database during the endorsement phase and final ledger update. The side effect of such action was only providing <em>non-repeatable read isolation level</em> at that chaincode. As our transaction was only writing keys, such side effect did not affect the database consistency. Figure 12(d) shows the improvement in endorsement phase. The average endorsement latency reduced from 800 ms to 40 ms, validating our hypothesis.</p>
</blockquote>
<p>结果，随着每个交易的写入次数的增加，账本更新等待时间增加了（请参见图12（b））。 由于上述三个耗时的串行操作，我们推测提交者将锁锁定在数据库上的时间更长，从而增加了背书延迟。 </p>
<p>为了验证我们的假设，我们通过在背书阶段和最终账本更新期间禁用整个数据库的锁获取来进行实验。 此类操作的副作用是在该链码上只提供了“不可重复的读取隔离级别”。 由于我们的交易只是写密钥，因此这种副作用不会影响数据库的一致性。 图12（d）显示了背书阶段的改进。 平均背书等待时间从 800ms 减少到 40ms，验证了我们的假设。</p>
<h3 id="Observation-12"><a href="#Observation-12" class="headerlink" title="Observation 12:"></a>Observation 12:</h3><blockquote>
<p><em>Only with an increase in the number of reads per transaction, the MVCC latency increased</em> as shown in Figure 12(c). This is because with an increase in the number of items in the read set, the number of GET REST API calls to CouchDB increased during MVCC validation phase. With an increase in the number of writes, MVCC latency did not increase as shown in Figure 12(b) because it only checks whether any read keys has been modified.</p>
</blockquote>
<p>如图12（c）所示，<em>仅随着每个交易读取次数的增加，MVCC 延迟才增加</em>。 这是因为随着读取集中项目的数量增加，在 MVCC 验证阶段，对 CouchDB 的 GET REST API 调用数量也增加了。 随着写入次数的增加，MVCC 延迟并没有增加，如图 12（b）所示，因为它仅检查是否已修改任何读取密钥。</p>
<h3 id="Guideline-6"><a href="#Guideline-6" class="headerlink" title="Guideline 6:"></a>Guideline 6:</h3><blockquote>
<p>GoLevelDB is a better performant option for state database. CouchDB is a better choice if rich-query support for read-only transactions is important. When using CouchDB, design the application and transaction to read/write a fewer number of keys to accomplish a task.</p>
</blockquote>
<p>对于状态数据库，GoLevelDB 是性能更好的选项。 如果对只读交易的富查询支持很重要，则 CouchDB 是更好的选择。 使用 CouchDB 时，设计应用程序和交易以读取/写入较少数量的键即可完成任务。</p>
<h3 id="Action-Item-4"><a href="#Action-Item-4" class="headerlink" title="Action Item 4:"></a>Action Item 4:</h3><blockquote>
<p>CouchDB supports bulk read/write operations without additional transactional semantics. Using the bulk operations will reduce the lock holding duration and improve the performance as demonstrated in §VI-C.</p>
</blockquote>
<p>CouchDB支持批量读/写操作，而无需其他交易语义。 如 §VI-C 所示，使用批量操作将减少锁保持时间并提高性能。</p>
<h3 id="Action-Item-5"><a href="#Action-Item-5" class="headerlink" title="Action Item 5:"></a>Action Item 5:</h3><blockquote>
<p>The usage of database such as GoLevelDB and CouchDB, without the snapshot isolation level, results in whole database lock during the endorsement and the ledger update phase. Hence, our future work is to look at ways to remove the lock and/or use a database such as PostgreSQL that supports snapshot isolation.</p>
</blockquote>
<p>在没有快照隔离级别的情况下，使用数据库（例如GoLevelDB和CouchDB）会在背书和账本更新阶段导致整个数据库锁定。 因此，我们的未来工作是研究删除锁和/或使用支持快照隔离的数据库（例如 PostgreSQL）的方法。</p>
<h2 id="E-Scalability-and-Fault-Tolerant"><a href="#E-Scalability-and-Fault-Tolerant" class="headerlink" title="E. Scalability and Fault Tolerant"></a>E. Scalability and Fault Tolerant</h2><blockquote>
<p>In Fabric, scalability can be measured in terms of the number of channels, number of organizations joining a channel and the number of peers per organization. From a resource consumption perspective, the endorsement policy complexity controls the scalability of network. Even with a large number of organizations or peers, if the endorsement policy requires only a few organizations signature, then the performance would be the unaffected. This is because, the transaction needs to be simulated at a fewer node in the network to collect endorsement. </p>
<p>Scalability could also be defined in terms of number of geographically distributed nodes and latency in block dissemination among them. Number of ordering service nodes and choice of consensus protocol used among them would also affect scalability. Though these are out of scope of this study, are important aspects of network scalability.</p>
</blockquote>
<p>在 Fabric 中，可扩展性可以根据通道数量，加入通道的组织数量以及每个组织的对等节点来衡量。 从资源消耗的角度来看，背书策略的复杂性控制着网络的可扩展性。 即使有大量组织或节点，如果背书策略仅需要几个组织签名，那么性能将不会受到影响。 这是因为，需要在网络中较少的节点上模拟交易来收集背书。 </p>
<p>还可以根据地理上分散的节点的数量和它们之间的块分发中的等待时间来定义可扩展性。 排序服务节点的数量以及在其中使用的共识协议的选择也会影响可扩展性。 尽管这些超出了本研究的范围，但它们是网络可扩展性的重要方面。</p>
<blockquote>
<p>Node failures are common in a distributed system and hence, it is important to study the fault tolerant capability of Fabric. In our initial and early study, we observed that node failures do not affect the performance (during non-overloaded case) as client can collect endorsement from other available nodes. With higher loads, node rejoining after a failure and syncing up the ledger due to missing blocks was observed to have large delays. This is because though the block processing rate at the rejoined node was at the peak, other nodes continues to add new blocks at the same peak processing rate.</p>
</blockquote>
<p>节点故障在分布式系统中很常见，因此，研究 Fabric 的容错能力很重要。 在我们的初期和早期研究中，我们观察到节点故障不会影响性能（在非过载情况下），因为客户端可以从其他可用节点收集认可。 对于更高的负载，观察到节点在故障后重新加入并由于缺少块而同步了账本，这会产生较大的延迟。 这是因为尽管重新加入的节点处的块处理速率处于峰值，但其他节点仍继续以相同的峰值处理速率添加新块。</p>
<h1 id="VI-OPTIMIZATIONS-STUDIED"><a href="#VI-OPTIMIZATIONS-STUDIED" class="headerlink" title="VI. OPTIMIZATIONS STUDIED"></a>VI. OPTIMIZATIONS STUDIED</h1><blockquote>
<p>In this section, we introduce three simple optimizations based on action items listed in §V – (1) MSP cache in §VI-A, (2) parallel VSCC validation of a block in §VI-B, and (3) bulk read/write during MVCC validation &amp; commit for CouchDB in §VI-C. For each of these optimizations, first, we study the performance improvement individually. Then, we study the improvement by combining all the three optimizations.</p>
</blockquote>
<p>在本节中，我们将基于 §V 中列出的操作项目介绍三种简单的优化方法-（1）§VI-A 中的 MSP 缓存，（2）§VI-B 中的块的并行 VSCC 验证，以及（3）§VI-C 中的在 MVCC 验证和提交期间对 CouchDB 批量读/写。 对于这些优化，首先，我们分别研究性能改进。 然后我们通过结合三个优化来研究改进。</p>
<h2 id="A-MSP-Cache"><a href="#A-MSP-Cache" class="headerlink" title="A. MSP Cache"></a>A. MSP Cache</h2><blockquote>
<p>As crypto operations are very CPU intensive, in this section, we studied the efficiency of using a cache at the following two operations in the crypto module:</p>
<ol>
<li><p>Deserialization of identity (i.e., x.509 certificate).</p>
</li>
<li><p>Validation of identity with Organization’s MSP.</p>
</li>
</ol>
</blockquote>
<p>由于加密操作非常占用CPU，因此在本节中，我们研究了在加密模块中的以下两个操作中使用缓存的效率：</p>
<ol>
<li><p>身份反序列化（即 x.509 证书）。</p>
</li>
<li><p>使用组织的 MSP 验证身份。</p>
</li>
</ol>
<blockquote>
<p>To avoid deserialization of the serialized identity every time, we cached the deserialized identity using a hash map with the serialized form as key. Similarly, to avoid validating an identity with multiple MSPs every time, we used a hash map with a key as identity and value as the corresponding MSP to which the identity belongs. Further, we employed the ARC algorithm for cache replacement. During identity revocations, we invalidated cache entries appropriately.</p>
</blockquote>
<p>为了避免每次都对序列化标识进行反序列化，我们使用以序列化形式作为键的哈希映射对反序列化的标识进行缓存。 同样，为避免每次都使用多个 MSP 验证身份，我们使用了一个哈希图，其中键为身份，值为身份所属的相应MSP。 此外，我们采用了 ARC 算法来替换缓存。 在身份吊销期间，我们适当地使缓存条目无效。</p>
<blockquote>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200410111743151.png" alt="image-20200410111743151" style="zoom:50%;">

<p>Figure 13 plots the impact of MSP cache on the throughput and latency for AND/OR endorsement policies over different transaction arrival rates. Table III presents various policies used along with different transaction arrival rates. We draw the attention of the reader to Figure 6(b) for comparison against the no-cache behavior. On average, the throughput increased by 3× due to MSP cache as compared to a vanilla peer. For e.g., when the endorsement policy required signature from two endorsers (defined using AND/OR syntax), the maximum throughput achieved without MSP cache was 160 tps while with cache, it increased to 540 tps. This is because the MSP cache reduced certain repetitive CPU intensive operations.</p>
</blockquote>
<p>图 13 绘制了 MSP 缓存对不同交易到达率下 AND / OR 背书策略的吞吐量和延迟的影响。 表 III 列出了使用的各种策略以及不同的交易到达率。 我们提请读者注意图6（b），以与无缓存行为进行比较。 平均而言，与普通节点相比，由于 MSP 缓存，吞吐量增加了 3 倍。 例如，当背书策略需要两个背书节点的签名（使用 AND / OR 语法定义）时，不使用 MSP 缓存时实现的最大吞吐量为 160 tps，而使用缓存时则达到 540 tps。 这是因为 MSP 缓存减少了某些重复的 CPU 密集型操作。</p>
<blockquote>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200410112955545.png" alt="image-20200410112955545" style="zoom:50%;">

<p>Figure 14 and 15 plots the flame graph showing frequency of crypto operations and call stack depth of VSCC validation phase in a vanilla peer and a peer with MSP cache, respectively. As it can be observed, the number of crypto operations and call stack depth reduced significantly with the MSP cache.</p>
</blockquote>
<p>图 14 和 15 绘制了火焰图，分别显示了原始对等节点和具有 MSP 缓存的对等节点中的加密操作频率和 VSCC 验证阶段的调用堆栈深度。 可以看出，使用 MSP 缓存，加密操作的数量和调用堆栈的深度大大减少了。</p>
<h2 id="B-Parallel-VSCC-Validation-of-a-Block"><a href="#B-Parallel-VSCC-Validation-of-a-Block" class="headerlink" title="B. Parallel VSCC Validation of a Block"></a>B. Parallel VSCC Validation of a Block</h2><blockquote>
<p>The VSCC validation phase validates each transaction in a block serially against the endorsement policy. As this approach under-utilized the resources, we studied the efficiency of parallel validation, i.e., validate multiple transactions’ endorsement in parallel to utilize otherwise idle CPU and improve the overall performance. To achieve this, we created a configurable number of worker threads per channel on peer startup. Each worker thread validates one transaction’s endorsement signature set against its endorsement policy.</p>
</blockquote>
<p>VSCC 验证阶段根据背书策略依次验证每个交易。 由于这种方法未充分利用资源，因此我们研究了并行验证的效率，即并行验证多个交易的背书，以利用空闲的 CPU 并提高整体性能。 为此，我们在对等节点启动时为每个通道创建了可配置数量的工作线程。 每个工作线程都会根据其背书策略验证一个交易的背书签名集。</p>
<blockquote>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200410113304957.png" alt="image-20200410113304957" style="zoom:50%;">

<p>Figure 16 plots the impact of parallel VSCC on the performance and resource utilization. We categorize the arrival rate for different channel count into two categories; non-overloaded case when the latency falls in [0.1-1s] and overloaded when the latency falls in [30-40s]. For each channel, we allocated worker threads equal to the block size. The throughput and resource utilization during the non-overloaded case for one channel exploded from 130 tps to 800 tps (improved by 6.3×) for the block size of 30 and to 980 tps (7.5×) for the block size of 300. This is due to parallel validation and hence the reduction in the VSCC latency (from 300 ms to 30 ms, i.e., by 10× reduction for the block size of 30). The throughput saturated at 950 tps (for the block size of 30) &amp; 1075 tps (for the block size of 300) – refer to Figure 16(a).</p>
</blockquote>
<p>图 16 绘制了并行 VSCC 对性能和资源利用率的影响。 我们将不同通道数的到达率分为两类： 延迟小于[0.1-1s]时处于非过载情况，而延迟小于[30-40s]时处于过载状态。 对于每个通道，我们分配的工作线程等于块大小。 一个通道在非过载情况下的吞吐量和资源利用率从块大小为 30 的 130 tps 激增至 800 tps（提高了6.3倍），块大小为 300 的吞吐量和资源利用率激增至 980 tps（7.5倍）。 由于并行验证，因此减少了 VSCC 延迟（从 300 毫秒减少到 30 毫秒，即对于 30 的块大小减少了 10 倍）。 吞吐量达到 950 tps（对于 30 块的块）和 1075 tps（对于 300块）达到饱和–请参见图16（a）。</p>
<blockquote>
<p>Similarly, the throughput and resource utilization during the overloaded case increased to 1.5× for 16 channels to as much as 10× for 1 channel – refer to Figure 16(b). This shows that parallel VSCC validation of a block significantly increases the performance of a single channel. With an increase in the number of channels, the percentage of improvement decreased. This is because multiple channels by default result in the parallel validation of blocks (instead of transactions) and hence a few number of free vCPUs were available for parallel VSCC.</p>
</blockquote>
<p>同样，过载情况下 16 通道的吞吐量和资源利用率增加 1.5 倍， 1 通道增加 10 倍–参见图16（b）。 这表明块的并行 VSCC 验证显着提高了单个通道的性能。 随着通道数量的增加，改善的百分比降低了。 这是因为默认情况下，多个通道会导致块的并行验证（而不是交易），因此，有几个可用的 vCPU 可用于并行 VSCC。</p>
<h2 id="C-Bulk-Read-Write-During-MVCC-Validation-amp-Commit"><a href="#C-Bulk-Read-Write-During-MVCC-Validation-amp-Commit" class="headerlink" title="C. Bulk Read/Write During MVCC Validation &amp; Commit"></a>C. Bulk Read/Write During MVCC Validation &amp; Commit</h2><blockquote>
<p>During the MVCC validation, with CouchDB as the state database, for each transaction in a block, for each key in the read set of the transaction, a GET REST API call to the database over a secure HTTPS retrieved the last committed version number. During the commit phase, for each valid transaction (recorded after MVCC validation) in a block, for each key in the write set of the transaction, a GET REST API call retrieved the revision numbers. Finally, for each entry in the write set, a PUT REST API call committed the document. Due to these multiple REST API calls, performance degraded significantly as demonstrated in §V-D.</p>
</blockquote>
<p>在 MVCC 验证期间，以 CouchDB 作为状态数据库，对于块中的每个交易，对于交易的读取集中的每个键，通过安全 HTTPS 对该数据库的 GET REST API 调用都检索到最后提交的版本号。 在提交阶段，对于块中的每个有效交易（在 MVCC 验证后记录），对于交易的写集中的每个键，GET REST API 调用都会检索修订号。 最后，对于写集中的每个条目，都会通过 PUT REST API 调用提交文档。 由于有多个 REST API 调用，因此性能大大降低，如§V-D所示。</p>
<blockquote>
<p>To cut down the number of REST API calls, CouchDB suggests using bulk operations. Hence, we used the existing BatchRetrieval API in Fabric to batch load multiple keys’ version and revision number into the cache over a single GET REST API call per block. To enhance the ledger update process, we used BatchUpdate API in Fabric to commit a batch of documents using a single PUT REST API call per block. Further, we introduced a cache in VSCC to reduce the calls to CouchDB to obtain the endorsement policy of the chaincode for each transaction. In this section, we show the efficiency of these enhancements on the overall performance.</p>
</blockquote>
<p>为了减少 REST API 调用的数量，CouchDB 建议使用批量操作。 因此，我们使用 Fabric 中现有的 BatchRetrieval API 通过每个块一次 GET REST API 调用将多个密钥的版本和修订号批量加载到缓存中。 为了增强账本更新过程，我们在 Fabric 中使用 BatchUpdate API 通过每个块一个 PUT REST API 调用来提交一批文档。 此外，我们在 VSCC 中引入了缓存，以减少对 CouchDB 的调用，以获取每个交易的链码的背书策略。 在本节中，我们将展示这些增强功能对整体性能的效率。</p>
<blockquote>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200410114711286.png" alt="image-20200410114711286" style="zoom:50%;">

<p>Figure 17 plots the throughput and latency when running a CouchDB as the state database with the bulk read/write optimization. For comparison against the non-bulk read/write, refer to Figure 11(b) and Figure 12. The performance increased significantly from 50 tps to 115 tps (i.e., by 2.3×) for transactions with a single write. For multiple writes (3-w &amp; 5-w), the throughput increased from 26 tps to 100 tps (i.e., 3.8× for 3-w), and 18 tps to 90 tps (i.e., 5× for 5-w). We noticed similar improvements for read-write transactions.</p>
</blockquote>
<p>图 17 绘制了运行 CouchDB 作为状态数据库时批量读/写优化的吞吐量和延迟。 为了与非批量读取/写入进行比较，请参考图11（b）和图12。对于一次写入的交易，性能从 50 tps 显着提高到 115 tps（即，提高了 2.3 倍）。 对于多次写入（ 3-w 和 5-w），吞吐量从 26 tps 增加到 100 tps（即 3-w为3-x），从 18 tps 增加到 90 tps（即 5-w 为 5 倍）。 我们注意到读写交易也有类似的改进。</p>
<blockquote>
<p>Due to the bulk read/write optimization, the MVCC latency, ledger update latency and endorsement latency decreased as shown in Figure 17(c) and (d) as compared to Figure 12. The reduction in endorsement latency (by at least 3×) was because of the reduction in lock holding duration by the commit phase (by at least 8×). The MVCC latency for read-write transactions reduced (by at least 6×) due to a bulk reading of all keys in the read set of all transactions in a block. Note that the MVCC latency increased with the increase in the number of keys read in a bulk read. The ledger update latency of a block encompassing a higher number of writeonly transactions was higher. This is because, in read-write transactions, the MVCC validation phase itself loaded the required revision numbers into the cache (as the transaction read those keys before modification) which was not the case with write-only transactions.</p>
</blockquote>
<p>由于批量读/写优化，图17（c）和（d）与图 12 相比，MVCC 延迟、账本更新延迟和背书延迟减少。背书延迟减少了（至少3倍） 这是因为提交阶段的锁保持时间减少了（至少减少了8倍）。 由于块中所有交易的读取集中的所有密钥都是批量读取，因此读写交易的 MVCC 延迟减少了（至少6倍）。 注意，MVCC 延迟随着批量读取中读取的键数的增加而增加。 包含更多只写交易的块的账本更新等待时间更长。 这是因为，在读写交易中，MVCC 验证阶段本身将所需的修订号加载到缓存中（因为交易在修改之前读取了这些键），而对于只写交易则不是这种情况。</p>
<h2 id="D-Combinations-of-Optimizations"><a href="#D-Combinations-of-Optimizations" class="headerlink" title="D. Combinations of Optimizations"></a>D. Combinations of Optimizations</h2><blockquote>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200414002047642.png" alt="image-20200414002047642" style="zoom:50%;">

<p>Figure 18 plots the performance improvement achieved with all three optimizations combined. Table IX presents the number of VSCC worker threads per channel, block sizes, and other relavant parameters used for this study.</p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200414002126408.png" alt="image-20200414002126408" style="zoom:50%;">
</blockquote>
<p>图 18 列出了三个优化相结合所实现的性能改进。 表 IX 列出了用于此研究的每个通道的 VSCC 工作线程数，块大小和其他相关参数。</p>
<blockquote>
<p>With GoLevelDB as the state database, the single channel throughput increased to 2250 tps from 140 tps (i.e., 16× improvement) due to all three optimizations – refer to Figure 18(a) and Figure 4. Similarly, with CouchDB as the state database, the singe channel throughput increased to 700 tps from 50 tps (i.e., 14× improvement) – refer to Figure 18(b) and Figure 11. With an increase in the block size, when CouchDB was the state database, we observed a lower total latency due to the reduction in the number of bulk REST API call to CouchDB (i.e, for 500 transactions, only 2 bulk REST API calls, one read call during MVCC phase and one write during commit phase, were issued when the block size was 500 as compared to 10 bulk REST API calls for a block size of 100). As a result, our guideline 1 &amp; 2 are not applicable for CouchDB with bulk read/write optimizations.</p>
</blockquote>
<p>使用 GoLevelDB 作为状态数据库，由于三个优化，单通道吞吐量从 140 tps 增加到了 2250 tps（即提高了16倍）–参见图18（a）和图4。类似地，使用 CouchDB 作为状态数据库 ，单通道吞吐量从 50 tps 增加到 700 tps（即提高了14倍）–参见图18（b）和图11。当 CouchDB 是状态数据库时，由于减少了对 CouchDB 的批量 REST API 调用的数量而导致的总延迟，随着块大小的增加，我们观察到更低的吞吐量（对于 500 个交易，当块大小为 500 时，仅发出 2 个批量 REST API 调用，在MVCC阶段进行一次读调用，在提交阶段进行一次写操作，而对于块大小为 100 时进行 10 次批量 REST API 调用） 。 因此，我们的准则 1 和 2 不适用于具有批量读/写优化功能的 CouchDB。</p>
<blockquote>
<p>Further, for 8 and 16 channels, the throughput increased to 2700 tps from 1025 tps and 1321 tps, respectively as shown in Figure 19(a). With a simpler endorsement policy, i.e., 1st AND/OR policy, the single channel throughput also increased to 2700 tps (with GoLevelDB) as shown in Figure 19(b).</p>
<img src="/Users/wuziyan/Library/Application Support/typora-user-images/image-20200414003650302.png" alt="image-20200414003650302" style="zoom:50%;">
</blockquote>
<p>此外，对于 8 和 16 通道，吞吐量分别从 1025 tps 和 1321 tps 增加到 2700 tps，如图19（a）所示。 使用更简单的背书策略（即第一个 AND / OR 策略），单通道吞吐量也增加到了 2700 tps（使用 GoLevelDB），如图19（b）所示。</p>
<blockquote>
<p>Even with a throughput of 2700 tps, the average CPU utilization of a peer was only 60% and the network utilization of a peer was 1680 Mbps (send) and 240 Mbps (receive). This is because the sum of MVCC latency and ledger update latency (less CPU intensive tasks) was almost same or higher than the VSCC latency (as shown in Figure 18(c) and (d)). Due to these sequential phases, vCPUs were underutilized. One potential optimization would be to pipeline the VSCC and MVCC validation phase.</p>
</blockquote>
<p>即使吞吐量为 2700 tps，对等节点的平均 CPU 利用率也仅为 60％，网络利用率为1680 Mbps（发送）和 240 Mbps（接收）。 这是因为 MVCC 延迟和账本更新延迟的总和（较少的 CPU 密集型任务）与 VSCC 延迟几乎相同或更高（如图18（c）和（d）所示）。 由于这些顺序的阶段，vCPU 未被充分利用。 一种潜在的优化方法是管道 VSCC 和 MVCC 验证阶段。</p>
<h1 id="VII-RELATED-WORK"><a href="#VII-RELATED-WORK" class="headerlink" title="VII. RELATED WORK"></a>VII. RELATED WORK</h1><blockquote>
<p>There has been considerable interest in the scalability and performance characteristics of public blockchain networks and specifically the limiting factor of the consensus protocol and its security implications [31], [23].</p>
</blockquote>
<p>人们对公共区块链网络的可扩展性和性能特征，特别是共识协议的限制因素及其安全性有着相当大的兴趣。</p>
<blockquote>
<p>Also for public blockchains, [19] have looked at quantifying throughput, latency, bootstrap time and cost per transaction for the Bitcoin network based on publicly available data.</p>
</blockquote>
<p>同样对于公共区块链，[19] 已经研究了基于可公开获得的数据来量化比特币网络的吞吐量，等待时间，自举时间和每笔交易成本。</p>
<blockquote>
<p>BlockBench [22] was one of the first to look at permissioned blockchain. They present a framework for comparing performance of different blockchain platforms, namely, Ethereum, Parity and Hyperledger Fabric using a set of micro and macro benchmarks. Similar to [19] they generalize consensus, data, execution and application as 4 layers of blockchain and use the benchmarks to exercise them. They measure the overall performance in terms of throughput, latency and scalability of the platforms and draw conclusions across the 3 platforms. However, they studied the performance of Fabric v0.6, with v1.0 version bringing in a complete re-design, their observations do not hold relevance and needs re-study.</p>
</blockquote>
<p>BlockBench [22] 是最早研究许可区块链的人之一。 他们提出了一个框架，用于使用一组微观和宏观基准来比较不同区块链平台（以太坊，Parity 和 Hyperledger Fabric）的性能。 与 [19] 相似，他们将共识，数据，执行和应用概括为4层区块链，并使用基准对其进行了实践。 他们根据平台的吞吐量，延迟和可伸缩性来衡量整体性能，并在这三个平台上得出结论。 但是，他们研究了 Fabric v0.6 的性能，而 v1.0 版本带来了完整的重新设计，他们的观察结果没有任何意义，需要重新研究。</p>
<blockquote>
<p>[16] presents the design and the new architecture of Fabric, delving in-depth into its design considerations and modularity. It presents the performance of a single Bitcoin like crypto currency application on Fabric, called Fabcoin, which uses a customized VSCC to validate the Fabcoin specific transactions and avoid complex endorsements and channels. Further, they used CLI command to emulate clients, which is not realistic, instead of using a SDK [6], [8], [10]. Our work differs from theirs in that, we do a comprehensive study for different workloads keeping Fabric’s modularity and application in multiple domains in focus.</p>
</blockquote>
<p>[16] 介绍了 Fabric 的设计和新架构，深入研究了其设计考虑因素和模块化。 它展示了 Fabric 上单个比特币（如加密货币）应用程序的性能，称为 Fabcoin，该应用程序使用定制的 VSCC 来验证 Fabcoin 特定交易并避免复杂的认可和通道。 此外，他们使用 CLI 命令来模拟客户端，这是不现实的，而不是使用 SDK [6]，[8]，[10]。 我们的工作与他们的不同之处在于，我们针对不同的工作负载进行了全面的研究，以确保Fabric的模块化和在多个领域中的应用为重点。</p>
<blockquote>
<p>A note to the reader, [16] used Fabric v1.1-preview release, which incorporates all our optimizations and other additional functionalities over v1.0. However, being a minor version update much of the core functionality remains the same and our observations hold true for v1.1 and future versions based on the new architecture of Fabric.</p>
</blockquote>
<p>给读者的说明，[16] 使用 Fabric v1.1-preview 版本，该版本合并了我们在 v1.0 上的所有优化和其他附加功能。 但是，作为次要版本更新，大部分核心功能保持不变，并且我们的观察对于基于 Fabric 的新体系结构的 v1.1 和将来版本仍然适用。</p>
<h1 id="VIII-CONCLUSION-amp-FUTURE-WORK"><a href="#VIII-CONCLUSION-amp-FUTURE-WORK" class="headerlink" title="VIII. CONCLUSION &amp; FUTURE WORK"></a>VIII. CONCLUSION &amp; FUTURE WORK</h1><blockquote>
<p>In this paper, we conducted a comprehensive empirical study to understand the performance of Hyperledger Fabric, a permissioned blockchain platform, by varying values assigned to configurable parameters such as block size, endorsement policy, channels, resource allocation, and state database choices. As a result of our study, we provided six valuable guidelines on configuring these parameters and also identified three major performance bottlenecks. Hence, we introduced and studied three simple optimizations such as MSP cache, parallel VSCC validation, and bulk read/write during MVCC validation &amp; commit phase to improve the singe channel performance by 16×. Further, these three optimizations have been successfully adopted in Fabric v1.1</p>
</blockquote>
<p>在本文中，我们进行了一项全面的实证研究，以了解通过更改分配给可配置参数（例如区块大小，背书策略，通道，资源分配和状态数据库选择）的值来了解许可的区块链平台 Hyperledger Fabric 的性能。 作为我们研究的结果，我们提供了六种有关配置这些参数的有价值的指南，并且确定了三个主要的性能瓶颈。 因此，我们引入并研究了三种简单的优化方法，例如 MSP 缓存，并行 VSCC 验证以及 MVCC 验证和提交阶段期间的批量读/写，以将单通道性能提高 16 倍。 此外，这三个优化已在 Fabric v1.1 中成功采用</p>
<blockquote>
<p>As a part of future work, we will study the scalability and fault tolerant capability of Fabric by using different blockchain topologies such as different number of organizations and different number of nodes per organization. Further, we plan to quantify the impact of various consensus algorithms and number of nodes in the ordering service on the performance of different workloads. In our study, we assumed that the network is not a bottleneck. However, in the real world setup, nodes can be geographically distributed and hence, the network might play a role. In addition, the arrival rates in real world production system would be following certain distributions. Hence, we will study the performance of Fabric in Wide Area Network (WAN) with different arrival rate distributions.</p>
</blockquote>
<p>作为未来工作的一部分，我们将通过使用不同的区块链拓扑来研 究Fabric 的可扩展性和容错能力，例如不同的组织数量和每个组织的节点数量。 此外，我们计划量化订购服务中各种共识算法和节点数对不同工作负载性能的影响。 在我们的研究中，我们假设网络不是瓶颈。 但是，在现实世界中，节点可以在地理位置上分布，因此网络可能会发挥作用。 另外，实际生产系统中的到达率将遵循某些分布。 因此，我们将研究具有不同到达速率分布的广域网（WAN）中光纤的性能。</p>
<h1 id="IX-ACKNOWLEDGEMENTS"><a href="#IX-ACKNOWLEDGEMENTS" class="headerlink" title="IX. ACKNOWLEDGEMENTS"></a>IX. ACKNOWLEDGEMENTS</h1><blockquote>
<p>We wish to acknowledge our following colleagues for their valuable assistance to our work. Our proposed optimizations were successfully adopted to Fabric, thanks to fabric developers who took care of submitting patches to Fabric v1.1. Angelo De Carlo (MSP Cache), Alessandro Sorniotti (Parallel Validation). Thanks to David Enyeart, Chris Elder, Manish Sethi for their proposal on Bulk Read from CouchDB. We would like to thank Yacov Manevich for his consistent help.</p>
</blockquote>
<p>我们谨感谢以下同事为我们的工作提供的宝贵帮助。 我们的建议优化已成功地被 Fabric 采纳，这要归功于 Fabric开发人员负责向 Fabric v1.1 提交补丁。 Angelo De Carlo（MSP缓存），Alessandro Sorniotti（并行验证）。 感谢 David Enyeart，Chris Elder 和 Manish Sethi 提出的有关 CouchDB 批量读取的建议。 我们要感谢 Yacov Manevich 的一贯帮助。 </p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://ziiyan.github.io/2020/04/04/Performance-Benchmarking-and-Optimizing-Hyperledger-Fabric-Blockchain-Platform/" title="Performance Benchmarking and Optimizing Hyperledger Fabric Blockchain Platform" target="_blank" rel="external">http://ziiyan.github.io/2020/04/04/Performance-Benchmarking-and-Optimizing-Hyperledger-Fabric-Blockchain-Platform/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/ziiyan" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/ziiyan" target="_blank"><span class="text-dark">Ziiyan</span><small class="ml-1x">Life kicks in right now</small></a></h3>
        <div>因上努力，果上随缘</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
           
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2020/04/07/dataExplorer%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/" title="DE打包优化"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2020/04/02/%E9%9D%A2%E7%BB%8F%EF%BC%9A%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-AE%E6%8A%80%E6%9C%AF%E9%83%A8-%E4%B8%80%E9%9D%A2/" title="面经：阿里巴巴-AE技术部-一面"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/ziiyan" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '25953118',
    clientSecret: 'wzy574542379',
    repo: 'https://github.com/ziiyan',
    owner: 'ziiyan',
    admin: ['ziiyan'],
    id: md5(location.pathname),
    distractionFreeMode: true
  })
  gitalk.render('comments')
  </script>

      







</body>
</html>