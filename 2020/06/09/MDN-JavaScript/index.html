<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>life kicks in right now</title>
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">life kicks in right now</a>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
        <li class="menu-item">
          <a href="https://github.com/ziiyan" target="_blank" rel="noopener" class="menu-item-link">Github</a>
        </li>
      
    </ul>
  </nav>
</header>
      <main class="main">
        <article class="post">
  <div class="post-title">
    <h2 class="title">MDN-JavaScript</h2>
  </div>
   <div class="post-meta">
    <span class="post-time">2020-06-09</span>
  </div>
  <div class="post-content">
    <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><code>indexOf</code> 查找子串</li>
<li><code>slice</code> 分片</li>
<li><code>replace</code> 替换</li>
<li><code>split</code> 字符串转数组</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><code>join</code> 数组转字符串（指定分隔符）</li>
<li><code>toString</code> 数组转字符串（逗号分隔）</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h2 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a>_<em>proto_</em></h2><ul>
<li>在javascript中，函数可以有属性，每个函数都有一个特殊的属性叫作原型</li>
<li>原型链中的方法和属性<strong>没有</strong>被复制到其他对象——它们被访问需要通过前面所说的“原型链”的方式</li>
</ul>
<blockquote>
<p>没有官方的方法用于直接访问一个对象的原型对象——原型链中的“连接”被定义在一个内部属性中，在 JavaScript 语言标准中用 <code>[[prototype]]</code> 表示（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/ECMAScript" target="_blank" rel="noopener">ECMAScript</a>）。然而，大多数现代浏览器还是提供了一个名为 <code>__proto__</code> （前后各有2个下划线）的属性，其包含了对象的原型</p>
</blockquote>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><ul>
<li><code>prototype</code> 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中<ul>
<li>不在 <code>prototype</code> 对象内的成员，不会被“对象实例”或“继承自 <code>Object()</code> 的对象类型”所继承</li>
<li>这些方法/属性仅能被 <code>Object()</code> 构造器自身使用</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">person1 = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"><span class="title">Person1</span>.<span class="title">__proto__</span> === <span class="title">person</span>.<span class="title">prototype</span></span></span><br></pre></td></tr></table></figure>

<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><ul>
<li>每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的<strong>构造函数</strong>（可以用来 new）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">person1 = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">constructor</span> === <span class="title">person</span></span></span><br><span class="line"><span class="function">// <span class="title">new</span> <span class="title">function</span>(<span class="params"></span>) &lt;=&gt; <span class="title">new</span> <span class="title">person1</span>.<span class="title">constructor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"><span class="title">person1</span>.<span class="title">constructor</span>.<span class="title">name</span></span></span><br><span class="line"><span class="function">// "<span class="title">person</span>"</span></span><br></pre></td></tr></table></figure>

<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = &#123;</span><br><span class="line">    first,</span><br><span class="line">    last</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.interests = interests;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name.first + <span class="string">'.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">first, last, age, gender, interests, subject</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, first, last, age, gender, interests);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.subject = subject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Teacher.prototype.constructor = Teacher;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们输入类似<code>var person1=new Person(...)</code>来构造对象时，JavaScript实际上参考的是<code>Person.prototype</code>指向的对象来生成<code>person1</code>。</p>
<p>另一方面，<code>Person()</code>函数是<code>Person.prototype</code>的构造函数，也就是说<code>Person===Person.prototype.constructor</code></p>
</blockquote>
<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><ul>
<li><strong>委托</strong> - 特殊的对象将功能委托给通用的对象类型完成</li>
</ul>
<blockquote>
<p>考虑到JavaScript的工作方式，由于原型链等特性的存在，在不同对象之间功能的共享通常被叫做 <strong>委托</strong> - 特殊的对象将功能委托给通用的对象类型完成。这也许比将其称之为继承更为贴切，因为“被继承”了的功能并没有被拷贝到正在“进行继承”的对象中，相反它仍存在于通用的对象中。</p>
</blockquote>
<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>一个<strong>线程</strong>是一个基本的处理过程，每个线程一次只能执行一个任务</li>
<li>现在的计算机大都有多个内核（core），因此可以同时执行多个任务</li>
<li>支持多线程的编程语言可以使用计算机的多个内核，同时完成多个任务</li>
</ul>
<h3 id="JavaScript-是单线程的"><a href="#JavaScript-是单线程的" class="headerlink" title="JavaScript 是单线程的"></a>JavaScript 是单线程的</h3><ul>
<li>即使有多个内核，也只能在单一线程上运行多个任务，称为主线程（<strong>main thread</strong>）</li>
</ul>
<h2 id="异步代码"><a href="#异步代码" class="headerlink" title="异步代码"></a>异步代码</h2><h3 id="Web-workers"><a href="#Web-workers" class="headerlink" title="Web workers"></a>Web workers</h3><ul>
<li>通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener">Web workers</a> 可以把一些任务交给一个名为 worker 的单独的线程<ul>
<li>用一个 worker来运行一个耗时的任务，主线程就可以处理用户的交互（避免了阻塞）</li>
<li>web workers 不能访问 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/DOM" target="_blank" rel="noopener">DOM</a> </li>
</ul>
</li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promises</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch" target="_blank" rel="noopener">fetch</a></p>
<ul>
<li>现代版的，更高效的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a></li>
</ul>
</li>
</ul>
<h3 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h3><blockquote>
<p>像promise这样的异步操作被放入事件队列中，事件队列在主线程完成处理后运行，这样它们就不会阻止后续JavaScript代码的运行。排队操作将尽快完成，然后将结果返回到JavaScript环境。</p>
</blockquote>
<h3 id="间隔"><a href="#间隔" class="headerlink" title="间隔"></a>间隔</h3><ul>
<li><p>setTimeout()</p>
<ul>
<li>在指定的时间后执行一段代码</li>
</ul>
</li>
<li><p>setInterval()</p>
<ul>
<li>以固定的时间间隔，重复运行一段代码</li>
</ul>
</li>
</ul>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">  setTimeout(run, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li>递归 <code>setTimeout()</code> 保证执行之间的延迟相同，例如在上述情况下为100ms。 代码将运行，然后在它再次运行之前等待100ms，因此无论代码运行多长时间，间隔都是相同的。</li>
<li>使用 <code>setInterval()</code> 的示例有些不同。 我们选择的间隔包括执行我们想要运行的代码所花费的时间。假设代码需要40毫秒才能运行 - 然后间隔最终只有60毫秒。</li>
<li>当递归使用 <code>setTimeout()</code> 时，每次迭代都可以在运行下一次迭代之前计算不同的延迟。 换句话说，第二个参数的值可以指定在再次运行代码之前等待的不同时间（以毫秒为单位）。</li>
</ul>
<p>当你的代码有可能比你分配的时间间隔，花费更长时间运行时，最好使用递归的 <code>setTimeout()</code> - 这将使执行之间的时间间隔保持不变，无论代码执行多长时间，你不会得到错误。</p>
</blockquote>
<ul>
<li>requestAnimationFrame()<ul>
<li>在浏览器下一次重新绘制显示之前执行指定的代码块，从而允许动画在适当的帧率下运行，而不管它在什么环境中运行</li>
</ul>
</li>
</ul>
<h1 id="客户端-API"><a href="#客户端-API" class="headerlink" title="客户端 API"></a>客户端 API</h1><h2 id="浏览器-API"><a href="#浏览器-API" class="headerlink" title="浏览器 API"></a>浏览器 API</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model" target="_blank" rel="noopener">DOM（文档对象模型）</a><ul>
<li>window是载入浏览器的标签</li>
<li>navigator表示浏览器存在于web上的状态和标识（即用户代理）</li>
<li>document（在浏览器中用DOM表示）是载入窗口的实际页面</li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noopener">Fetch API</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" target="_blank" rel="noopener">Canvas</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API" target="_blank" rel="noopener">Web Storage API</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">IndexedDB API</a></li>
</ul>
<h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><h2 id="音频与视频"><a href="#音频与视频" class="headerlink" title="音频与视频"></a>音频与视频</h2><h2 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h2><h3 id="传统方法：cookie"><a href="#传统方法：cookie" class="headerlink" title="传统方法：cookie"></a>传统方法：cookie</h3><ul>
<li>过时、存在各种<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#安全" target="_blank" rel="noopener">安全问题</a>，而且无法存储复杂数据</li>
<li>唯一优势是它们得到了非常旧的浏览器的支持</li>
</ul>
<h3 id="新流派：Web-Storage-和-IndexedDB"><a href="#新流派：Web-Storage-和-IndexedDB" class="headerlink" title="新流派：Web Storage 和 IndexedDB"></a>新流派：Web Storage 和 IndexedDB</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API" target="_blank" rel="noopener">Web Storage API</a> 提供了一种非常简单的语法，用于存储和检索较小的、由名称和相应值组成的数据项。当您只需要存储一些简单的数据时，比如用户的名字，用户是否登录，屏幕背景使用了什么颜色等等，这是非常有用的。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">IndexedDB API</a> 为浏览器提供了一个完整的数据库系统来存储复杂的数据。这可以用于存储从完整的用户记录到甚至是复杂的数据类型，如音频或视频文件。</li>
</ul>
<h4 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h4><ul>
<li>所有的 web storage 数据都包含在浏览器内两个类似于对象的结构中： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage" target="_blank" rel="noopener"><code>sessionStorage</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="noopener"><code>localStorage</code></a>。 <ul>
<li>sessionStorage：只要浏览器开着，数据就会一直保存；关闭浏览器时数据会丢失</li>
<li>localStorage：一直保存数据，甚至到浏览器关闭又开启后也是这样</li>
</ul>
</li>
<li>每个域都有一个单独的数据存储区</li>
</ul>
<h4 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h4><h3 id="未来：Cache-API"><a href="#未来：Cache-API" class="headerlink" title="未来：Cache API"></a>未来：Cache API</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener"><code>Cache</code></a> API 是为存储特定HTTP请求的响应文件而设计的，它对于像存储离线网站文件这样的事情非常有用，这样网站就可以在没有网络连接的情况下使用。</li>
<li>缓存通常与 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service Worker API</a> 组合使用，尽管不一定非要这么做。</li>
</ul>

  </div>
</article>
      </main>
    </div>
  </body>
</html>