<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>学习笔记：React | life kicks in right now</title>
  <meta name="description" content="核心概念JSX 简介 JSX 是一个 JavaScript 的语法扩展 JSX 可以生成 React 元素  1const element &#x3D; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt;;  为什么使用 JSX？ React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合  React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之">
<meta property="og:type" content="article">
<meta property="og:title" content="学习笔记：React">
<meta property="og:url" content="http://ziiyan.github.io/2020/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AReact/index.html">
<meta property="og:site_name" content="life kicks in right now">
<meta property="og:description" content="核心概念JSX 简介 JSX 是一个 JavaScript 的语法扩展 JSX 可以生成 React 元素  1const element &#x3D; &lt;h1&gt;Hello, world!&lt;&#x2F;h1&gt;;  为什么使用 JSX？ React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合  React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-07T02:46:01.000Z">
<meta property="article:modified_time" content="2020-08-11T08:15:03.941Z">
<meta property="article:author" content="ziiyan">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://ziiyan.github.io/2020/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AReact/index.html">
  
    <link rel="alternate" href="/atom.xml" title="life kicks in right now" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css">
  
<meta name="generator" content="Hexo 4.2.0"></head>


<body class="main-center theme-purple" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/ziiyan" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Ziiyan</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Life kicks in right now</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> HangZhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/ziiyan" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>鶸挣扎记</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/" rel="tag">ECMAScript 6 入门</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" rel="tag">JavaScript高级程序设计</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWA/" rel="tag">PWA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E5%AE%83/" rel="tag">其它</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C/" rel="tag">工作</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD/" rel="tag">性能</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B2%BE%E8%AF%BB/" rel="tag">精读</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">16</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/CSS/" style="font-size: 13.33px;">CSS</a> <a href="/tags/ECMAScript-6-%E5%85%A5%E9%97%A8/" style="font-size: 13.78px;">ECMAScript 6 入门</a> <a href="/tags/HTML/" style="font-size: 13px;">HTML</a> <a href="/tags/Java/" style="font-size: 13px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 13.67px;">JavaScript</a> <a href="/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" style="font-size: 14px;">JavaScript高级程序设计</a> <a href="/tags/PWA/" style="font-size: 13px;">PWA</a> <a href="/tags/React/" style="font-size: 13.22px;">React</a> <a href="/tags/Vue/" style="font-size: 13.56px;">Vue</a> <a href="/tags/Webpack/" style="font-size: 13px;">Webpack</a> <a href="/tags/%E5%85%B6%E5%AE%83/" style="font-size: 13.11px;">其它</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 13.44px;">刷题</a> <a href="/tags/%E5%B7%A5%E4%BD%9C/" style="font-size: 13px;">工作</a> <a href="/tags/%E6%80%A7%E8%83%BD/" style="font-size: 13.22px;">性能</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13px;">数据结构</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 13.44px;">浏览器</a> <a href="/tags/%E7%B2%BE%E8%AF%BB/" style="font-size: 13px;">精读</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 13.33px;">网络</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 13px;">翻译</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13.89px;">面试</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">30</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/09/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%20&%20%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="title">面试准备：深拷贝 &amp; 浅拷贝</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-05T15:57:29.000Z" itemprop="datePublished">2020-09-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/09/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9Acall:apply:bind/" class="title">面试准备：call/apply/bind</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-05T14:49:41.000Z" itemprop="datePublished">2020-09-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/09/05/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/" class="title">面试准备：浏览器缓存</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-05T07:58:33.000Z" itemprop="datePublished">2020-09-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/09/04/%E7%BA%A2%E5%AE%9D%E4%B9%A68%EF%BC%9A%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="title">红宝书8：对象、类与面向对象编程</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-03T17:18:54.000Z" itemprop="datePublished">2020-09-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2020/09/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9Athis/" class="title">面试准备：this</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-03T15:27:45.000Z" itemprop="datePublished">2020-09-03</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#核心概念"><span class="toc-number">1.</span> <span class="toc-text">核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSX-简介"><span class="toc-number">1.1.</span> <span class="toc-text">JSX 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么使用-JSX？"><span class="toc-number">1.1.1.</span> <span class="toc-text">为什么使用 JSX？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元素渲染"><span class="toc-number">1.2.</span> <span class="toc-text">元素渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#将一个元素渲染为-DOM"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">将一个元素渲染为 DOM</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更新已渲染的元素"><span class="toc-number">1.2.1.</span> <span class="toc-text">更新已渲染的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-只更新它需要更新的部分"><span class="toc-number">1.2.2.</span> <span class="toc-text">React 只更新它需要更新的部分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件-amp-Props"><span class="toc-number">1.3.</span> <span class="toc-text">组件 &amp; Props</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#渲染组件"><span class="toc-number">1.3.1.</span> <span class="toc-text">渲染组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State-amp-生命周期"><span class="toc-number">1.4.</span> <span class="toc-text">State &amp; 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#正确地使用-State"><span class="toc-number">1.4.1.</span> <span class="toc-text">正确地使用 State</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#数据是自上而下的单向数据流"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">数据是自上而下的单向数据流</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生命周期"><span class="toc-number">1.4.2.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#生命周期方法"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">生命周期方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件处理"><span class="toc-number">1.5.</span> <span class="toc-text">事件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件渲染"><span class="toc-number">1.6.</span> <span class="toc-text">条件渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表-amp-Key"><span class="toc-number">1.7.</span> <span class="toc-text">列表 &amp; Key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#表单"><span class="toc-number">1.8.</span> <span class="toc-text">表单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#受控组件"><span class="toc-number">1.8.1.</span> <span class="toc-text">受控组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态提升"><span class="toc-number">1.9.</span> <span class="toc-text">状态提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合-vs-继承"><span class="toc-number">1.10.</span> <span class="toc-text">组合 vs 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#包含关系"><span class="toc-number">1.10.1.</span> <span class="toc-text">包含关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特例关系"><span class="toc-number">1.10.2.</span> <span class="toc-text">特例关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-哲学"><span class="toc-number">1.11.</span> <span class="toc-text">React 哲学</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高级指引"><span class="toc-number">2.</span> <span class="toc-text">高级指引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无障碍"><span class="toc-number">2.1.</span> <span class="toc-text">无障碍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码分割"><span class="toc-number">2.2.</span> <span class="toc-text">代码分割</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#动态-import-语法"><span class="toc-number">2.2.1.</span> <span class="toc-text">动态 import() 语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-lazy"><span class="toc-number">2.2.2.</span> <span class="toc-text">React.lazy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异常捕获边界（Error-boundaries）"><span class="toc-number">2.2.3.</span> <span class="toc-text">异常捕获边界（Error boundaries）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基于路由的代码分割"><span class="toc-number">2.2.4.</span> <span class="toc-text">基于路由的代码分割</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名导出（Named-Exports）"><span class="toc-number">2.2.5.</span> <span class="toc-text">命名导出（Named Exports）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Context"><span class="toc-number">2.3.</span> <span class="toc-text">Context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误边界（Error-Boundaries）"><span class="toc-number">2.4.</span> <span class="toc-text">错误边界（Error Boundaries）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于事件处理器"><span class="toc-number">2.4.1.</span> <span class="toc-text">关于事件处理器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Refs-amp-DOM"><span class="toc-number">2.5.</span> <span class="toc-text">Refs &amp; DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#场景"><span class="toc-number">2.5.1.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#勿过度使用-Refs"><span class="toc-number">2.5.2.</span> <span class="toc-text">勿过度使用 Refs</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Refs-转发"><span class="toc-number">2.6.</span> <span class="toc-text">Refs 转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非受控组件"><span class="toc-number">2.7.</span> <span class="toc-text">非受控组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fragments"><span class="toc-number">2.8.</span> <span class="toc-text">Fragments</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#短语法（不支持-key）"><span class="toc-number">2.8.1.</span> <span class="toc-text">短语法（不支持 key）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高阶组件（Higher-Order-Components）"><span class="toc-number">2.9.</span> <span class="toc-text">高阶组件（Higher-Order Components）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Render-Props"><span class="toc-number">2.10.</span> <span class="toc-text">Render Props</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与第三方库协同"><span class="toc-number">2.11.</span> <span class="toc-text">与第三方库协同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深入-JSX"><span class="toc-number">2.12.</span> <span class="toc-text">深入 JSX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Profiler"><span class="toc-number">2.13.</span> <span class="toc-text">Profiler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能优化"><span class="toc-number">2.14.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Profiler-1"><span class="toc-number">2.15.</span> <span class="toc-text">Profiler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态类型检查"><span class="toc-number">2.16.</span> <span class="toc-text">静态类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#严格模式"><span class="toc-number">2.17.</span> <span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协调（diffing-算法）-amp-key"><span class="toc-number">2.18.</span> <span class="toc-text">协调（diffing 算法）&amp; key</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API-REFERENCE"><span class="toc-number">3.</span> <span class="toc-text">API REFERENCE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React"><span class="toc-number">3.1.</span> <span class="toc-text">React</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#React-Component"><span class="toc-number">3.1.1.</span> <span class="toc-text">React.Component</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#生命周期图谱"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">生命周期图谱</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HOOK"><span class="toc-number">4.</span> <span class="toc-text">HOOK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试"><span class="toc-number">5.</span> <span class="toc-text">测试</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-学习笔记：React" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      学习笔记：React
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2020/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AReact/" class="article-date">
	  <time datetime="2020-08-07T02:46:01.000Z" itemprop="datePublished">2020-08-07</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/React/" rel="tag">React</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AReact/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="JSX-简介"><a href="#JSX-简介" class="headerlink" title="JSX 简介"></a>JSX 简介</h3><ul>
<li>JSX 是一个 JavaScript 的语法扩展</li>
<li>JSX 可以生成 React 元素</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="为什么使用-JSX？"><a href="#为什么使用-JSX？" class="headerlink" title="为什么使用 JSX？"></a>为什么使用 JSX？</h4><ul>
<li><p>React 认为<strong>渲染逻辑</strong>本质上与其他 UI 逻辑内在耦合</p>
</li>
<li><p>React 并没有采用将<em>标记与逻辑进行分离到不同文件</em>这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现<a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener"><em>关注点分离</em></a>。</p>
<ul>
<li><blockquote>
<p>关注点分离在<a href="https://zh.wikipedia.org/wiki/計算機科學" target="_blank" rel="noopener">计算机科学</a>中，是将计算机程序分隔为不同部分的设计原则，是<a href="https://zh.wikipedia.org/wiki/面向对象的程序设计" target="_blank" rel="noopener">面向对象的程序设计</a>的核心概念。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h3><ul>
<li>元素是构成 React 应用的最小砖块</li>
</ul>
<blockquote>
<p>与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。</p>
</blockquote>
<h5 id="将一个元素渲染为-DOM"><a href="#将一个元素渲染为-DOM" class="headerlink" title="将一个元素渲染为 DOM"></a>将一个元素渲染为 DOM</h5><ul>
<li>想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入  <code>React DOM.render()</code></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>

<h4 id="更新已渲染的元素"><a href="#更新已渲染的元素" class="headerlink" title="更新已渲染的元素"></a>更新已渲染的元素</h4><ul>
<li>React 元素是不可变对象。一个元素就像电影的单帧，代表了某个特定时刻的 UI</li>
<li>更新 UI 唯一的方式是创建一个全新的元素，并将其传入 <code>React DOM.render()</code></li>
</ul>
<h4 id="React-只更新它需要更新的部分"><a href="#React-只更新它需要更新的部分" class="headerlink" title="React 只更新它需要更新的部分"></a>React 只更新它需要更新的部分</h4><blockquote>
<p>React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。</p>
</blockquote>
<h3 id="组件-amp-Props"><a href="#组件-amp-Props" class="headerlink" title="组件 &amp; Props"></a>组件 &amp; Props</h3><ul>
<li>组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思</li>
<li>组件，从概念上类似于 JavaScript 函数。接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素</li>
</ul>
<h4 id="渲染组件"><a href="#渲染组件" class="headerlink" title="渲染组件"></a>渲染组件</h4><blockquote>
<p>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。</p>
<p><strong>注意：</strong> 组件名称必须以大写字母开头。</p>
</blockquote>
<ul>
<li>props 是只读的</li>
</ul>
<h3 id="State-amp-生命周期"><a href="#State-amp-生命周期" class="headerlink" title="State &amp; 生命周期"></a>State &amp; 生命周期</h3><h4 id="正确地使用-State"><a href="#正确地使用-State" class="headerlink" title="正确地使用 State"></a>正确地使用 State</h4><ul>
<li>不要直接修改 State，用 <code>setState({ key: value })</code></li>
<li>State  的更新可能是异步的<ul>
<li>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用</li>
<li>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态</li>
<li>要解决这个问题，可以让 <code>setState()</code> 接收一个函数而不是一个对象</li>
</ul>
</li>
<li>调用 <code>setState()</code> 的时候，React 会把对象合并到当前的 state，因此只需调用需要更改的部分</li>
<li><strong>不要将 props 的值复制给 state</strong>，props 更新不会影响 state，<strong>只有在刻意忽略 prop 更新的情况下使用</strong></li>
</ul>
<h5 id="数据是自上而下的单向数据流"><a href="#数据是自上而下的单向数据流" class="headerlink" title="数据是自上而下的单向数据流"></a>数据是自上而下的单向数据流</h5><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><h5 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h5><ul>
<li>componentDidMount：组件已经被渲染到 DOM 中后运行</li>
<li>componentWillUnmount：组件从 DOM 中被移除时运行</li>
</ul>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul>
<li>事件命名采用小驼峰，传入函数作为事件处理函数</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"activateLasers()"</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsx</span></span><br><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不能通过 <code>return false</code> 阻止默认行为，必须显示使用 <code>preventDefault</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span></span><br><span class="line">  Click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsx</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The link was clicked.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>e 是一个合成事件，根据 W3C 规范定义 e，不必担心跨浏览器的兼容问题</p>
</blockquote>
<ul>
<li>通常的做法是将事件处理函数声明为 class 中的方法</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isToggleOn ? <span class="string">'ON'</span> : <span class="string">'OFF'</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;Toggle /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 JavaScript 中，class 的方法默认不会<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">绑定</a> <code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code>。</p>
<p>如果觉得使用 <code>bind</code> 很麻烦，这里有两种方式可以解决</p>
<ul>
<li>实验性的 <a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">public class fields 语法</a></li>
<li>回调中使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a><ul>
<li>每次渲染都会创建不同的回调函数，如果传入子组件会进行额外的重新渲染</li>
<li>建议不要使用这种方式</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>向事件处理程序传递参数</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><ul>
<li><p>依据应用的不同状态，只渲染对应状态下的部分内容</p>
</li>
<li><p>使用变量来储存元素，称为元素变量</p>
</li>
<li><p>通过花括号包裹代码可以嵌入表达式</p>
<ul>
<li>&amp;&amp;</li>
<li>三目运算符</li>
</ul>
</li>
<li><p><code>return null</code> 不进行渲染，不影响组件生命周期</p>
</li>
</ul>
<h3 id="列表-amp-Key"><a href="#列表-amp-Key" class="headerlink" title="列表 &amp; Key"></a>列表 &amp; Key</h3><ul>
<li>key 帮助 React 识别哪些元素改变了，应当给数组中的每一个元素赋予一个确定的标识</li>
<li>一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串</li>
<li>一个好的经验法则是：在 <code>map()</code> 方法中的元素需要设置 key 属性</li>
<li>数组元素中使用的 key 在其兄弟节点之间应该是独一无二的，不需要全局唯一</li>
<li>key 会传递信息给 React ，但不会传递给组件</li>
</ul>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><ul>
<li>state 成为“唯一数据源”，组件控制表单操作</li>
<li>对于受控组件来说，输入的值始终由 React 的 state 驱动</li>
<li>当需要处理多个 <code>input</code> 元素时，可以给每个元素添加 <code>name</code> 属性，并让处理函数根据 <code>event.target.name</code> 的值选择要执行的操作</li>
<li>受控组件组织用户更改输入，如果指定 <code>value</code> 仍可以编辑，可能 <code>value</code> 为 <code>undefined</code> 或 <code>null</code></li>
</ul>
<h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><ul>
<li>多个组件需要反映相同的变化数据，建议将共享状态提升到最近的共同父组件中</li>
</ul>
<blockquote>
<p>任何可变数据应当只有一个相对应的唯一“数据源</p>
<p>state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中</p>
<p>应当依靠<a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html#the-data-flows-down" target="_blank" rel="noopener">自上而下的数据流</a>，而不是尝试在不同组件间同步 state</p>
</blockquote>
<h3 id="组合-vs-继承"><a href="#组合-vs-继承" class="headerlink" title="组合 vs 继承"></a>组合 vs 继承</h3><ul>
<li>推荐使用组合实现代码重用</li>
</ul>
<h4 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h4><ul>
<li>通过 <code>props.children</code> 将获取所有子标签</li>
</ul>
<h4 id="特例关系"><a href="#特例关系" class="headerlink" title="特例关系"></a>特例关系</h4><ul>
<li>“特殊”组件可以通过 props 定制并渲染“一般”组件</li>
</ul>
<blockquote>
<p>不建议用继承。</p>
<p>组件可以接受任意 props，包括基本数据类型，React 元素以及函数。</p>
<p>如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。</p>
</blockquote>
<h3 id="React-哲学"><a href="#React-哲学" class="headerlink" title="React 哲学"></a>React 哲学</h3><ol>
<li><p>将 UI 划分为组件层级</p>
<ul>
<li>单一功能原则</li>
</ul>
</li>
<li><p>创建一个不含交互功能的静态版本</p>
<ul>
<li>将渲染 UI 和添加交互这两个过程分开</li>
<li>该阶段<strong>不应该使用 state</strong></li>
<li>自上而下：适合比较简单的项目</li>
<li>自下而上：适合大型的项目，并同时为低层组件编写测试</li>
</ul>
</li>
<li><p>确定 UI state 的最小表示</p>
<ul>
<li>DRY ( Don’t Repeat Yourself )</li>
<li>只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生<ul>
<li>如：只需要保存数组，无需保存数组长度，因为长度可以通过数组的 length 属性获取</li>
</ul>
</li>
<li>check list：<ul>
<li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li>
<li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li>
<li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li>
</ul>
</li>
</ul>
</li>
<li><p>确定 state 放置的位置</p>
<ul>
<li>对于应用中的每一个 state：<ul>
<li>找到根据这个 state 进行渲染的所有组件。</li>
<li>找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。</li>
<li>该共同所有者组件或者比它层级更高的组件应该拥有该 state。</li>
<li>如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。</li>
</ul>
</li>
</ul>
</li>
<li><p>添加反向数据流</p>
<ul>
<li>处于较低层级的组件更新较高层级的组件中的 state</li>
<li>父组件将一个能够触发 state 改变的回调函数（callback）传递给子组件</li>
</ul>
</li>
</ol>
<h2 id="高级指引"><a href="#高级指引" class="headerlink" title="高级指引"></a>高级指引</h2><h3 id="无障碍"><a href="#无障碍" class="headerlink" title="无障碍"></a>无障碍</h3><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><ul>
<li>代码分割能够“懒加载”当前用户所需要的内容，显著地提高应用性能</li>
<li>没有减少应用整体的代码体积，可以避免加载用户永远不需要的代码，并在初始加载的时候减少所需加载的代码量</li>
</ul>
<h4 id="动态-import-语法"><a href="#动态-import-语法" class="headerlink" title="动态 import() 语法"></a>动态 import() 语法</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">16</span>, <span class="number">26</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">"./math"</span>).then(<span class="function"><span class="params">math</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(math.add(<span class="number">16</span>, <span class="number">26</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当使用 <a href="https://babel.docschina.org/" target="_blank" rel="noopener">Babel</a> 时，你要确保 Babel 能够解析动态 import 语法而不是将其进行转换。对于这一要求你需要 <a href="https://yarnpkg.com/en/package/babel-plugin-syntax-dynamic-import" target="_blank" rel="noopener">babel-plugin-syntax-dynamic-import</a> 插件。</p>
</blockquote>
<h4 id="React-lazy"><a href="#React-lazy" class="headerlink" title="React.lazy"></a>React.lazy</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> OtherComponent <span class="keyword">from</span> <span class="string">'./OtherComponent'</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>React.lazy</code> 接受一个函数，这个函数需要动态调用 <code>import()</code>。它必须返回一个 <code>Promise</code>，该 Promise 需要 resolve 一个 <code>default</code> export 的 React 组件。</p>
<p>然后应在 <code>Suspense</code> 组件中渲染 lazy 组件，<code>fallback</code> 属性接受任何在组件加载过程中你想展示的 React 元素。你可以将 <code>Suspense</code> 组件置于懒加载组件之上的任何位置。你甚至可以用一个 <code>Suspense</code> 组件包裹多个懒加载组件。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Suspense &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> OtherComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;OtherComponent /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常捕获边界（Error-boundaries）"><a href="#异常捕获边界（Error-boundaries）" class="headerlink" title="异常捕获边界（Error boundaries）"></a>异常捕获边界（Error boundaries）</h4><ul>
<li>如果模块加载失败（如网络问题），它会触发一个错误，可以通过<a href="https://zh-hans.reactjs.org/docs/error-boundaries.html" target="_blank" rel="noopener">异常捕获边界（Error boundaries）</a>技术来处理这些情况</li>
</ul>
<h4 id="基于路由的代码分割"><a href="#基于路由的代码分割" class="headerlink" title="基于路由的代码分割"></a>基于路由的代码分割</h4><h4 id="命名导出（Named-Exports）"><a href="#命名导出（Named-Exports）" class="headerlink" title="命名导出（Named Exports）"></a>命名导出（Named Exports）</h4><blockquote>
<p><code>React.lazy</code> 目前只支持默认导出（default exports）。如果你想被引入的模块使用命名导出（named exports），你可以创建一个中间模块，来重新导出为默认模块。这能保证 tree shaking 不会出错，并且不必引入不需要的组件。</p>
</blockquote>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><ul>
<li>组件之间共享的值，如 主题、当前用户、首选语言 等全局属性</li>
<li>API<ul>
<li><code>React.createContext</code></li>
<li><code>Context.Provider</code></li>
<li><code>Class.contextType</code></li>
<li><code>Context.Consumer</code></li>
<li><code>Context.displayName</code></li>
</ul>
</li>
</ul>
<h3 id="错误边界（Error-Boundaries）"><a href="#错误边界（Error-Boundaries）" class="headerlink" title="错误边界（Error Boundaries）"></a>错误边界（Error Boundaries）</h3><ul>
<li>错误边界是一种 React 组件，这种组件<strong>可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI</strong>，而不是渲染那些崩溃了的子组件树。</li>
<li>错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</li>
<li>错误边界的工作方式类似于 JavaScript 的 <code>catch {}</code>，不同的地方在于错误边界只针对 React 组件。</li>
<li>只有 class 组件才可以成为错误边界组件。</li>
<li>大多数情况下，你只需要声明一次错误边界组件，并在整个应用中使用它。</li>
<li>注意<strong>错误边界仅可以捕获其子组件的错误</strong>，它无法捕获其自身的错误。</li>
<li><strong>任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载</strong>。</li>
</ul>
<h4 id="关于事件处理器"><a href="#关于事件处理器" class="headerlink" title="关于事件处理器"></a>关于事件处理器</h4><ul>
<li>错误边界<strong>无法</strong>捕获事件处理器内部的错误。</li>
<li>如果需要在事件处理器内部捕获错误，使用普通的 JavaScript <code>try</code> / <code>catch</code> 语句。</li>
</ul>
<h3 id="Refs-amp-DOM"><a href="#Refs-amp-DOM" class="headerlink" title="Refs &amp; DOM"></a>Refs &amp; DOM</h3><ul>
<li>在典型的 React 数据流中，<a href="https://zh-hans.reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">props</a> 是父组件与子组件交互的唯一方式</li>
<li>Refs 提供了一种方式，允许访问 DOM 节点或在 render 方法中创建的 React 元素</li>
</ul>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul>
<li>管理焦点，文本选择或媒体播放</li>
<li>触发强制动画</li>
<li>集成第三方 DOM 库</li>
</ul>
<h4 id="勿过度使用-Refs"><a href="#勿过度使用-Refs" class="headerlink" title="勿过度使用 Refs"></a>勿过度使用 Refs</h4><ul>
<li>创建：构造函数中 <code>this.myRef = React.createRef()</code></li>
<li>访问：<code>const node = this.myRef.current</code><ul>
<li>当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。</li>
<li>当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</li>
<li><strong>不能在函数组件上使用 <code>ref</code> 属性</strong>，因为他们没有实例。</li>
</ul>
</li>
</ul>
<h3 id="Refs-转发"><a href="#Refs-转发" class="headerlink" title="Refs 转发"></a>Refs 转发</h3><ul>
<li>Ref 转发是一项将 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">ref</a> 自动地通过组件传递到其一子组件的技巧</li>
</ul>
<h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><ul>
<li>受控组件，表单数据是由 React 组件来管理的</li>
<li>非受控组件，表单数据将交由 DOM 节点来处理<ul>
<li>可以 <a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">使用 ref</a> 来从 DOM 节点中获取表单数据</li>
</ul>
</li>
<li>默认值<ul>
<li>在 React 渲染生命周期时，表单元素上的 <code>value</code> 将会覆盖 DOM 节点中的值，在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 <code>defaultValue</code> 属性，而不是 <code>value</code>。</li>
</ul>
</li>
<li>在 React 中，<code>&lt;input type=&quot;file&quot; /&gt;</code> 始终是一个非受控组件，因为它的值只能由用户设置，而不能通过代码控制。</li>
</ul>
<h3 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h3><ul>
<li>Fragments 将子列表分组，无需向 DOM 添加额外节点</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Columns</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;React.Fragment key=&#123;...&#125;&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;td&gt;World&lt;/</span>td&gt;</span><br><span class="line">      &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="短语法（不支持-key）"><a href="#短语法（不支持-key）" class="headerlink" title="短语法（不支持 key）"></a>短语法（不支持 key）</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Columns</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;td&gt;World&lt;/</span>td&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="高阶组件（Higher-Order-Components）"><a href="#高阶组件（Higher-Order-Components）" class="headerlink" title="高阶组件（Higher-Order Components）"></a>高阶组件（Higher-Order Components）</h3><ul>
<li>用于复用组件逻辑的一种高级技巧，基于 React 的组合特性而形成的<strong>设计模式</strong></li>
<li>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件</li>
<li><strong>高阶组件是参数为组件，返回值为新组件的函数</strong></li>
</ul>
<h3 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h3><ul>
<li><strong>render prop 是一个用于告知组件需要渲染什么内容的函数 prop</strong></li>
<li>可以使用带有 render prop 的常规组件来实现大多数<a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">高阶组件</a></li>
</ul>
<h3 id="与第三方库协同"><a href="#与第三方库协同" class="headerlink" title="与第三方库协同"></a>与第三方库协同</h3><ul>
<li>React 不会理会 React 自身之外的 DOM 操作</li>
<li>它根据内部虚拟 DOM 来决定是否需要更新，而且如果同一个 DOM 节点被另一个库操作了，React 会觉得困惑而且没有办法恢复。</li>
</ul>
<h3 id="深入-JSX"><a href="#深入-JSX" class="headerlink" title="深入 JSX"></a>深入 JSX</h3><ul>
<li>实际上，JSX 仅仅只是 <code>React.createElement(component, props, ...children)</code> 函数的语法糖</li>
</ul>
<h3 id="Profiler"><a href="#Profiler" class="headerlink" title="Profiler"></a>Profiler</h3><ul>
<li>将子节点渲染到存在于父组件以外的 DOM 节点</li>
</ul>
<p><code>ReactDOM.createPortal(child, container)</code></p>
<ul>
<li>场景当父组件有 <code>overflow: hidden</code> 或 <code>z-index</code> ，但需要子组件能够在视觉上“跳出”其容器。<ul>
<li>如对话框、悬浮卡以及提示框</li>
</ul>
</li>
<li>其他方面，其行为和普通的 React 子节点行为一致<ul>
<li>如冒泡事件，从 portal 内部触发的事件会一直冒泡至包含React 树的祖先，即便这些元素并不是DOM 树中的祖先</li>
</ul>
</li>
</ul>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h3 id="Profiler-1"><a href="#Profiler-1" class="headerlink" title="Profiler"></a>Profiler</h3><ul>
<li>测量渲染一个 React 应用多久渲染一次以及渲染一次的“代价”，目的是识别渲染慢的部分，以便优化</li>
</ul>
<h3 id="静态类型检查"><a href="#静态类型检查" class="headerlink" title="静态类型检查"></a>静态类型检查</h3><ul>
<li><p>PropTypes</p>
</li>
<li><p>建议大型代码库中使用 Flow 或 TypeScript 来代替 <code>PropTypes</code></p>
</li>
</ul>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><h3 id="协调（diffing-算法）-amp-key"><a href="#协调（diffing-算法）-amp-key" class="headerlink" title="协调（diffing 算法）&amp; key"></a>协调（diffing 算法）&amp; key</h3><blockquote>
<p>当组件的 props 或 state 发生变化时，React 通过将最新返回的元素与原先渲染的元素进行比较，来决定是否有必要进行一次实际的 DOM 更新。当它们不相等时，React 才会更新 DOM。这个过程被称为“协调”。</p>
</blockquote>
<ul>
<li><p>对比不同类型的元素</p>
<ul>
<li>根节点为不同类型的元素时，React 会拆卸原有的树并建立新的树</li>
<li>当拆卸一棵树时，对应的 DOM 节点也会被销毁，执行 <code>componentWillUnmount</code></li>
<li>当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中，执行 <code>componentWillMount</code> 及 <code>componentDidMount</code></li>
</ul>
</li>
<li><p>对比同类型的元素</p>
<ul>
<li>保留 DOM 节点，仅比对及更新有改变的属性</li>
</ul>
</li>
<li><p>对比同类型的组件元素</p>
<ul>
<li>当一个组件更新时，组件实例保持不变</li>
</ul>
</li>
<li><p>对子节点进行递归</p>
<ul>
<li>在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation</li>
<li>直接列表尾部插入没问题，但首部插入时，无法感知原来的元素被移动了，都会因匹配不成功生成新元素</li>
<li>用唯一 key 标识元素，因此建议不用下标做 key，因为下标也会因为移动而改变，而无法达到识别元素移动的目的</li>
</ul>
</li>
</ul>
<h2 id="API-REFERENCE"><a href="#API-REFERENCE" class="headerlink" title="API REFERENCE"></a>API REFERENCE</h2><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h4 id="React-Component"><a href="#React-Component" class="headerlink" title="React.Component"></a>React.Component</h4><h5 id="生命周期图谱"><a href="#生命周期图谱" class="headerlink" title="生命周期图谱"></a><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener">生命周期图谱</a></h5><ul>
<li><strong>挂载</strong>：当组件实例被创建并插入 DOM 中<ul>
<li><strong>constructor()</strong><ul>
<li>如果不初始化 state 或不进行方法绑定，则不需要实现</li>
</ul>
</li>
<li>static getDerivedStateFromProps()</li>
<li><strong>render()</strong><ul>
<li><code>render()</code> 应该为纯函数</li>
<li>class 组件中唯一必须实现的方法</li>
</ul>
</li>
<li><strong>componentDidMount()</strong><ul>
<li>组件挂载后（插入 DOM 树中）立即调用</li>
<li>依赖于 DOM 节点的初始化应该放在这里</li>
</ul>
</li>
</ul>
</li>
<li><strong>更新</strong>：props 或 state 发生变化时触发更新<ul>
<li>static getDerivedStateFromProps() </li>
<li>shouldComponentUpdate()</li>
<li><strong>render()</strong></li>
<li>getSnapshotBeforeUpdate()</li>
<li><strong>componentDidUpdate()</strong><ul>
<li>更新后会被立即调用</li>
<li>首次渲染不会执行此方法</li>
</ul>
</li>
</ul>
</li>
<li><strong>卸载</strong>：组件从 DOM 中移除<ul>
<li><strong>componentWillUnmount()</strong><ul>
<li>组件卸载及销毁之前直接调用</li>
<li>执行必要的清理操作</li>
</ul>
</li>
</ul>
</li>
<li><strong>错误处理</strong>：抛出错误时<ul>
<li>static getDerivedStateFromError() </li>
<li>componentDidCatch()</li>
</ul>
</li>
</ul>
<h2 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h2><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li><a href="https://jestjs.io/" target="_blank" rel="noopener">Jest</a></li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://ziiyan.github.io/2020/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AReact/" title="学习笔记：React" target="_blank" rel="external">http://ziiyan.github.io/2020/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AReact/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/ziiyan" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/ziiyan" target="_blank"><span class="text-dark">Ziiyan</span><small class="ml-1x">Life kicks in right now</small></a></h3>
        <div>因上努力，果上随缘</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
           
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2020/08/11/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9A%E8%99%9A%E6%8B%9FDOM/" title="面试准备：虚拟 DOM"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2020/08/06/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/" title="面试准备：双向绑定原理"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/ziiyan" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '25953118',
    clientSecret: 'wzy574542379',
    repo: 'https://github.com/ziiyan',
    owner: 'ziiyan',
    admin: ['ziiyan'],
    id: md5(location.pathname),
    distractionFreeMode: true
  })
  gitalk.render('comments')
  </script>

      







</body>
</html>